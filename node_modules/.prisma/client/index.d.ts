
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model CALL
 */

export type CALL = {
  seq: number
  createdAt: Date | null
  expiredAt: Date | null
  status: CALL_status | null
  calltext: string | null
  price: number
}

/**
 * Model CART
 */

export type CART = {
  seq: number
  request: string | null
}

/**
 * Model CHAT
 */

export type CHAT = {
  seq: number
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model LOCATION
 */

export type LOCATION = {
  seq: number
  latitude: number
  longitude: number
  address: string
}

/**
 * Model MENU
 */

export type MENU = {
  seq: number
  name: string
  thumbnail: string | null
  description: string | null
  price: number
  isAvailable: boolean
  bestmenu: boolean
}

/**
 * Model MESSAGE
 */

export type MESSAGE = {
  seq: number
  text: string
  isRead: boolean
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model OPTION
 */

export type OPTION = {
  seq: number
  category: string
  isRequired: boolean
  isMultiple: boolean
}

/**
 * Model OPTION_ITEM
 */

export type OPTION_ITEM = {
  seq: number
  content: string
  price: number
}

/**
 * Model ORDER
 */

export type ORDER = {
  seq: number
  createdAt: Date
  updatedAt: Date
  deliveryTime: Date
  status: ORDER_status | null
}

/**
 * Model REPLY
 */

export type REPLY = {
  seq: number
  content: string
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model REPORT
 */

export type REPORT = {
  seq: number
  reason: string
  isSolved: boolean
  createdAt: Date
  updatedAt: Date | null
}

/**
 * Model RES_REVIEW
 */

export type RES_REVIEW = {
  seq: number
  createdAt: Date
  updatedAt: Date | null
  rate: number
  content: string
  image: string | null
}

/**
 * Model RESTAURANT
 */

export type RESTAURANT = {
  seq: number
  id: string
  password: string
  createdAt: Date
  dayoff: string
  isOpen: boolean
  minOrder: number
  deliveryTip: number
  seperatable: boolean
  introduction: string | null
  thumbnail: string | null
  rate: number
  category: string
}

/**
 * Model RUN_TIME
 */

export type RUN_TIME = {
  seq: number
  day: string
  open: Date
  close: Date
}

/**
 * Model SELECTED_MENU
 */

export type SELECTED_MENU = {
  seq: number
  count: number
}

/**
 * Model USER
 */

export type USER = {
  seq: number
  ID: string
  password: string
  name: string
  createdAt: Date | null
  updatedAt: Date | null
  thumbnail: string | null
  token: string
  status: USER_status
}

/**
 * Model USER_REVIEW
 */

export type USER_REVIEW = {
  seq: number
  createdAt: Date
  updatedAt: Date | null
  rate: number
  content: string | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const CALL_status: {
  isActivated: 'isActivated',
  isMatched: 'isMatched',
  isExpired: 'isExpired',
  isCompleted: 'isCompleted'
};

export type CALL_status = (typeof CALL_status)[keyof typeof CALL_status]


export const ORDER_status: {
  Recieved: 'Recieved',
  inDelivery: 'inDelivery',
  canceled: 'canceled',
  completed: 'completed'
};

export type ORDER_status = (typeof ORDER_status)[keyof typeof ORDER_status]


export const USER_status: {
  Active: 'Active',
  Stop: 'Stop',
  Withdraw: 'Withdraw'
};

export type USER_status = (typeof USER_status)[keyof typeof USER_status]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CALLS
 * const cALLS = await prisma.cALL.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CALLS
   * const cALLS = await prisma.cALL.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.cALL`: Exposes CRUD operations for the **CALL** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CALLS
    * const cALLS = await prisma.cALL.findMany()
    * ```
    */
  get cALL(): Prisma.CALLDelegate<GlobalReject>;

  /**
   * `prisma.cART`: Exposes CRUD operations for the **CART** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CARTS
    * const cARTS = await prisma.cART.findMany()
    * ```
    */
  get cART(): Prisma.CARTDelegate<GlobalReject>;

  /**
   * `prisma.cHAT`: Exposes CRUD operations for the **CHAT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CHATS
    * const cHATS = await prisma.cHAT.findMany()
    * ```
    */
  get cHAT(): Prisma.CHATDelegate<GlobalReject>;

  /**
   * `prisma.lOCATION`: Exposes CRUD operations for the **LOCATION** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LOCATIONS
    * const lOCATIONS = await prisma.lOCATION.findMany()
    * ```
    */
  get lOCATION(): Prisma.LOCATIONDelegate<GlobalReject>;

  /**
   * `prisma.mENU`: Exposes CRUD operations for the **MENU** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MENUS
    * const mENUS = await prisma.mENU.findMany()
    * ```
    */
  get mENU(): Prisma.MENUDelegate<GlobalReject>;

  /**
   * `prisma.mESSAGE`: Exposes CRUD operations for the **MESSAGE** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MESSAGES
    * const mESSAGES = await prisma.mESSAGE.findMany()
    * ```
    */
  get mESSAGE(): Prisma.MESSAGEDelegate<GlobalReject>;

  /**
   * `prisma.oPTION`: Exposes CRUD operations for the **OPTION** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OPTIONS
    * const oPTIONS = await prisma.oPTION.findMany()
    * ```
    */
  get oPTION(): Prisma.OPTIONDelegate<GlobalReject>;

  /**
   * `prisma.oPTION_ITEM`: Exposes CRUD operations for the **OPTION_ITEM** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OPTION_ITEMS
    * const oPTION_ITEMS = await prisma.oPTION_ITEM.findMany()
    * ```
    */
  get oPTION_ITEM(): Prisma.OPTION_ITEMDelegate<GlobalReject>;

  /**
   * `prisma.oRDER`: Exposes CRUD operations for the **ORDER** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ORDERS
    * const oRDERS = await prisma.oRDER.findMany()
    * ```
    */
  get oRDER(): Prisma.ORDERDelegate<GlobalReject>;

  /**
   * `prisma.rEPLY`: Exposes CRUD operations for the **REPLY** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REPLIES
    * const rEPLIES = await prisma.rEPLY.findMany()
    * ```
    */
  get rEPLY(): Prisma.REPLYDelegate<GlobalReject>;

  /**
   * `prisma.rEPORT`: Exposes CRUD operations for the **REPORT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more REPORTS
    * const rEPORTS = await prisma.rEPORT.findMany()
    * ```
    */
  get rEPORT(): Prisma.REPORTDelegate<GlobalReject>;

  /**
   * `prisma.rES_REVIEW`: Exposes CRUD operations for the **RES_REVIEW** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RES_REVIEWS
    * const rES_REVIEWS = await prisma.rES_REVIEW.findMany()
    * ```
    */
  get rES_REVIEW(): Prisma.RES_REVIEWDelegate<GlobalReject>;

  /**
   * `prisma.rESTAURANT`: Exposes CRUD operations for the **RESTAURANT** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RESTAURANTS
    * const rESTAURANTS = await prisma.rESTAURANT.findMany()
    * ```
    */
  get rESTAURANT(): Prisma.RESTAURANTDelegate<GlobalReject>;

  /**
   * `prisma.rUN_TIME`: Exposes CRUD operations for the **RUN_TIME** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RUN_TIMES
    * const rUN_TIMES = await prisma.rUN_TIME.findMany()
    * ```
    */
  get rUN_TIME(): Prisma.RUN_TIMEDelegate<GlobalReject>;

  /**
   * `prisma.sELECTED_MENU`: Exposes CRUD operations for the **SELECTED_MENU** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SELECTED_MENUS
    * const sELECTED_MENUS = await prisma.sELECTED_MENU.findMany()
    * ```
    */
  get sELECTED_MENU(): Prisma.SELECTED_MENUDelegate<GlobalReject>;

  /**
   * `prisma.uSER`: Exposes CRUD operations for the **USER** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more USERS
    * const uSERS = await prisma.uSER.findMany()
    * ```
    */
  get uSER(): Prisma.USERDelegate<GlobalReject>;

  /**
   * `prisma.uSER_REVIEW`: Exposes CRUD operations for the **USER_REVIEW** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more USER_REVIEWS
    * const uSER_REVIEWS = await prisma.uSER_REVIEW.findMany()
    * ```
    */
  get uSER_REVIEW(): Prisma.USER_REVIEWDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.20.1
   * Query Engine version: 60ba6551f29b17d7d6ce479e5733c70d9c00860e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    CALL: 'CALL',
    CART: 'CART',
    CHAT: 'CHAT',
    LOCATION: 'LOCATION',
    MENU: 'MENU',
    MESSAGE: 'MESSAGE',
    OPTION: 'OPTION',
    OPTION_ITEM: 'OPTION_ITEM',
    ORDER: 'ORDER',
    REPLY: 'REPLY',
    REPORT: 'REPORT',
    RES_REVIEW: 'RES_REVIEW',
    RESTAURANT: 'RESTAURANT',
    RUN_TIME: 'RUN_TIME',
    SELECTED_MENU: 'SELECTED_MENU',
    USER: 'USER',
    USER_REVIEW: 'USER_REVIEW'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model CALL
   */


  export type AggregateCALL = {
    count: CALLCountAggregateOutputType | null
    avg: CALLAvgAggregateOutputType | null
    sum: CALLSumAggregateOutputType | null
    min: CALLMinAggregateOutputType | null
    max: CALLMaxAggregateOutputType | null
  }

  export type CALLAvgAggregateOutputType = {
    seq: number
    price: number
  }

  export type CALLSumAggregateOutputType = {
    seq: number
    price: number
  }

  export type CALLMinAggregateOutputType = {
    seq: number
    createdAt: Date | null
    expiredAt: Date | null
    status: CALL_status | null
    calltext: string | null
    price: number
  }

  export type CALLMaxAggregateOutputType = {
    seq: number
    createdAt: Date | null
    expiredAt: Date | null
    status: CALL_status | null
    calltext: string | null
    price: number
  }

  export type CALLCountAggregateOutputType = {
    seq: number
    createdAt: number | null
    expiredAt: number | null
    status: number | null
    calltext: number | null
    price: number
    _all: number
  }


  export type CALLAvgAggregateInputType = {
    seq?: true
    price?: true
  }

  export type CALLSumAggregateInputType = {
    seq?: true
    price?: true
  }

  export type CALLMinAggregateInputType = {
    seq?: true
    createdAt?: true
    expiredAt?: true
    status?: true
    calltext?: true
    price?: true
  }

  export type CALLMaxAggregateInputType = {
    seq?: true
    createdAt?: true
    expiredAt?: true
    status?: true
    calltext?: true
    price?: true
  }

  export type CALLCountAggregateInputType = {
    seq?: true
    createdAt?: true
    expiredAt?: true
    status?: true
    calltext?: true
    price?: true
    _all?: true
  }

  export type CALLAggregateArgs = {
    /**
     * Filter which CALL to aggregate.
    **/
    where?: CALLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CALLS to fetch.
    **/
    orderBy?: Enumerable<CALLOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CALLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CALLS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CALLS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CALLS
    **/
    count?: true | CALLCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CALLAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CALLSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CALLMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CALLMaxAggregateInputType
  }

  export type GetCALLAggregateType<T extends CALLAggregateArgs> = {
    [P in keyof T & keyof AggregateCALL]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCALL[P]>
      : GetScalarType<T[P], AggregateCALL[P]>
  }


    
    
  export type CALLGroupByArgs = {
    where?: CALLWhereInput
    orderBy?: Enumerable<CALLOrderByInput>
    by: Array<CALLScalarFieldEnum>
    having?: CALLScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CALLCountAggregateInputType | true
    avg?: CALLAvgAggregateInputType
    sum?: CALLSumAggregateInputType
    min?: CALLMinAggregateInputType
    max?: CALLMaxAggregateInputType
  }


  export type CALLGroupByOutputType = {
    seq: number
    createdAt: Date | null
    expiredAt: Date | null
    status: CALL_status | null
    calltext: string | null
    price: number
    count: CALLCountAggregateOutputType | null
    avg: CALLAvgAggregateOutputType | null
    sum: CALLSumAggregateOutputType | null
    min: CALLMinAggregateOutputType | null
    max: CALLMaxAggregateOutputType | null
  }

  type GetCALLGroupByPayload<T extends CALLGroupByArgs> = Promise<Array<
    PickArray<CALLGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CALLGroupByOutputType))]: GetScalarType<T[P], CALLGroupByOutputType[P]>
    }
  >>
    

  export type CALLSelect = {
    seq?: boolean
    createdAt?: boolean
    expiredAt?: boolean
    status?: boolean
    calltext?: boolean
    price?: boolean
    RESTAURANT?: boolean | RESTAURANTArgs
    LOCATION?: boolean | LOCATIONArgs
    USER?: boolean | USERArgs
    CART?: boolean | CARTArgs
    ORDER?: boolean | ORDERArgs
  }

  export type CALLInclude = {
    RESTAURANT?: boolean | RESTAURANTArgs
    LOCATION?: boolean | LOCATIONArgs
    USER?: boolean | USERArgs
    CART?: boolean | CARTArgs
    ORDER?: boolean | ORDERArgs
  }

  export type CALLGetPayload<
    S extends boolean | null | undefined | CALLArgs,
    U = keyof S
      > = S extends true
        ? CALL
    : S extends undefined
    ? never
    : S extends CALLArgs | CALLFindManyArgs
    ?'include' extends U
    ? CALL  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'RESTAURANT'
        ? RESTAURANTGetPayload<S['include'][P]> :
        P extends 'LOCATION'
        ? LOCATIONGetPayload<S['include'][P]> :
        P extends 'USER'
        ? USERGetPayload<S['include'][P]> :
        P extends 'CART'
        ? CARTGetPayload<S['include'][P]> | null :
        P extends 'ORDER'
        ? ORDERGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CALL ?CALL [P]
  : 
          P extends 'RESTAURANT'
        ? RESTAURANTGetPayload<S['select'][P]> :
        P extends 'LOCATION'
        ? LOCATIONGetPayload<S['select'][P]> :
        P extends 'USER'
        ? USERGetPayload<S['select'][P]> :
        P extends 'CART'
        ? CARTGetPayload<S['select'][P]> | null :
        P extends 'ORDER'
        ? ORDERGetPayload<S['select'][P]> | null : never
  } 
    : CALL
  : CALL


  type CALLCountArgs = Merge<
    Omit<CALLFindManyArgs, 'select' | 'include'> & {
      select?: CALLCountAggregateInputType | true
    }
  >

  export interface CALLDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CALL that matches the filter.
     * @param {CALLFindUniqueArgs} args - Arguments to find a CALL
     * @example
     * // Get one CALL
     * const cALL = await prisma.cALL.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CALLFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CALLFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CALL'> extends True ? CheckSelect<T, Prisma__CALLClient<CALL>, Prisma__CALLClient<CALLGetPayload<T>>> : CheckSelect<T, Prisma__CALLClient<CALL | null >, Prisma__CALLClient<CALLGetPayload<T> | null >>

    /**
     * Find the first CALL that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CALLFindFirstArgs} args - Arguments to find a CALL
     * @example
     * // Get one CALL
     * const cALL = await prisma.cALL.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CALLFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CALLFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CALL'> extends True ? CheckSelect<T, Prisma__CALLClient<CALL>, Prisma__CALLClient<CALLGetPayload<T>>> : CheckSelect<T, Prisma__CALLClient<CALL | null >, Prisma__CALLClient<CALLGetPayload<T> | null >>

    /**
     * Find zero or more CALLS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CALLFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CALLS
     * const cALLS = await prisma.cALL.findMany()
     * 
     * // Get first 10 CALLS
     * const cALLS = await prisma.cALL.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const cALLWithSeqOnly = await prisma.cALL.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends CALLFindManyArgs>(
      args?: SelectSubset<T, CALLFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CALL>>, PrismaPromise<Array<CALLGetPayload<T>>>>

    /**
     * Create a CALL.
     * @param {CALLCreateArgs} args - Arguments to create a CALL.
     * @example
     * // Create one CALL
     * const CALL = await prisma.cALL.create({
     *   data: {
     *     // ... data to create a CALL
     *   }
     * })
     * 
    **/
    create<T extends CALLCreateArgs>(
      args: SelectSubset<T, CALLCreateArgs>
    ): CheckSelect<T, Prisma__CALLClient<CALL>, Prisma__CALLClient<CALLGetPayload<T>>>

    /**
     * Create many CALLS.
     *     @param {CALLCreateManyArgs} args - Arguments to create many CALLS.
     *     @example
     *     // Create many CALLS
     *     const cALL = await prisma.cALL.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CALLCreateManyArgs>(
      args?: SelectSubset<T, CALLCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CALL.
     * @param {CALLDeleteArgs} args - Arguments to delete one CALL.
     * @example
     * // Delete one CALL
     * const CALL = await prisma.cALL.delete({
     *   where: {
     *     // ... filter to delete one CALL
     *   }
     * })
     * 
    **/
    delete<T extends CALLDeleteArgs>(
      args: SelectSubset<T, CALLDeleteArgs>
    ): CheckSelect<T, Prisma__CALLClient<CALL>, Prisma__CALLClient<CALLGetPayload<T>>>

    /**
     * Update one CALL.
     * @param {CALLUpdateArgs} args - Arguments to update one CALL.
     * @example
     * // Update one CALL
     * const cALL = await prisma.cALL.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CALLUpdateArgs>(
      args: SelectSubset<T, CALLUpdateArgs>
    ): CheckSelect<T, Prisma__CALLClient<CALL>, Prisma__CALLClient<CALLGetPayload<T>>>

    /**
     * Delete zero or more CALLS.
     * @param {CALLDeleteManyArgs} args - Arguments to filter CALLS to delete.
     * @example
     * // Delete a few CALLS
     * const { count } = await prisma.cALL.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CALLDeleteManyArgs>(
      args?: SelectSubset<T, CALLDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CALLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CALLUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CALLS
     * const cALL = await prisma.cALL.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CALLUpdateManyArgs>(
      args: SelectSubset<T, CALLUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CALL.
     * @param {CALLUpsertArgs} args - Arguments to update or create a CALL.
     * @example
     * // Update or create a CALL
     * const cALL = await prisma.cALL.upsert({
     *   create: {
     *     // ... data to create a CALL
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CALL we want to update
     *   }
     * })
    **/
    upsert<T extends CALLUpsertArgs>(
      args: SelectSubset<T, CALLUpsertArgs>
    ): CheckSelect<T, Prisma__CALLClient<CALL>, Prisma__CALLClient<CALLGetPayload<T>>>

    /**
     * Count the number of CALLS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CALLCountArgs} args - Arguments to filter CALLS to count.
     * @example
     * // Count the number of CALLS
     * const count = await prisma.cALL.count({
     *   where: {
     *     // ... the filter for the CALLS we want to count
     *   }
     * })
    **/
    count<T extends CALLCountArgs>(
      args?: Subset<T, CALLCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CALLCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CALL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CALLAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CALLAggregateArgs>(args: Subset<T, CALLAggregateArgs>): PrismaPromise<GetCALLAggregateType<T>>

    /**
     * Group by CALL.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CALLGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CALLGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CALLGroupByArgs['orderBy'] }
        : { orderBy?: CALLGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CALLGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCALLGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CALL.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CALLClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RESTAURANT<T extends RESTAURANTArgs = {}>(args?: Subset<T, RESTAURANTArgs>): CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT | null >, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T> | null >>;

    LOCATION<T extends LOCATIONArgs = {}>(args?: Subset<T, LOCATIONArgs>): CheckSelect<T, Prisma__LOCATIONClient<LOCATION | null >, Prisma__LOCATIONClient<LOCATIONGetPayload<T> | null >>;

    USER<T extends USERArgs = {}>(args?: Subset<T, USERArgs>): CheckSelect<T, Prisma__USERClient<USER | null >, Prisma__USERClient<USERGetPayload<T> | null >>;

    CART<T extends CARTArgs = {}>(args?: Subset<T, CARTArgs>): CheckSelect<T, Prisma__CARTClient<CART | null >, Prisma__CARTClient<CARTGetPayload<T> | null >>;

    ORDER<T extends ORDERArgs = {}>(args?: Subset<T, ORDERArgs>): CheckSelect<T, Prisma__ORDERClient<ORDER | null >, Prisma__ORDERClient<ORDERGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CALL findUnique
   */
  export type CALLFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CALL
    **/
    select?: CALLSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CALLInclude | null
    /**
     * Throw an Error if a CALL can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CALL to fetch.
    **/
    where: CALLWhereUniqueInput
  }


  /**
   * CALL findFirst
   */
  export type CALLFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CALL
    **/
    select?: CALLSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CALLInclude | null
    /**
     * Throw an Error if a CALL can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CALL to fetch.
    **/
    where?: CALLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CALLS to fetch.
    **/
    orderBy?: Enumerable<CALLOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CALLS.
    **/
    cursor?: CALLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CALLS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CALLS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CALLS.
    **/
    distinct?: Enumerable<CALLScalarFieldEnum>
  }


  /**
   * CALL findMany
   */
  export type CALLFindManyArgs = {
    /**
     * Select specific fields to fetch from the CALL
    **/
    select?: CALLSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CALLInclude | null
    /**
     * Filter, which CALLS to fetch.
    **/
    where?: CALLWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CALLS to fetch.
    **/
    orderBy?: Enumerable<CALLOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CALLS.
    **/
    cursor?: CALLWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CALLS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CALLS.
    **/
    skip?: number
    distinct?: Enumerable<CALLScalarFieldEnum>
  }


  /**
   * CALL create
   */
  export type CALLCreateArgs = {
    /**
     * Select specific fields to fetch from the CALL
    **/
    select?: CALLSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CALLInclude | null
    /**
     * The data needed to create a CALL.
    **/
    data: XOR<CALLCreateInput, CALLUncheckedCreateInput>
  }


  /**
   * CALL createMany
   */
  export type CALLCreateManyArgs = {
    data: Enumerable<CALLCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CALL update
   */
  export type CALLUpdateArgs = {
    /**
     * Select specific fields to fetch from the CALL
    **/
    select?: CALLSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CALLInclude | null
    /**
     * The data needed to update a CALL.
    **/
    data: XOR<CALLUpdateInput, CALLUncheckedUpdateInput>
    /**
     * Choose, which CALL to update.
    **/
    where: CALLWhereUniqueInput
  }


  /**
   * CALL updateMany
   */
  export type CALLUpdateManyArgs = {
    data: XOR<CALLUpdateManyMutationInput, CALLUncheckedUpdateManyInput>
    where?: CALLWhereInput
  }


  /**
   * CALL upsert
   */
  export type CALLUpsertArgs = {
    /**
     * Select specific fields to fetch from the CALL
    **/
    select?: CALLSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CALLInclude | null
    /**
     * The filter to search for the CALL to update in case it exists.
    **/
    where: CALLWhereUniqueInput
    /**
     * In case the CALL found by the `where` argument doesn't exist, create a new CALL with this data.
    **/
    create: XOR<CALLCreateInput, CALLUncheckedCreateInput>
    /**
     * In case the CALL was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CALLUpdateInput, CALLUncheckedUpdateInput>
  }


  /**
   * CALL delete
   */
  export type CALLDeleteArgs = {
    /**
     * Select specific fields to fetch from the CALL
    **/
    select?: CALLSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CALLInclude | null
    /**
     * Filter which CALL to delete.
    **/
    where: CALLWhereUniqueInput
  }


  /**
   * CALL deleteMany
   */
  export type CALLDeleteManyArgs = {
    where?: CALLWhereInput
  }


  /**
   * CALL without action
   */
  export type CALLArgs = {
    /**
     * Select specific fields to fetch from the CALL
    **/
    select?: CALLSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CALLInclude | null
  }



  /**
   * Model CART
   */


  export type AggregateCART = {
    count: CARTCountAggregateOutputType | null
    avg: CARTAvgAggregateOutputType | null
    sum: CARTSumAggregateOutputType | null
    min: CARTMinAggregateOutputType | null
    max: CARTMaxAggregateOutputType | null
  }

  export type CARTAvgAggregateOutputType = {
    seq: number
  }

  export type CARTSumAggregateOutputType = {
    seq: number
  }

  export type CARTMinAggregateOutputType = {
    seq: number
    request: string | null
  }

  export type CARTMaxAggregateOutputType = {
    seq: number
    request: string | null
  }

  export type CARTCountAggregateOutputType = {
    seq: number
    request: number | null
    _all: number
  }


  export type CARTAvgAggregateInputType = {
    seq?: true
  }

  export type CARTSumAggregateInputType = {
    seq?: true
  }

  export type CARTMinAggregateInputType = {
    seq?: true
    request?: true
  }

  export type CARTMaxAggregateInputType = {
    seq?: true
    request?: true
  }

  export type CARTCountAggregateInputType = {
    seq?: true
    request?: true
    _all?: true
  }

  export type CARTAggregateArgs = {
    /**
     * Filter which CART to aggregate.
    **/
    where?: CARTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CARTS to fetch.
    **/
    orderBy?: Enumerable<CARTOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CARTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CARTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CARTS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CARTS
    **/
    count?: true | CARTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CARTAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CARTSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CARTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CARTMaxAggregateInputType
  }

  export type GetCARTAggregateType<T extends CARTAggregateArgs> = {
    [P in keyof T & keyof AggregateCART]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCART[P]>
      : GetScalarType<T[P], AggregateCART[P]>
  }


    
    
  export type CARTGroupByArgs = {
    where?: CARTWhereInput
    orderBy?: Enumerable<CARTOrderByInput>
    by: Array<CARTScalarFieldEnum>
    having?: CARTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CARTCountAggregateInputType | true
    avg?: CARTAvgAggregateInputType
    sum?: CARTSumAggregateInputType
    min?: CARTMinAggregateInputType
    max?: CARTMaxAggregateInputType
  }


  export type CARTGroupByOutputType = {
    seq: number
    request: string | null
    count: CARTCountAggregateOutputType | null
    avg: CARTAvgAggregateOutputType | null
    sum: CARTSumAggregateOutputType | null
    min: CARTMinAggregateOutputType | null
    max: CARTMaxAggregateOutputType | null
  }

  type GetCARTGroupByPayload<T extends CARTGroupByArgs> = Promise<Array<
    PickArray<CARTGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CARTGroupByOutputType))]: GetScalarType<T[P], CARTGroupByOutputType[P]>
    }
  >>
    

  export type CARTSelect = {
    seq?: boolean
    request?: boolean
    CALL?: boolean | CALLArgs
    SELECTED_MENU?: boolean | SELECTED_MENUArgs
    USER?: boolean | USERArgs
  }

  export type CARTInclude = {
    CALL?: boolean | CALLArgs
    SELECTED_MENU?: boolean | SELECTED_MENUArgs
    USER?: boolean | USERArgs
  }

  export type CARTGetPayload<
    S extends boolean | null | undefined | CARTArgs,
    U = keyof S
      > = S extends true
        ? CART
    : S extends undefined
    ? never
    : S extends CARTArgs | CARTFindManyArgs
    ?'include' extends U
    ? CART  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CALL'
        ? CALLGetPayload<S['include'][P]> :
        P extends 'SELECTED_MENU'
        ? SELECTED_MENUGetPayload<S['include'][P]> :
        P extends 'USER'
        ? USERGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CART ?CART [P]
  : 
          P extends 'CALL'
        ? CALLGetPayload<S['select'][P]> :
        P extends 'SELECTED_MENU'
        ? SELECTED_MENUGetPayload<S['select'][P]> :
        P extends 'USER'
        ? USERGetPayload<S['select'][P]> : never
  } 
    : CART
  : CART


  type CARTCountArgs = Merge<
    Omit<CARTFindManyArgs, 'select' | 'include'> & {
      select?: CARTCountAggregateInputType | true
    }
  >

  export interface CARTDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CART that matches the filter.
     * @param {CARTFindUniqueArgs} args - Arguments to find a CART
     * @example
     * // Get one CART
     * const cART = await prisma.cART.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CARTFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CARTFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CART'> extends True ? CheckSelect<T, Prisma__CARTClient<CART>, Prisma__CARTClient<CARTGetPayload<T>>> : CheckSelect<T, Prisma__CARTClient<CART | null >, Prisma__CARTClient<CARTGetPayload<T> | null >>

    /**
     * Find the first CART that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTFindFirstArgs} args - Arguments to find a CART
     * @example
     * // Get one CART
     * const cART = await prisma.cART.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CARTFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CARTFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CART'> extends True ? CheckSelect<T, Prisma__CARTClient<CART>, Prisma__CARTClient<CARTGetPayload<T>>> : CheckSelect<T, Prisma__CARTClient<CART | null >, Prisma__CARTClient<CARTGetPayload<T> | null >>

    /**
     * Find zero or more CARTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CARTS
     * const cARTS = await prisma.cART.findMany()
     * 
     * // Get first 10 CARTS
     * const cARTS = await prisma.cART.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const cARTWithSeqOnly = await prisma.cART.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends CARTFindManyArgs>(
      args?: SelectSubset<T, CARTFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CART>>, PrismaPromise<Array<CARTGetPayload<T>>>>

    /**
     * Create a CART.
     * @param {CARTCreateArgs} args - Arguments to create a CART.
     * @example
     * // Create one CART
     * const CART = await prisma.cART.create({
     *   data: {
     *     // ... data to create a CART
     *   }
     * })
     * 
    **/
    create<T extends CARTCreateArgs>(
      args: SelectSubset<T, CARTCreateArgs>
    ): CheckSelect<T, Prisma__CARTClient<CART>, Prisma__CARTClient<CARTGetPayload<T>>>

    /**
     * Create many CARTS.
     *     @param {CARTCreateManyArgs} args - Arguments to create many CARTS.
     *     @example
     *     // Create many CARTS
     *     const cART = await prisma.cART.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CARTCreateManyArgs>(
      args?: SelectSubset<T, CARTCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CART.
     * @param {CARTDeleteArgs} args - Arguments to delete one CART.
     * @example
     * // Delete one CART
     * const CART = await prisma.cART.delete({
     *   where: {
     *     // ... filter to delete one CART
     *   }
     * })
     * 
    **/
    delete<T extends CARTDeleteArgs>(
      args: SelectSubset<T, CARTDeleteArgs>
    ): CheckSelect<T, Prisma__CARTClient<CART>, Prisma__CARTClient<CARTGetPayload<T>>>

    /**
     * Update one CART.
     * @param {CARTUpdateArgs} args - Arguments to update one CART.
     * @example
     * // Update one CART
     * const cART = await prisma.cART.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CARTUpdateArgs>(
      args: SelectSubset<T, CARTUpdateArgs>
    ): CheckSelect<T, Prisma__CARTClient<CART>, Prisma__CARTClient<CARTGetPayload<T>>>

    /**
     * Delete zero or more CARTS.
     * @param {CARTDeleteManyArgs} args - Arguments to filter CARTS to delete.
     * @example
     * // Delete a few CARTS
     * const { count } = await prisma.cART.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CARTDeleteManyArgs>(
      args?: SelectSubset<T, CARTDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CARTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CARTS
     * const cART = await prisma.cART.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CARTUpdateManyArgs>(
      args: SelectSubset<T, CARTUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CART.
     * @param {CARTUpsertArgs} args - Arguments to update or create a CART.
     * @example
     * // Update or create a CART
     * const cART = await prisma.cART.upsert({
     *   create: {
     *     // ... data to create a CART
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CART we want to update
     *   }
     * })
    **/
    upsert<T extends CARTUpsertArgs>(
      args: SelectSubset<T, CARTUpsertArgs>
    ): CheckSelect<T, Prisma__CARTClient<CART>, Prisma__CARTClient<CARTGetPayload<T>>>

    /**
     * Count the number of CARTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTCountArgs} args - Arguments to filter CARTS to count.
     * @example
     * // Count the number of CARTS
     * const count = await prisma.cART.count({
     *   where: {
     *     // ... the filter for the CARTS we want to count
     *   }
     * })
    **/
    count<T extends CARTCountArgs>(
      args?: Subset<T, CARTCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CARTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CART.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CARTAggregateArgs>(args: Subset<T, CARTAggregateArgs>): PrismaPromise<GetCARTAggregateType<T>>

    /**
     * Group by CART.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CARTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CARTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CARTGroupByArgs['orderBy'] }
        : { orderBy?: CARTGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CARTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCARTGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CART.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CARTClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CALL<T extends CALLArgs = {}>(args?: Subset<T, CALLArgs>): CheckSelect<T, Prisma__CALLClient<CALL | null >, Prisma__CALLClient<CALLGetPayload<T> | null >>;

    SELECTED_MENU<T extends SELECTED_MENUArgs = {}>(args?: Subset<T, SELECTED_MENUArgs>): CheckSelect<T, Prisma__SELECTED_MENUClient<SELECTED_MENU | null >, Prisma__SELECTED_MENUClient<SELECTED_MENUGetPayload<T> | null >>;

    USER<T extends USERArgs = {}>(args?: Subset<T, USERArgs>): CheckSelect<T, Prisma__USERClient<USER | null >, Prisma__USERClient<USERGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CART findUnique
   */
  export type CARTFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CART
    **/
    select?: CARTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CARTInclude | null
    /**
     * Throw an Error if a CART can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CART to fetch.
    **/
    where: CARTWhereUniqueInput
  }


  /**
   * CART findFirst
   */
  export type CARTFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CART
    **/
    select?: CARTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CARTInclude | null
    /**
     * Throw an Error if a CART can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CART to fetch.
    **/
    where?: CARTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CARTS to fetch.
    **/
    orderBy?: Enumerable<CARTOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CARTS.
    **/
    cursor?: CARTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CARTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CARTS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CARTS.
    **/
    distinct?: Enumerable<CARTScalarFieldEnum>
  }


  /**
   * CART findMany
   */
  export type CARTFindManyArgs = {
    /**
     * Select specific fields to fetch from the CART
    **/
    select?: CARTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CARTInclude | null
    /**
     * Filter, which CARTS to fetch.
    **/
    where?: CARTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CARTS to fetch.
    **/
    orderBy?: Enumerable<CARTOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CARTS.
    **/
    cursor?: CARTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CARTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CARTS.
    **/
    skip?: number
    distinct?: Enumerable<CARTScalarFieldEnum>
  }


  /**
   * CART create
   */
  export type CARTCreateArgs = {
    /**
     * Select specific fields to fetch from the CART
    **/
    select?: CARTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CARTInclude | null
    /**
     * The data needed to create a CART.
    **/
    data: XOR<CARTCreateInput, CARTUncheckedCreateInput>
  }


  /**
   * CART createMany
   */
  export type CARTCreateManyArgs = {
    data: Enumerable<CARTCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CART update
   */
  export type CARTUpdateArgs = {
    /**
     * Select specific fields to fetch from the CART
    **/
    select?: CARTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CARTInclude | null
    /**
     * The data needed to update a CART.
    **/
    data: XOR<CARTUpdateInput, CARTUncheckedUpdateInput>
    /**
     * Choose, which CART to update.
    **/
    where: CARTWhereUniqueInput
  }


  /**
   * CART updateMany
   */
  export type CARTUpdateManyArgs = {
    data: XOR<CARTUpdateManyMutationInput, CARTUncheckedUpdateManyInput>
    where?: CARTWhereInput
  }


  /**
   * CART upsert
   */
  export type CARTUpsertArgs = {
    /**
     * Select specific fields to fetch from the CART
    **/
    select?: CARTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CARTInclude | null
    /**
     * The filter to search for the CART to update in case it exists.
    **/
    where: CARTWhereUniqueInput
    /**
     * In case the CART found by the `where` argument doesn't exist, create a new CART with this data.
    **/
    create: XOR<CARTCreateInput, CARTUncheckedCreateInput>
    /**
     * In case the CART was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CARTUpdateInput, CARTUncheckedUpdateInput>
  }


  /**
   * CART delete
   */
  export type CARTDeleteArgs = {
    /**
     * Select specific fields to fetch from the CART
    **/
    select?: CARTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CARTInclude | null
    /**
     * Filter which CART to delete.
    **/
    where: CARTWhereUniqueInput
  }


  /**
   * CART deleteMany
   */
  export type CARTDeleteManyArgs = {
    where?: CARTWhereInput
  }


  /**
   * CART without action
   */
  export type CARTArgs = {
    /**
     * Select specific fields to fetch from the CART
    **/
    select?: CARTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CARTInclude | null
  }



  /**
   * Model CHAT
   */


  export type AggregateCHAT = {
    count: CHATCountAggregateOutputType | null
    avg: CHATAvgAggregateOutputType | null
    sum: CHATSumAggregateOutputType | null
    min: CHATMinAggregateOutputType | null
    max: CHATMaxAggregateOutputType | null
  }

  export type CHATAvgAggregateOutputType = {
    seq: number
  }

  export type CHATSumAggregateOutputType = {
    seq: number
  }

  export type CHATMinAggregateOutputType = {
    seq: number
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CHATMaxAggregateOutputType = {
    seq: number
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CHATCountAggregateOutputType = {
    seq: number
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type CHATAvgAggregateInputType = {
    seq?: true
  }

  export type CHATSumAggregateInputType = {
    seq?: true
  }

  export type CHATMinAggregateInputType = {
    seq?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CHATMaxAggregateInputType = {
    seq?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CHATCountAggregateInputType = {
    seq?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CHATAggregateArgs = {
    /**
     * Filter which CHAT to aggregate.
    **/
    where?: CHATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CHATS to fetch.
    **/
    orderBy?: Enumerable<CHATOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CHATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CHATS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CHATS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CHATS
    **/
    count?: true | CHATCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CHATAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CHATSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CHATMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CHATMaxAggregateInputType
  }

  export type GetCHATAggregateType<T extends CHATAggregateArgs> = {
    [P in keyof T & keyof AggregateCHAT]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCHAT[P]>
      : GetScalarType<T[P], AggregateCHAT[P]>
  }


    
    
  export type CHATGroupByArgs = {
    where?: CHATWhereInput
    orderBy?: Enumerable<CHATOrderByInput>
    by: Array<CHATScalarFieldEnum>
    having?: CHATScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: CHATCountAggregateInputType | true
    avg?: CHATAvgAggregateInputType
    sum?: CHATSumAggregateInputType
    min?: CHATMinAggregateInputType
    max?: CHATMaxAggregateInputType
  }


  export type CHATGroupByOutputType = {
    seq: number
    createdAt: Date
    updatedAt: Date | null
    count: CHATCountAggregateOutputType | null
    avg: CHATAvgAggregateOutputType | null
    sum: CHATSumAggregateOutputType | null
    min: CHATMinAggregateOutputType | null
    max: CHATMaxAggregateOutputType | null
  }

  type GetCHATGroupByPayload<T extends CHATGroupByArgs> = Promise<Array<
    PickArray<CHATGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof CHATGroupByOutputType))]: GetScalarType<T[P], CHATGroupByOutputType[P]>
    }
  >>
    

  export type CHATSelect = {
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    USER?: boolean | USERArgs
    MESSAGE_CHAT_seqToMESSAGE?: boolean | MESSAGEArgs
    MESSAGE_CHATToMESSAGE_seq?: boolean | MESSAGEArgs
  }

  export type CHATInclude = {
    USER?: boolean | USERArgs
    MESSAGE_CHAT_seqToMESSAGE?: boolean | MESSAGEArgs
    MESSAGE_CHATToMESSAGE_seq?: boolean | MESSAGEArgs
  }

  export type CHATGetPayload<
    S extends boolean | null | undefined | CHATArgs,
    U = keyof S
      > = S extends true
        ? CHAT
    : S extends undefined
    ? never
    : S extends CHATArgs | CHATFindManyArgs
    ?'include' extends U
    ? CHAT  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'USER'
        ? USERGetPayload<S['include'][P]> :
        P extends 'MESSAGE_CHAT_seqToMESSAGE'
        ? MESSAGEGetPayload<S['include'][P]> :
        P extends 'MESSAGE_CHATToMESSAGE_seq'
        ? MESSAGEGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CHAT ?CHAT [P]
  : 
          P extends 'USER'
        ? USERGetPayload<S['select'][P]> :
        P extends 'MESSAGE_CHAT_seqToMESSAGE'
        ? MESSAGEGetPayload<S['select'][P]> :
        P extends 'MESSAGE_CHATToMESSAGE_seq'
        ? MESSAGEGetPayload<S['select'][P]> | null : never
  } 
    : CHAT
  : CHAT


  type CHATCountArgs = Merge<
    Omit<CHATFindManyArgs, 'select' | 'include'> & {
      select?: CHATCountAggregateInputType | true
    }
  >

  export interface CHATDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CHAT that matches the filter.
     * @param {CHATFindUniqueArgs} args - Arguments to find a CHAT
     * @example
     * // Get one CHAT
     * const cHAT = await prisma.cHAT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CHATFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CHATFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CHAT'> extends True ? CheckSelect<T, Prisma__CHATClient<CHAT>, Prisma__CHATClient<CHATGetPayload<T>>> : CheckSelect<T, Prisma__CHATClient<CHAT | null >, Prisma__CHATClient<CHATGetPayload<T> | null >>

    /**
     * Find the first CHAT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CHATFindFirstArgs} args - Arguments to find a CHAT
     * @example
     * // Get one CHAT
     * const cHAT = await prisma.cHAT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CHATFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CHATFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CHAT'> extends True ? CheckSelect<T, Prisma__CHATClient<CHAT>, Prisma__CHATClient<CHATGetPayload<T>>> : CheckSelect<T, Prisma__CHATClient<CHAT | null >, Prisma__CHATClient<CHATGetPayload<T> | null >>

    /**
     * Find zero or more CHATS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CHATFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CHATS
     * const cHATS = await prisma.cHAT.findMany()
     * 
     * // Get first 10 CHATS
     * const cHATS = await prisma.cHAT.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const cHATWithSeqOnly = await prisma.cHAT.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends CHATFindManyArgs>(
      args?: SelectSubset<T, CHATFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CHAT>>, PrismaPromise<Array<CHATGetPayload<T>>>>

    /**
     * Create a CHAT.
     * @param {CHATCreateArgs} args - Arguments to create a CHAT.
     * @example
     * // Create one CHAT
     * const CHAT = await prisma.cHAT.create({
     *   data: {
     *     // ... data to create a CHAT
     *   }
     * })
     * 
    **/
    create<T extends CHATCreateArgs>(
      args: SelectSubset<T, CHATCreateArgs>
    ): CheckSelect<T, Prisma__CHATClient<CHAT>, Prisma__CHATClient<CHATGetPayload<T>>>

    /**
     * Create many CHATS.
     *     @param {CHATCreateManyArgs} args - Arguments to create many CHATS.
     *     @example
     *     // Create many CHATS
     *     const cHAT = await prisma.cHAT.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CHATCreateManyArgs>(
      args?: SelectSubset<T, CHATCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a CHAT.
     * @param {CHATDeleteArgs} args - Arguments to delete one CHAT.
     * @example
     * // Delete one CHAT
     * const CHAT = await prisma.cHAT.delete({
     *   where: {
     *     // ... filter to delete one CHAT
     *   }
     * })
     * 
    **/
    delete<T extends CHATDeleteArgs>(
      args: SelectSubset<T, CHATDeleteArgs>
    ): CheckSelect<T, Prisma__CHATClient<CHAT>, Prisma__CHATClient<CHATGetPayload<T>>>

    /**
     * Update one CHAT.
     * @param {CHATUpdateArgs} args - Arguments to update one CHAT.
     * @example
     * // Update one CHAT
     * const cHAT = await prisma.cHAT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CHATUpdateArgs>(
      args: SelectSubset<T, CHATUpdateArgs>
    ): CheckSelect<T, Prisma__CHATClient<CHAT>, Prisma__CHATClient<CHATGetPayload<T>>>

    /**
     * Delete zero or more CHATS.
     * @param {CHATDeleteManyArgs} args - Arguments to filter CHATS to delete.
     * @example
     * // Delete a few CHATS
     * const { count } = await prisma.cHAT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CHATDeleteManyArgs>(
      args?: SelectSubset<T, CHATDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CHATS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CHATUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CHATS
     * const cHAT = await prisma.cHAT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CHATUpdateManyArgs>(
      args: SelectSubset<T, CHATUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CHAT.
     * @param {CHATUpsertArgs} args - Arguments to update or create a CHAT.
     * @example
     * // Update or create a CHAT
     * const cHAT = await prisma.cHAT.upsert({
     *   create: {
     *     // ... data to create a CHAT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CHAT we want to update
     *   }
     * })
    **/
    upsert<T extends CHATUpsertArgs>(
      args: SelectSubset<T, CHATUpsertArgs>
    ): CheckSelect<T, Prisma__CHATClient<CHAT>, Prisma__CHATClient<CHATGetPayload<T>>>

    /**
     * Count the number of CHATS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CHATCountArgs} args - Arguments to filter CHATS to count.
     * @example
     * // Count the number of CHATS
     * const count = await prisma.cHAT.count({
     *   where: {
     *     // ... the filter for the CHATS we want to count
     *   }
     * })
    **/
    count<T extends CHATCountArgs>(
      args?: Subset<T, CHATCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CHATCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CHAT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CHATAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CHATAggregateArgs>(args: Subset<T, CHATAggregateArgs>): PrismaPromise<GetCHATAggregateType<T>>

    /**
     * Group by CHAT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CHATGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CHATGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CHATGroupByArgs['orderBy'] }
        : { orderBy?: CHATGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CHATGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCHATGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for CHAT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CHATClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    USER<T extends USERArgs = {}>(args?: Subset<T, USERArgs>): CheckSelect<T, Prisma__USERClient<USER | null >, Prisma__USERClient<USERGetPayload<T> | null >>;

    MESSAGE_CHAT_seqToMESSAGE<T extends MESSAGEArgs = {}>(args?: Subset<T, MESSAGEArgs>): CheckSelect<T, Prisma__MESSAGEClient<MESSAGE | null >, Prisma__MESSAGEClient<MESSAGEGetPayload<T> | null >>;

    MESSAGE_CHATToMESSAGE_seq<T extends MESSAGEArgs = {}>(args?: Subset<T, MESSAGEArgs>): CheckSelect<T, Prisma__MESSAGEClient<MESSAGE | null >, Prisma__MESSAGEClient<MESSAGEGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CHAT findUnique
   */
  export type CHATFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CHAT
    **/
    select?: CHATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CHATInclude | null
    /**
     * Throw an Error if a CHAT can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CHAT to fetch.
    **/
    where: CHATWhereUniqueInput
  }


  /**
   * CHAT findFirst
   */
  export type CHATFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CHAT
    **/
    select?: CHATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CHATInclude | null
    /**
     * Throw an Error if a CHAT can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CHAT to fetch.
    **/
    where?: CHATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CHATS to fetch.
    **/
    orderBy?: Enumerable<CHATOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CHATS.
    **/
    cursor?: CHATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CHATS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CHATS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CHATS.
    **/
    distinct?: Enumerable<CHATScalarFieldEnum>
  }


  /**
   * CHAT findMany
   */
  export type CHATFindManyArgs = {
    /**
     * Select specific fields to fetch from the CHAT
    **/
    select?: CHATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CHATInclude | null
    /**
     * Filter, which CHATS to fetch.
    **/
    where?: CHATWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CHATS to fetch.
    **/
    orderBy?: Enumerable<CHATOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CHATS.
    **/
    cursor?: CHATWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CHATS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CHATS.
    **/
    skip?: number
    distinct?: Enumerable<CHATScalarFieldEnum>
  }


  /**
   * CHAT create
   */
  export type CHATCreateArgs = {
    /**
     * Select specific fields to fetch from the CHAT
    **/
    select?: CHATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CHATInclude | null
    /**
     * The data needed to create a CHAT.
    **/
    data: XOR<CHATCreateInput, CHATUncheckedCreateInput>
  }


  /**
   * CHAT createMany
   */
  export type CHATCreateManyArgs = {
    data: Enumerable<CHATCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * CHAT update
   */
  export type CHATUpdateArgs = {
    /**
     * Select specific fields to fetch from the CHAT
    **/
    select?: CHATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CHATInclude | null
    /**
     * The data needed to update a CHAT.
    **/
    data: XOR<CHATUpdateInput, CHATUncheckedUpdateInput>
    /**
     * Choose, which CHAT to update.
    **/
    where: CHATWhereUniqueInput
  }


  /**
   * CHAT updateMany
   */
  export type CHATUpdateManyArgs = {
    data: XOR<CHATUpdateManyMutationInput, CHATUncheckedUpdateManyInput>
    where?: CHATWhereInput
  }


  /**
   * CHAT upsert
   */
  export type CHATUpsertArgs = {
    /**
     * Select specific fields to fetch from the CHAT
    **/
    select?: CHATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CHATInclude | null
    /**
     * The filter to search for the CHAT to update in case it exists.
    **/
    where: CHATWhereUniqueInput
    /**
     * In case the CHAT found by the `where` argument doesn't exist, create a new CHAT with this data.
    **/
    create: XOR<CHATCreateInput, CHATUncheckedCreateInput>
    /**
     * In case the CHAT was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CHATUpdateInput, CHATUncheckedUpdateInput>
  }


  /**
   * CHAT delete
   */
  export type CHATDeleteArgs = {
    /**
     * Select specific fields to fetch from the CHAT
    **/
    select?: CHATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CHATInclude | null
    /**
     * Filter which CHAT to delete.
    **/
    where: CHATWhereUniqueInput
  }


  /**
   * CHAT deleteMany
   */
  export type CHATDeleteManyArgs = {
    where?: CHATWhereInput
  }


  /**
   * CHAT without action
   */
  export type CHATArgs = {
    /**
     * Select specific fields to fetch from the CHAT
    **/
    select?: CHATSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CHATInclude | null
  }



  /**
   * Model LOCATION
   */


  export type AggregateLOCATION = {
    count: LOCATIONCountAggregateOutputType | null
    avg: LOCATIONAvgAggregateOutputType | null
    sum: LOCATIONSumAggregateOutputType | null
    min: LOCATIONMinAggregateOutputType | null
    max: LOCATIONMaxAggregateOutputType | null
  }

  export type LOCATIONAvgAggregateOutputType = {
    seq: number
    latitude: number
    longitude: number
  }

  export type LOCATIONSumAggregateOutputType = {
    seq: number
    latitude: number
    longitude: number
  }

  export type LOCATIONMinAggregateOutputType = {
    seq: number
    latitude: number
    longitude: number
    address: string | null
  }

  export type LOCATIONMaxAggregateOutputType = {
    seq: number
    latitude: number
    longitude: number
    address: string | null
  }

  export type LOCATIONCountAggregateOutputType = {
    seq: number
    latitude: number
    longitude: number
    address: number | null
    _all: number
  }


  export type LOCATIONAvgAggregateInputType = {
    seq?: true
    latitude?: true
    longitude?: true
  }

  export type LOCATIONSumAggregateInputType = {
    seq?: true
    latitude?: true
    longitude?: true
  }

  export type LOCATIONMinAggregateInputType = {
    seq?: true
    latitude?: true
    longitude?: true
    address?: true
  }

  export type LOCATIONMaxAggregateInputType = {
    seq?: true
    latitude?: true
    longitude?: true
    address?: true
  }

  export type LOCATIONCountAggregateInputType = {
    seq?: true
    latitude?: true
    longitude?: true
    address?: true
    _all?: true
  }

  export type LOCATIONAggregateArgs = {
    /**
     * Filter which LOCATION to aggregate.
    **/
    where?: LOCATIONWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LOCATIONS to fetch.
    **/
    orderBy?: Enumerable<LOCATIONOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: LOCATIONWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LOCATIONS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LOCATIONS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LOCATIONS
    **/
    count?: true | LOCATIONCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: LOCATIONAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: LOCATIONSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: LOCATIONMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: LOCATIONMaxAggregateInputType
  }

  export type GetLOCATIONAggregateType<T extends LOCATIONAggregateArgs> = {
    [P in keyof T & keyof AggregateLOCATION]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLOCATION[P]>
      : GetScalarType<T[P], AggregateLOCATION[P]>
  }


    
    
  export type LOCATIONGroupByArgs = {
    where?: LOCATIONWhereInput
    orderBy?: Enumerable<LOCATIONOrderByInput>
    by: Array<LOCATIONScalarFieldEnum>
    having?: LOCATIONScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: LOCATIONCountAggregateInputType | true
    avg?: LOCATIONAvgAggregateInputType
    sum?: LOCATIONSumAggregateInputType
    min?: LOCATIONMinAggregateInputType
    max?: LOCATIONMaxAggregateInputType
  }


  export type LOCATIONGroupByOutputType = {
    seq: number
    latitude: number
    longitude: number
    address: string
    count: LOCATIONCountAggregateOutputType | null
    avg: LOCATIONAvgAggregateOutputType | null
    sum: LOCATIONSumAggregateOutputType | null
    min: LOCATIONMinAggregateOutputType | null
    max: LOCATIONMaxAggregateOutputType | null
  }

  type GetLOCATIONGroupByPayload<T extends LOCATIONGroupByArgs> = Promise<Array<
    PickArray<LOCATIONGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof LOCATIONGroupByOutputType))]: GetScalarType<T[P], LOCATIONGroupByOutputType[P]>
    }
  >>
    

  export type LOCATIONSelect = {
    seq?: boolean
    latitude?: boolean
    longitude?: boolean
    address?: boolean
    CALL?: boolean | CALLArgs
    RESTAURANT?: boolean | RESTAURANTArgs
  }

  export type LOCATIONInclude = {
    CALL?: boolean | CALLArgs
    RESTAURANT?: boolean | RESTAURANTArgs
  }

  export type LOCATIONGetPayload<
    S extends boolean | null | undefined | LOCATIONArgs,
    U = keyof S
      > = S extends true
        ? LOCATION
    : S extends undefined
    ? never
    : S extends LOCATIONArgs | LOCATIONFindManyArgs
    ?'include' extends U
    ? LOCATION  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CALL'
        ? CALLGetPayload<S['include'][P]> | null :
        P extends 'RESTAURANT'
        ? RESTAURANTGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LOCATION ?LOCATION [P]
  : 
          P extends 'CALL'
        ? CALLGetPayload<S['select'][P]> | null :
        P extends 'RESTAURANT'
        ? RESTAURANTGetPayload<S['select'][P]> | null : never
  } 
    : LOCATION
  : LOCATION


  type LOCATIONCountArgs = Merge<
    Omit<LOCATIONFindManyArgs, 'select' | 'include'> & {
      select?: LOCATIONCountAggregateInputType | true
    }
  >

  export interface LOCATIONDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one LOCATION that matches the filter.
     * @param {LOCATIONFindUniqueArgs} args - Arguments to find a LOCATION
     * @example
     * // Get one LOCATION
     * const lOCATION = await prisma.lOCATION.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LOCATIONFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LOCATIONFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LOCATION'> extends True ? CheckSelect<T, Prisma__LOCATIONClient<LOCATION>, Prisma__LOCATIONClient<LOCATIONGetPayload<T>>> : CheckSelect<T, Prisma__LOCATIONClient<LOCATION | null >, Prisma__LOCATIONClient<LOCATIONGetPayload<T> | null >>

    /**
     * Find the first LOCATION that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LOCATIONFindFirstArgs} args - Arguments to find a LOCATION
     * @example
     * // Get one LOCATION
     * const lOCATION = await prisma.lOCATION.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LOCATIONFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LOCATIONFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LOCATION'> extends True ? CheckSelect<T, Prisma__LOCATIONClient<LOCATION>, Prisma__LOCATIONClient<LOCATIONGetPayload<T>>> : CheckSelect<T, Prisma__LOCATIONClient<LOCATION | null >, Prisma__LOCATIONClient<LOCATIONGetPayload<T> | null >>

    /**
     * Find zero or more LOCATIONS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LOCATIONFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LOCATIONS
     * const lOCATIONS = await prisma.lOCATION.findMany()
     * 
     * // Get first 10 LOCATIONS
     * const lOCATIONS = await prisma.lOCATION.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const lOCATIONWithSeqOnly = await prisma.lOCATION.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends LOCATIONFindManyArgs>(
      args?: SelectSubset<T, LOCATIONFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LOCATION>>, PrismaPromise<Array<LOCATIONGetPayload<T>>>>

    /**
     * Create a LOCATION.
     * @param {LOCATIONCreateArgs} args - Arguments to create a LOCATION.
     * @example
     * // Create one LOCATION
     * const LOCATION = await prisma.lOCATION.create({
     *   data: {
     *     // ... data to create a LOCATION
     *   }
     * })
     * 
    **/
    create<T extends LOCATIONCreateArgs>(
      args: SelectSubset<T, LOCATIONCreateArgs>
    ): CheckSelect<T, Prisma__LOCATIONClient<LOCATION>, Prisma__LOCATIONClient<LOCATIONGetPayload<T>>>

    /**
     * Create many LOCATIONS.
     *     @param {LOCATIONCreateManyArgs} args - Arguments to create many LOCATIONS.
     *     @example
     *     // Create many LOCATIONS
     *     const lOCATION = await prisma.lOCATION.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LOCATIONCreateManyArgs>(
      args?: SelectSubset<T, LOCATIONCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a LOCATION.
     * @param {LOCATIONDeleteArgs} args - Arguments to delete one LOCATION.
     * @example
     * // Delete one LOCATION
     * const LOCATION = await prisma.lOCATION.delete({
     *   where: {
     *     // ... filter to delete one LOCATION
     *   }
     * })
     * 
    **/
    delete<T extends LOCATIONDeleteArgs>(
      args: SelectSubset<T, LOCATIONDeleteArgs>
    ): CheckSelect<T, Prisma__LOCATIONClient<LOCATION>, Prisma__LOCATIONClient<LOCATIONGetPayload<T>>>

    /**
     * Update one LOCATION.
     * @param {LOCATIONUpdateArgs} args - Arguments to update one LOCATION.
     * @example
     * // Update one LOCATION
     * const lOCATION = await prisma.lOCATION.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LOCATIONUpdateArgs>(
      args: SelectSubset<T, LOCATIONUpdateArgs>
    ): CheckSelect<T, Prisma__LOCATIONClient<LOCATION>, Prisma__LOCATIONClient<LOCATIONGetPayload<T>>>

    /**
     * Delete zero or more LOCATIONS.
     * @param {LOCATIONDeleteManyArgs} args - Arguments to filter LOCATIONS to delete.
     * @example
     * // Delete a few LOCATIONS
     * const { count } = await prisma.lOCATION.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LOCATIONDeleteManyArgs>(
      args?: SelectSubset<T, LOCATIONDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LOCATIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LOCATIONUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LOCATIONS
     * const lOCATION = await prisma.lOCATION.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LOCATIONUpdateManyArgs>(
      args: SelectSubset<T, LOCATIONUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LOCATION.
     * @param {LOCATIONUpsertArgs} args - Arguments to update or create a LOCATION.
     * @example
     * // Update or create a LOCATION
     * const lOCATION = await prisma.lOCATION.upsert({
     *   create: {
     *     // ... data to create a LOCATION
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LOCATION we want to update
     *   }
     * })
    **/
    upsert<T extends LOCATIONUpsertArgs>(
      args: SelectSubset<T, LOCATIONUpsertArgs>
    ): CheckSelect<T, Prisma__LOCATIONClient<LOCATION>, Prisma__LOCATIONClient<LOCATIONGetPayload<T>>>

    /**
     * Count the number of LOCATIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LOCATIONCountArgs} args - Arguments to filter LOCATIONS to count.
     * @example
     * // Count the number of LOCATIONS
     * const count = await prisma.lOCATION.count({
     *   where: {
     *     // ... the filter for the LOCATIONS we want to count
     *   }
     * })
    **/
    count<T extends LOCATIONCountArgs>(
      args?: Subset<T, LOCATIONCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LOCATIONCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LOCATION.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LOCATIONAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LOCATIONAggregateArgs>(args: Subset<T, LOCATIONAggregateArgs>): PrismaPromise<GetLOCATIONAggregateType<T>>

    /**
     * Group by LOCATION.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LOCATIONGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LOCATIONGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LOCATIONGroupByArgs['orderBy'] }
        : { orderBy?: LOCATIONGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LOCATIONGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLOCATIONGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for LOCATION.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LOCATIONClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CALL<T extends CALLArgs = {}>(args?: Subset<T, CALLArgs>): CheckSelect<T, Prisma__CALLClient<CALL | null >, Prisma__CALLClient<CALLGetPayload<T> | null >>;

    RESTAURANT<T extends RESTAURANTArgs = {}>(args?: Subset<T, RESTAURANTArgs>): CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT | null >, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * LOCATION findUnique
   */
  export type LOCATIONFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the LOCATION
    **/
    select?: LOCATIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LOCATIONInclude | null
    /**
     * Throw an Error if a LOCATION can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LOCATION to fetch.
    **/
    where: LOCATIONWhereUniqueInput
  }


  /**
   * LOCATION findFirst
   */
  export type LOCATIONFindFirstArgs = {
    /**
     * Select specific fields to fetch from the LOCATION
    **/
    select?: LOCATIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LOCATIONInclude | null
    /**
     * Throw an Error if a LOCATION can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LOCATION to fetch.
    **/
    where?: LOCATIONWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LOCATIONS to fetch.
    **/
    orderBy?: Enumerable<LOCATIONOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LOCATIONS.
    **/
    cursor?: LOCATIONWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LOCATIONS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LOCATIONS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LOCATIONS.
    **/
    distinct?: Enumerable<LOCATIONScalarFieldEnum>
  }


  /**
   * LOCATION findMany
   */
  export type LOCATIONFindManyArgs = {
    /**
     * Select specific fields to fetch from the LOCATION
    **/
    select?: LOCATIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LOCATIONInclude | null
    /**
     * Filter, which LOCATIONS to fetch.
    **/
    where?: LOCATIONWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LOCATIONS to fetch.
    **/
    orderBy?: Enumerable<LOCATIONOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LOCATIONS.
    **/
    cursor?: LOCATIONWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LOCATIONS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LOCATIONS.
    **/
    skip?: number
    distinct?: Enumerable<LOCATIONScalarFieldEnum>
  }


  /**
   * LOCATION create
   */
  export type LOCATIONCreateArgs = {
    /**
     * Select specific fields to fetch from the LOCATION
    **/
    select?: LOCATIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LOCATIONInclude | null
    /**
     * The data needed to create a LOCATION.
    **/
    data: XOR<LOCATIONCreateInput, LOCATIONUncheckedCreateInput>
  }


  /**
   * LOCATION createMany
   */
  export type LOCATIONCreateManyArgs = {
    data: Enumerable<LOCATIONCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * LOCATION update
   */
  export type LOCATIONUpdateArgs = {
    /**
     * Select specific fields to fetch from the LOCATION
    **/
    select?: LOCATIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LOCATIONInclude | null
    /**
     * The data needed to update a LOCATION.
    **/
    data: XOR<LOCATIONUpdateInput, LOCATIONUncheckedUpdateInput>
    /**
     * Choose, which LOCATION to update.
    **/
    where: LOCATIONWhereUniqueInput
  }


  /**
   * LOCATION updateMany
   */
  export type LOCATIONUpdateManyArgs = {
    data: XOR<LOCATIONUpdateManyMutationInput, LOCATIONUncheckedUpdateManyInput>
    where?: LOCATIONWhereInput
  }


  /**
   * LOCATION upsert
   */
  export type LOCATIONUpsertArgs = {
    /**
     * Select specific fields to fetch from the LOCATION
    **/
    select?: LOCATIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LOCATIONInclude | null
    /**
     * The filter to search for the LOCATION to update in case it exists.
    **/
    where: LOCATIONWhereUniqueInput
    /**
     * In case the LOCATION found by the `where` argument doesn't exist, create a new LOCATION with this data.
    **/
    create: XOR<LOCATIONCreateInput, LOCATIONUncheckedCreateInput>
    /**
     * In case the LOCATION was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<LOCATIONUpdateInput, LOCATIONUncheckedUpdateInput>
  }


  /**
   * LOCATION delete
   */
  export type LOCATIONDeleteArgs = {
    /**
     * Select specific fields to fetch from the LOCATION
    **/
    select?: LOCATIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LOCATIONInclude | null
    /**
     * Filter which LOCATION to delete.
    **/
    where: LOCATIONWhereUniqueInput
  }


  /**
   * LOCATION deleteMany
   */
  export type LOCATIONDeleteManyArgs = {
    where?: LOCATIONWhereInput
  }


  /**
   * LOCATION without action
   */
  export type LOCATIONArgs = {
    /**
     * Select specific fields to fetch from the LOCATION
    **/
    select?: LOCATIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LOCATIONInclude | null
  }



  /**
   * Model MENU
   */


  export type AggregateMENU = {
    count: MENUCountAggregateOutputType | null
    avg: MENUAvgAggregateOutputType | null
    sum: MENUSumAggregateOutputType | null
    min: MENUMinAggregateOutputType | null
    max: MENUMaxAggregateOutputType | null
  }

  export type MENUAvgAggregateOutputType = {
    seq: number
    price: number
  }

  export type MENUSumAggregateOutputType = {
    seq: number
    price: number
  }

  export type MENUMinAggregateOutputType = {
    seq: number
    name: string | null
    thumbnail: string | null
    description: string | null
    price: number
    isAvailable: boolean | null
    bestmenu: boolean | null
  }

  export type MENUMaxAggregateOutputType = {
    seq: number
    name: string | null
    thumbnail: string | null
    description: string | null
    price: number
    isAvailable: boolean | null
    bestmenu: boolean | null
  }

  export type MENUCountAggregateOutputType = {
    seq: number
    name: number | null
    thumbnail: number | null
    description: number | null
    price: number
    isAvailable: number | null
    bestmenu: number | null
    _all: number
  }


  export type MENUAvgAggregateInputType = {
    seq?: true
    price?: true
  }

  export type MENUSumAggregateInputType = {
    seq?: true
    price?: true
  }

  export type MENUMinAggregateInputType = {
    seq?: true
    name?: true
    thumbnail?: true
    description?: true
    price?: true
    isAvailable?: true
    bestmenu?: true
  }

  export type MENUMaxAggregateInputType = {
    seq?: true
    name?: true
    thumbnail?: true
    description?: true
    price?: true
    isAvailable?: true
    bestmenu?: true
  }

  export type MENUCountAggregateInputType = {
    seq?: true
    name?: true
    thumbnail?: true
    description?: true
    price?: true
    isAvailable?: true
    bestmenu?: true
    _all?: true
  }

  export type MENUAggregateArgs = {
    /**
     * Filter which MENU to aggregate.
    **/
    where?: MENUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MENUS to fetch.
    **/
    orderBy?: Enumerable<MENUOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: MENUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MENUS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MENUS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MENUS
    **/
    count?: true | MENUCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: MENUAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: MENUSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: MENUMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: MENUMaxAggregateInputType
  }

  export type GetMENUAggregateType<T extends MENUAggregateArgs> = {
    [P in keyof T & keyof AggregateMENU]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMENU[P]>
      : GetScalarType<T[P], AggregateMENU[P]>
  }


    
    
  export type MENUGroupByArgs = {
    where?: MENUWhereInput
    orderBy?: Enumerable<MENUOrderByInput>
    by: Array<MENUScalarFieldEnum>
    having?: MENUScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: MENUCountAggregateInputType | true
    avg?: MENUAvgAggregateInputType
    sum?: MENUSumAggregateInputType
    min?: MENUMinAggregateInputType
    max?: MENUMaxAggregateInputType
  }


  export type MENUGroupByOutputType = {
    seq: number
    name: string
    thumbnail: string | null
    description: string | null
    price: number
    isAvailable: boolean
    bestmenu: boolean
    count: MENUCountAggregateOutputType | null
    avg: MENUAvgAggregateOutputType | null
    sum: MENUSumAggregateOutputType | null
    min: MENUMinAggregateOutputType | null
    max: MENUMaxAggregateOutputType | null
  }

  type GetMENUGroupByPayload<T extends MENUGroupByArgs> = Promise<Array<
    PickArray<MENUGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof MENUGroupByOutputType))]: GetScalarType<T[P], MENUGroupByOutputType[P]>
    }
  >>
    

  export type MENUSelect = {
    seq?: boolean
    name?: boolean
    thumbnail?: boolean
    description?: boolean
    price?: boolean
    isAvailable?: boolean
    bestmenu?: boolean
    RESTAURANT?: boolean | RESTAURANTArgs
    OPTION?: boolean | OPTIONArgs
    SELECTED_MENU?: boolean | SELECTED_MENUArgs
  }

  export type MENUInclude = {
    RESTAURANT?: boolean | RESTAURANTArgs
    OPTION?: boolean | OPTIONArgs
    SELECTED_MENU?: boolean | SELECTED_MENUArgs
  }

  export type MENUGetPayload<
    S extends boolean | null | undefined | MENUArgs,
    U = keyof S
      > = S extends true
        ? MENU
    : S extends undefined
    ? never
    : S extends MENUArgs | MENUFindManyArgs
    ?'include' extends U
    ? MENU  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'RESTAURANT'
        ? RESTAURANTGetPayload<S['include'][P]> :
        P extends 'OPTION'
        ? OPTIONGetPayload<S['include'][P]> | null :
        P extends 'SELECTED_MENU'
        ? SELECTED_MENUGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MENU ?MENU [P]
  : 
          P extends 'RESTAURANT'
        ? RESTAURANTGetPayload<S['select'][P]> :
        P extends 'OPTION'
        ? OPTIONGetPayload<S['select'][P]> | null :
        P extends 'SELECTED_MENU'
        ? SELECTED_MENUGetPayload<S['select'][P]> | null : never
  } 
    : MENU
  : MENU


  type MENUCountArgs = Merge<
    Omit<MENUFindManyArgs, 'select' | 'include'> & {
      select?: MENUCountAggregateInputType | true
    }
  >

  export interface MENUDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MENU that matches the filter.
     * @param {MENUFindUniqueArgs} args - Arguments to find a MENU
     * @example
     * // Get one MENU
     * const mENU = await prisma.mENU.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MENUFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MENUFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MENU'> extends True ? CheckSelect<T, Prisma__MENUClient<MENU>, Prisma__MENUClient<MENUGetPayload<T>>> : CheckSelect<T, Prisma__MENUClient<MENU | null >, Prisma__MENUClient<MENUGetPayload<T> | null >>

    /**
     * Find the first MENU that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MENUFindFirstArgs} args - Arguments to find a MENU
     * @example
     * // Get one MENU
     * const mENU = await prisma.mENU.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MENUFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MENUFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MENU'> extends True ? CheckSelect<T, Prisma__MENUClient<MENU>, Prisma__MENUClient<MENUGetPayload<T>>> : CheckSelect<T, Prisma__MENUClient<MENU | null >, Prisma__MENUClient<MENUGetPayload<T> | null >>

    /**
     * Find zero or more MENUS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MENUFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MENUS
     * const mENUS = await prisma.mENU.findMany()
     * 
     * // Get first 10 MENUS
     * const mENUS = await prisma.mENU.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const mENUWithSeqOnly = await prisma.mENU.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends MENUFindManyArgs>(
      args?: SelectSubset<T, MENUFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MENU>>, PrismaPromise<Array<MENUGetPayload<T>>>>

    /**
     * Create a MENU.
     * @param {MENUCreateArgs} args - Arguments to create a MENU.
     * @example
     * // Create one MENU
     * const MENU = await prisma.mENU.create({
     *   data: {
     *     // ... data to create a MENU
     *   }
     * })
     * 
    **/
    create<T extends MENUCreateArgs>(
      args: SelectSubset<T, MENUCreateArgs>
    ): CheckSelect<T, Prisma__MENUClient<MENU>, Prisma__MENUClient<MENUGetPayload<T>>>

    /**
     * Create many MENUS.
     *     @param {MENUCreateManyArgs} args - Arguments to create many MENUS.
     *     @example
     *     // Create many MENUS
     *     const mENU = await prisma.mENU.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MENUCreateManyArgs>(
      args?: SelectSubset<T, MENUCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MENU.
     * @param {MENUDeleteArgs} args - Arguments to delete one MENU.
     * @example
     * // Delete one MENU
     * const MENU = await prisma.mENU.delete({
     *   where: {
     *     // ... filter to delete one MENU
     *   }
     * })
     * 
    **/
    delete<T extends MENUDeleteArgs>(
      args: SelectSubset<T, MENUDeleteArgs>
    ): CheckSelect<T, Prisma__MENUClient<MENU>, Prisma__MENUClient<MENUGetPayload<T>>>

    /**
     * Update one MENU.
     * @param {MENUUpdateArgs} args - Arguments to update one MENU.
     * @example
     * // Update one MENU
     * const mENU = await prisma.mENU.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MENUUpdateArgs>(
      args: SelectSubset<T, MENUUpdateArgs>
    ): CheckSelect<T, Prisma__MENUClient<MENU>, Prisma__MENUClient<MENUGetPayload<T>>>

    /**
     * Delete zero or more MENUS.
     * @param {MENUDeleteManyArgs} args - Arguments to filter MENUS to delete.
     * @example
     * // Delete a few MENUS
     * const { count } = await prisma.mENU.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MENUDeleteManyArgs>(
      args?: SelectSubset<T, MENUDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MENUS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MENUUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MENUS
     * const mENU = await prisma.mENU.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MENUUpdateManyArgs>(
      args: SelectSubset<T, MENUUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MENU.
     * @param {MENUUpsertArgs} args - Arguments to update or create a MENU.
     * @example
     * // Update or create a MENU
     * const mENU = await prisma.mENU.upsert({
     *   create: {
     *     // ... data to create a MENU
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MENU we want to update
     *   }
     * })
    **/
    upsert<T extends MENUUpsertArgs>(
      args: SelectSubset<T, MENUUpsertArgs>
    ): CheckSelect<T, Prisma__MENUClient<MENU>, Prisma__MENUClient<MENUGetPayload<T>>>

    /**
     * Count the number of MENUS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MENUCountArgs} args - Arguments to filter MENUS to count.
     * @example
     * // Count the number of MENUS
     * const count = await prisma.mENU.count({
     *   where: {
     *     // ... the filter for the MENUS we want to count
     *   }
     * })
    **/
    count<T extends MENUCountArgs>(
      args?: Subset<T, MENUCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MENUCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MENU.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MENUAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MENUAggregateArgs>(args: Subset<T, MENUAggregateArgs>): PrismaPromise<GetMENUAggregateType<T>>

    /**
     * Group by MENU.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MENUGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MENUGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MENUGroupByArgs['orderBy'] }
        : { orderBy?: MENUGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MENUGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMENUGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MENU.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MENUClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RESTAURANT<T extends RESTAURANTArgs = {}>(args?: Subset<T, RESTAURANTArgs>): CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT | null >, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T> | null >>;

    OPTION<T extends OPTIONArgs = {}>(args?: Subset<T, OPTIONArgs>): CheckSelect<T, Prisma__OPTIONClient<OPTION | null >, Prisma__OPTIONClient<OPTIONGetPayload<T> | null >>;

    SELECTED_MENU<T extends SELECTED_MENUArgs = {}>(args?: Subset<T, SELECTED_MENUArgs>): CheckSelect<T, Prisma__SELECTED_MENUClient<SELECTED_MENU | null >, Prisma__SELECTED_MENUClient<SELECTED_MENUGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MENU findUnique
   */
  export type MENUFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MENU
    **/
    select?: MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MENUInclude | null
    /**
     * Throw an Error if a MENU can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MENU to fetch.
    **/
    where: MENUWhereUniqueInput
  }


  /**
   * MENU findFirst
   */
  export type MENUFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MENU
    **/
    select?: MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MENUInclude | null
    /**
     * Throw an Error if a MENU can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MENU to fetch.
    **/
    where?: MENUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MENUS to fetch.
    **/
    orderBy?: Enumerable<MENUOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MENUS.
    **/
    cursor?: MENUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MENUS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MENUS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MENUS.
    **/
    distinct?: Enumerable<MENUScalarFieldEnum>
  }


  /**
   * MENU findMany
   */
  export type MENUFindManyArgs = {
    /**
     * Select specific fields to fetch from the MENU
    **/
    select?: MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MENUInclude | null
    /**
     * Filter, which MENUS to fetch.
    **/
    where?: MENUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MENUS to fetch.
    **/
    orderBy?: Enumerable<MENUOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MENUS.
    **/
    cursor?: MENUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MENUS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MENUS.
    **/
    skip?: number
    distinct?: Enumerable<MENUScalarFieldEnum>
  }


  /**
   * MENU create
   */
  export type MENUCreateArgs = {
    /**
     * Select specific fields to fetch from the MENU
    **/
    select?: MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MENUInclude | null
    /**
     * The data needed to create a MENU.
    **/
    data: XOR<MENUCreateInput, MENUUncheckedCreateInput>
  }


  /**
   * MENU createMany
   */
  export type MENUCreateManyArgs = {
    data: Enumerable<MENUCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MENU update
   */
  export type MENUUpdateArgs = {
    /**
     * Select specific fields to fetch from the MENU
    **/
    select?: MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MENUInclude | null
    /**
     * The data needed to update a MENU.
    **/
    data: XOR<MENUUpdateInput, MENUUncheckedUpdateInput>
    /**
     * Choose, which MENU to update.
    **/
    where: MENUWhereUniqueInput
  }


  /**
   * MENU updateMany
   */
  export type MENUUpdateManyArgs = {
    data: XOR<MENUUpdateManyMutationInput, MENUUncheckedUpdateManyInput>
    where?: MENUWhereInput
  }


  /**
   * MENU upsert
   */
  export type MENUUpsertArgs = {
    /**
     * Select specific fields to fetch from the MENU
    **/
    select?: MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MENUInclude | null
    /**
     * The filter to search for the MENU to update in case it exists.
    **/
    where: MENUWhereUniqueInput
    /**
     * In case the MENU found by the `where` argument doesn't exist, create a new MENU with this data.
    **/
    create: XOR<MENUCreateInput, MENUUncheckedCreateInput>
    /**
     * In case the MENU was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<MENUUpdateInput, MENUUncheckedUpdateInput>
  }


  /**
   * MENU delete
   */
  export type MENUDeleteArgs = {
    /**
     * Select specific fields to fetch from the MENU
    **/
    select?: MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MENUInclude | null
    /**
     * Filter which MENU to delete.
    **/
    where: MENUWhereUniqueInput
  }


  /**
   * MENU deleteMany
   */
  export type MENUDeleteManyArgs = {
    where?: MENUWhereInput
  }


  /**
   * MENU without action
   */
  export type MENUArgs = {
    /**
     * Select specific fields to fetch from the MENU
    **/
    select?: MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MENUInclude | null
  }



  /**
   * Model MESSAGE
   */


  export type AggregateMESSAGE = {
    count: MESSAGECountAggregateOutputType | null
    avg: MESSAGEAvgAggregateOutputType | null
    sum: MESSAGESumAggregateOutputType | null
    min: MESSAGEMinAggregateOutputType | null
    max: MESSAGEMaxAggregateOutputType | null
  }

  export type MESSAGEAvgAggregateOutputType = {
    seq: number
  }

  export type MESSAGESumAggregateOutputType = {
    seq: number
  }

  export type MESSAGEMinAggregateOutputType = {
    seq: number
    text: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MESSAGEMaxAggregateOutputType = {
    seq: number
    text: string | null
    isRead: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MESSAGECountAggregateOutputType = {
    seq: number
    text: number | null
    isRead: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type MESSAGEAvgAggregateInputType = {
    seq?: true
  }

  export type MESSAGESumAggregateInputType = {
    seq?: true
  }

  export type MESSAGEMinAggregateInputType = {
    seq?: true
    text?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MESSAGEMaxAggregateInputType = {
    seq?: true
    text?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MESSAGECountAggregateInputType = {
    seq?: true
    text?: true
    isRead?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MESSAGEAggregateArgs = {
    /**
     * Filter which MESSAGE to aggregate.
    **/
    where?: MESSAGEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MESSAGES to fetch.
    **/
    orderBy?: Enumerable<MESSAGEOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: MESSAGEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MESSAGES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MESSAGES.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MESSAGES
    **/
    count?: true | MESSAGECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: MESSAGEAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: MESSAGESumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: MESSAGEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: MESSAGEMaxAggregateInputType
  }

  export type GetMESSAGEAggregateType<T extends MESSAGEAggregateArgs> = {
    [P in keyof T & keyof AggregateMESSAGE]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMESSAGE[P]>
      : GetScalarType<T[P], AggregateMESSAGE[P]>
  }


    
    
  export type MESSAGEGroupByArgs = {
    where?: MESSAGEWhereInput
    orderBy?: Enumerable<MESSAGEOrderByInput>
    by: Array<MESSAGEScalarFieldEnum>
    having?: MESSAGEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: MESSAGECountAggregateInputType | true
    avg?: MESSAGEAvgAggregateInputType
    sum?: MESSAGESumAggregateInputType
    min?: MESSAGEMinAggregateInputType
    max?: MESSAGEMaxAggregateInputType
  }


  export type MESSAGEGroupByOutputType = {
    seq: number
    text: string
    isRead: boolean
    createdAt: Date
    updatedAt: Date | null
    count: MESSAGECountAggregateOutputType | null
    avg: MESSAGEAvgAggregateOutputType | null
    sum: MESSAGESumAggregateOutputType | null
    min: MESSAGEMinAggregateOutputType | null
    max: MESSAGEMaxAggregateOutputType | null
  }

  type GetMESSAGEGroupByPayload<T extends MESSAGEGroupByArgs> = Promise<Array<
    PickArray<MESSAGEGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof MESSAGEGroupByOutputType))]: GetScalarType<T[P], MESSAGEGroupByOutputType[P]>
    }
  >>
    

  export type MESSAGESelect = {
    seq?: boolean
    text?: boolean
    isRead?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    USER?: boolean | USERArgs
    CHAT_CHATToMESSAGE_seq?: boolean | CHATArgs
    CHAT_CHAT_seqToMESSAGE?: boolean | CHATArgs
  }

  export type MESSAGEInclude = {
    USER?: boolean | USERArgs
    CHAT_CHATToMESSAGE_seq?: boolean | CHATArgs
    CHAT_CHAT_seqToMESSAGE?: boolean | CHATArgs
  }

  export type MESSAGEGetPayload<
    S extends boolean | null | undefined | MESSAGEArgs,
    U = keyof S
      > = S extends true
        ? MESSAGE
    : S extends undefined
    ? never
    : S extends MESSAGEArgs | MESSAGEFindManyArgs
    ?'include' extends U
    ? MESSAGE  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'USER'
        ? USERGetPayload<S['include'][P]> :
        P extends 'CHAT_CHATToMESSAGE_seq'
        ? CHATGetPayload<S['include'][P]> :
        P extends 'CHAT_CHAT_seqToMESSAGE'
        ? CHATGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof MESSAGE ?MESSAGE [P]
  : 
          P extends 'USER'
        ? USERGetPayload<S['select'][P]> :
        P extends 'CHAT_CHATToMESSAGE_seq'
        ? CHATGetPayload<S['select'][P]> :
        P extends 'CHAT_CHAT_seqToMESSAGE'
        ? CHATGetPayload<S['select'][P]> | null : never
  } 
    : MESSAGE
  : MESSAGE


  type MESSAGECountArgs = Merge<
    Omit<MESSAGEFindManyArgs, 'select' | 'include'> & {
      select?: MESSAGECountAggregateInputType | true
    }
  >

  export interface MESSAGEDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MESSAGE that matches the filter.
     * @param {MESSAGEFindUniqueArgs} args - Arguments to find a MESSAGE
     * @example
     * // Get one MESSAGE
     * const mESSAGE = await prisma.mESSAGE.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MESSAGEFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MESSAGEFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MESSAGE'> extends True ? CheckSelect<T, Prisma__MESSAGEClient<MESSAGE>, Prisma__MESSAGEClient<MESSAGEGetPayload<T>>> : CheckSelect<T, Prisma__MESSAGEClient<MESSAGE | null >, Prisma__MESSAGEClient<MESSAGEGetPayload<T> | null >>

    /**
     * Find the first MESSAGE that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MESSAGEFindFirstArgs} args - Arguments to find a MESSAGE
     * @example
     * // Get one MESSAGE
     * const mESSAGE = await prisma.mESSAGE.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MESSAGEFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MESSAGEFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MESSAGE'> extends True ? CheckSelect<T, Prisma__MESSAGEClient<MESSAGE>, Prisma__MESSAGEClient<MESSAGEGetPayload<T>>> : CheckSelect<T, Prisma__MESSAGEClient<MESSAGE | null >, Prisma__MESSAGEClient<MESSAGEGetPayload<T> | null >>

    /**
     * Find zero or more MESSAGES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MESSAGEFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MESSAGES
     * const mESSAGES = await prisma.mESSAGE.findMany()
     * 
     * // Get first 10 MESSAGES
     * const mESSAGES = await prisma.mESSAGE.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const mESSAGEWithSeqOnly = await prisma.mESSAGE.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends MESSAGEFindManyArgs>(
      args?: SelectSubset<T, MESSAGEFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MESSAGE>>, PrismaPromise<Array<MESSAGEGetPayload<T>>>>

    /**
     * Create a MESSAGE.
     * @param {MESSAGECreateArgs} args - Arguments to create a MESSAGE.
     * @example
     * // Create one MESSAGE
     * const MESSAGE = await prisma.mESSAGE.create({
     *   data: {
     *     // ... data to create a MESSAGE
     *   }
     * })
     * 
    **/
    create<T extends MESSAGECreateArgs>(
      args: SelectSubset<T, MESSAGECreateArgs>
    ): CheckSelect<T, Prisma__MESSAGEClient<MESSAGE>, Prisma__MESSAGEClient<MESSAGEGetPayload<T>>>

    /**
     * Create many MESSAGES.
     *     @param {MESSAGECreateManyArgs} args - Arguments to create many MESSAGES.
     *     @example
     *     // Create many MESSAGES
     *     const mESSAGE = await prisma.mESSAGE.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MESSAGECreateManyArgs>(
      args?: SelectSubset<T, MESSAGECreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MESSAGE.
     * @param {MESSAGEDeleteArgs} args - Arguments to delete one MESSAGE.
     * @example
     * // Delete one MESSAGE
     * const MESSAGE = await prisma.mESSAGE.delete({
     *   where: {
     *     // ... filter to delete one MESSAGE
     *   }
     * })
     * 
    **/
    delete<T extends MESSAGEDeleteArgs>(
      args: SelectSubset<T, MESSAGEDeleteArgs>
    ): CheckSelect<T, Prisma__MESSAGEClient<MESSAGE>, Prisma__MESSAGEClient<MESSAGEGetPayload<T>>>

    /**
     * Update one MESSAGE.
     * @param {MESSAGEUpdateArgs} args - Arguments to update one MESSAGE.
     * @example
     * // Update one MESSAGE
     * const mESSAGE = await prisma.mESSAGE.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MESSAGEUpdateArgs>(
      args: SelectSubset<T, MESSAGEUpdateArgs>
    ): CheckSelect<T, Prisma__MESSAGEClient<MESSAGE>, Prisma__MESSAGEClient<MESSAGEGetPayload<T>>>

    /**
     * Delete zero or more MESSAGES.
     * @param {MESSAGEDeleteManyArgs} args - Arguments to filter MESSAGES to delete.
     * @example
     * // Delete a few MESSAGES
     * const { count } = await prisma.mESSAGE.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MESSAGEDeleteManyArgs>(
      args?: SelectSubset<T, MESSAGEDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MESSAGES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MESSAGEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MESSAGES
     * const mESSAGE = await prisma.mESSAGE.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MESSAGEUpdateManyArgs>(
      args: SelectSubset<T, MESSAGEUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MESSAGE.
     * @param {MESSAGEUpsertArgs} args - Arguments to update or create a MESSAGE.
     * @example
     * // Update or create a MESSAGE
     * const mESSAGE = await prisma.mESSAGE.upsert({
     *   create: {
     *     // ... data to create a MESSAGE
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MESSAGE we want to update
     *   }
     * })
    **/
    upsert<T extends MESSAGEUpsertArgs>(
      args: SelectSubset<T, MESSAGEUpsertArgs>
    ): CheckSelect<T, Prisma__MESSAGEClient<MESSAGE>, Prisma__MESSAGEClient<MESSAGEGetPayload<T>>>

    /**
     * Count the number of MESSAGES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MESSAGECountArgs} args - Arguments to filter MESSAGES to count.
     * @example
     * // Count the number of MESSAGES
     * const count = await prisma.mESSAGE.count({
     *   where: {
     *     // ... the filter for the MESSAGES we want to count
     *   }
     * })
    **/
    count<T extends MESSAGECountArgs>(
      args?: Subset<T, MESSAGECountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MESSAGECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MESSAGE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MESSAGEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MESSAGEAggregateArgs>(args: Subset<T, MESSAGEAggregateArgs>): PrismaPromise<GetMESSAGEAggregateType<T>>

    /**
     * Group by MESSAGE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MESSAGEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MESSAGEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MESSAGEGroupByArgs['orderBy'] }
        : { orderBy?: MESSAGEGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MESSAGEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMESSAGEGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MESSAGE.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MESSAGEClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    USER<T extends USERArgs = {}>(args?: Subset<T, USERArgs>): CheckSelect<T, Prisma__USERClient<USER | null >, Prisma__USERClient<USERGetPayload<T> | null >>;

    CHAT_CHATToMESSAGE_seq<T extends CHATArgs = {}>(args?: Subset<T, CHATArgs>): CheckSelect<T, Prisma__CHATClient<CHAT | null >, Prisma__CHATClient<CHATGetPayload<T> | null >>;

    CHAT_CHAT_seqToMESSAGE<T extends CHATArgs = {}>(args?: Subset<T, CHATArgs>): CheckSelect<T, Prisma__CHATClient<CHAT | null >, Prisma__CHATClient<CHATGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MESSAGE findUnique
   */
  export type MESSAGEFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MESSAGE
    **/
    select?: MESSAGESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MESSAGEInclude | null
    /**
     * Throw an Error if a MESSAGE can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MESSAGE to fetch.
    **/
    where: MESSAGEWhereUniqueInput
  }


  /**
   * MESSAGE findFirst
   */
  export type MESSAGEFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MESSAGE
    **/
    select?: MESSAGESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MESSAGEInclude | null
    /**
     * Throw an Error if a MESSAGE can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MESSAGE to fetch.
    **/
    where?: MESSAGEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MESSAGES to fetch.
    **/
    orderBy?: Enumerable<MESSAGEOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MESSAGES.
    **/
    cursor?: MESSAGEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MESSAGES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MESSAGES.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MESSAGES.
    **/
    distinct?: Enumerable<MESSAGEScalarFieldEnum>
  }


  /**
   * MESSAGE findMany
   */
  export type MESSAGEFindManyArgs = {
    /**
     * Select specific fields to fetch from the MESSAGE
    **/
    select?: MESSAGESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MESSAGEInclude | null
    /**
     * Filter, which MESSAGES to fetch.
    **/
    where?: MESSAGEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MESSAGES to fetch.
    **/
    orderBy?: Enumerable<MESSAGEOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MESSAGES.
    **/
    cursor?: MESSAGEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MESSAGES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MESSAGES.
    **/
    skip?: number
    distinct?: Enumerable<MESSAGEScalarFieldEnum>
  }


  /**
   * MESSAGE create
   */
  export type MESSAGECreateArgs = {
    /**
     * Select specific fields to fetch from the MESSAGE
    **/
    select?: MESSAGESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MESSAGEInclude | null
    /**
     * The data needed to create a MESSAGE.
    **/
    data: XOR<MESSAGECreateInput, MESSAGEUncheckedCreateInput>
  }


  /**
   * MESSAGE createMany
   */
  export type MESSAGECreateManyArgs = {
    data: Enumerable<MESSAGECreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MESSAGE update
   */
  export type MESSAGEUpdateArgs = {
    /**
     * Select specific fields to fetch from the MESSAGE
    **/
    select?: MESSAGESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MESSAGEInclude | null
    /**
     * The data needed to update a MESSAGE.
    **/
    data: XOR<MESSAGEUpdateInput, MESSAGEUncheckedUpdateInput>
    /**
     * Choose, which MESSAGE to update.
    **/
    where: MESSAGEWhereUniqueInput
  }


  /**
   * MESSAGE updateMany
   */
  export type MESSAGEUpdateManyArgs = {
    data: XOR<MESSAGEUpdateManyMutationInput, MESSAGEUncheckedUpdateManyInput>
    where?: MESSAGEWhereInput
  }


  /**
   * MESSAGE upsert
   */
  export type MESSAGEUpsertArgs = {
    /**
     * Select specific fields to fetch from the MESSAGE
    **/
    select?: MESSAGESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MESSAGEInclude | null
    /**
     * The filter to search for the MESSAGE to update in case it exists.
    **/
    where: MESSAGEWhereUniqueInput
    /**
     * In case the MESSAGE found by the `where` argument doesn't exist, create a new MESSAGE with this data.
    **/
    create: XOR<MESSAGECreateInput, MESSAGEUncheckedCreateInput>
    /**
     * In case the MESSAGE was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<MESSAGEUpdateInput, MESSAGEUncheckedUpdateInput>
  }


  /**
   * MESSAGE delete
   */
  export type MESSAGEDeleteArgs = {
    /**
     * Select specific fields to fetch from the MESSAGE
    **/
    select?: MESSAGESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MESSAGEInclude | null
    /**
     * Filter which MESSAGE to delete.
    **/
    where: MESSAGEWhereUniqueInput
  }


  /**
   * MESSAGE deleteMany
   */
  export type MESSAGEDeleteManyArgs = {
    where?: MESSAGEWhereInput
  }


  /**
   * MESSAGE without action
   */
  export type MESSAGEArgs = {
    /**
     * Select specific fields to fetch from the MESSAGE
    **/
    select?: MESSAGESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: MESSAGEInclude | null
  }



  /**
   * Model OPTION
   */


  export type AggregateOPTION = {
    count: OPTIONCountAggregateOutputType | null
    avg: OPTIONAvgAggregateOutputType | null
    sum: OPTIONSumAggregateOutputType | null
    min: OPTIONMinAggregateOutputType | null
    max: OPTIONMaxAggregateOutputType | null
  }

  export type OPTIONAvgAggregateOutputType = {
    seq: number
  }

  export type OPTIONSumAggregateOutputType = {
    seq: number
  }

  export type OPTIONMinAggregateOutputType = {
    seq: number
    category: string | null
    isRequired: boolean | null
    isMultiple: boolean | null
  }

  export type OPTIONMaxAggregateOutputType = {
    seq: number
    category: string | null
    isRequired: boolean | null
    isMultiple: boolean | null
  }

  export type OPTIONCountAggregateOutputType = {
    seq: number
    category: number | null
    isRequired: number | null
    isMultiple: number | null
    _all: number
  }


  export type OPTIONAvgAggregateInputType = {
    seq?: true
  }

  export type OPTIONSumAggregateInputType = {
    seq?: true
  }

  export type OPTIONMinAggregateInputType = {
    seq?: true
    category?: true
    isRequired?: true
    isMultiple?: true
  }

  export type OPTIONMaxAggregateInputType = {
    seq?: true
    category?: true
    isRequired?: true
    isMultiple?: true
  }

  export type OPTIONCountAggregateInputType = {
    seq?: true
    category?: true
    isRequired?: true
    isMultiple?: true
    _all?: true
  }

  export type OPTIONAggregateArgs = {
    /**
     * Filter which OPTION to aggregate.
    **/
    where?: OPTIONWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OPTIONS to fetch.
    **/
    orderBy?: Enumerable<OPTIONOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: OPTIONWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OPTIONS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OPTIONS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OPTIONS
    **/
    count?: true | OPTIONCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: OPTIONAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: OPTIONSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: OPTIONMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: OPTIONMaxAggregateInputType
  }

  export type GetOPTIONAggregateType<T extends OPTIONAggregateArgs> = {
    [P in keyof T & keyof AggregateOPTION]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOPTION[P]>
      : GetScalarType<T[P], AggregateOPTION[P]>
  }


    
    
  export type OPTIONGroupByArgs = {
    where?: OPTIONWhereInput
    orderBy?: Enumerable<OPTIONOrderByInput>
    by: Array<OPTIONScalarFieldEnum>
    having?: OPTIONScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: OPTIONCountAggregateInputType | true
    avg?: OPTIONAvgAggregateInputType
    sum?: OPTIONSumAggregateInputType
    min?: OPTIONMinAggregateInputType
    max?: OPTIONMaxAggregateInputType
  }


  export type OPTIONGroupByOutputType = {
    seq: number
    category: string
    isRequired: boolean
    isMultiple: boolean
    count: OPTIONCountAggregateOutputType | null
    avg: OPTIONAvgAggregateOutputType | null
    sum: OPTIONSumAggregateOutputType | null
    min: OPTIONMinAggregateOutputType | null
    max: OPTIONMaxAggregateOutputType | null
  }

  type GetOPTIONGroupByPayload<T extends OPTIONGroupByArgs> = Promise<Array<
    PickArray<OPTIONGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof OPTIONGroupByOutputType))]: GetScalarType<T[P], OPTIONGroupByOutputType[P]>
    }
  >>
    

  export type OPTIONSelect = {
    seq?: boolean
    category?: boolean
    isRequired?: boolean
    isMultiple?: boolean
    MENU?: boolean | MENUArgs
    OPTION_ITEM?: boolean | OPTION_ITEMArgs
  }

  export type OPTIONInclude = {
    MENU?: boolean | MENUArgs
    OPTION_ITEM?: boolean | OPTION_ITEMArgs
  }

  export type OPTIONGetPayload<
    S extends boolean | null | undefined | OPTIONArgs,
    U = keyof S
      > = S extends true
        ? OPTION
    : S extends undefined
    ? never
    : S extends OPTIONArgs | OPTIONFindManyArgs
    ?'include' extends U
    ? OPTION  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'MENU'
        ? MENUGetPayload<S['include'][P]> :
        P extends 'OPTION_ITEM'
        ? OPTION_ITEMGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OPTION ?OPTION [P]
  : 
          P extends 'MENU'
        ? MENUGetPayload<S['select'][P]> :
        P extends 'OPTION_ITEM'
        ? OPTION_ITEMGetPayload<S['select'][P]> | null : never
  } 
    : OPTION
  : OPTION


  type OPTIONCountArgs = Merge<
    Omit<OPTIONFindManyArgs, 'select' | 'include'> & {
      select?: OPTIONCountAggregateInputType | true
    }
  >

  export interface OPTIONDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OPTION that matches the filter.
     * @param {OPTIONFindUniqueArgs} args - Arguments to find a OPTION
     * @example
     * // Get one OPTION
     * const oPTION = await prisma.oPTION.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OPTIONFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OPTIONFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OPTION'> extends True ? CheckSelect<T, Prisma__OPTIONClient<OPTION>, Prisma__OPTIONClient<OPTIONGetPayload<T>>> : CheckSelect<T, Prisma__OPTIONClient<OPTION | null >, Prisma__OPTIONClient<OPTIONGetPayload<T> | null >>

    /**
     * Find the first OPTION that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OPTIONFindFirstArgs} args - Arguments to find a OPTION
     * @example
     * // Get one OPTION
     * const oPTION = await prisma.oPTION.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OPTIONFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OPTIONFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OPTION'> extends True ? CheckSelect<T, Prisma__OPTIONClient<OPTION>, Prisma__OPTIONClient<OPTIONGetPayload<T>>> : CheckSelect<T, Prisma__OPTIONClient<OPTION | null >, Prisma__OPTIONClient<OPTIONGetPayload<T> | null >>

    /**
     * Find zero or more OPTIONS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OPTIONFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OPTIONS
     * const oPTIONS = await prisma.oPTION.findMany()
     * 
     * // Get first 10 OPTIONS
     * const oPTIONS = await prisma.oPTION.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const oPTIONWithSeqOnly = await prisma.oPTION.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends OPTIONFindManyArgs>(
      args?: SelectSubset<T, OPTIONFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OPTION>>, PrismaPromise<Array<OPTIONGetPayload<T>>>>

    /**
     * Create a OPTION.
     * @param {OPTIONCreateArgs} args - Arguments to create a OPTION.
     * @example
     * // Create one OPTION
     * const OPTION = await prisma.oPTION.create({
     *   data: {
     *     // ... data to create a OPTION
     *   }
     * })
     * 
    **/
    create<T extends OPTIONCreateArgs>(
      args: SelectSubset<T, OPTIONCreateArgs>
    ): CheckSelect<T, Prisma__OPTIONClient<OPTION>, Prisma__OPTIONClient<OPTIONGetPayload<T>>>

    /**
     * Create many OPTIONS.
     *     @param {OPTIONCreateManyArgs} args - Arguments to create many OPTIONS.
     *     @example
     *     // Create many OPTIONS
     *     const oPTION = await prisma.oPTION.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OPTIONCreateManyArgs>(
      args?: SelectSubset<T, OPTIONCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OPTION.
     * @param {OPTIONDeleteArgs} args - Arguments to delete one OPTION.
     * @example
     * // Delete one OPTION
     * const OPTION = await prisma.oPTION.delete({
     *   where: {
     *     // ... filter to delete one OPTION
     *   }
     * })
     * 
    **/
    delete<T extends OPTIONDeleteArgs>(
      args: SelectSubset<T, OPTIONDeleteArgs>
    ): CheckSelect<T, Prisma__OPTIONClient<OPTION>, Prisma__OPTIONClient<OPTIONGetPayload<T>>>

    /**
     * Update one OPTION.
     * @param {OPTIONUpdateArgs} args - Arguments to update one OPTION.
     * @example
     * // Update one OPTION
     * const oPTION = await prisma.oPTION.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OPTIONUpdateArgs>(
      args: SelectSubset<T, OPTIONUpdateArgs>
    ): CheckSelect<T, Prisma__OPTIONClient<OPTION>, Prisma__OPTIONClient<OPTIONGetPayload<T>>>

    /**
     * Delete zero or more OPTIONS.
     * @param {OPTIONDeleteManyArgs} args - Arguments to filter OPTIONS to delete.
     * @example
     * // Delete a few OPTIONS
     * const { count } = await prisma.oPTION.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OPTIONDeleteManyArgs>(
      args?: SelectSubset<T, OPTIONDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OPTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OPTIONUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OPTIONS
     * const oPTION = await prisma.oPTION.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OPTIONUpdateManyArgs>(
      args: SelectSubset<T, OPTIONUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OPTION.
     * @param {OPTIONUpsertArgs} args - Arguments to update or create a OPTION.
     * @example
     * // Update or create a OPTION
     * const oPTION = await prisma.oPTION.upsert({
     *   create: {
     *     // ... data to create a OPTION
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OPTION we want to update
     *   }
     * })
    **/
    upsert<T extends OPTIONUpsertArgs>(
      args: SelectSubset<T, OPTIONUpsertArgs>
    ): CheckSelect<T, Prisma__OPTIONClient<OPTION>, Prisma__OPTIONClient<OPTIONGetPayload<T>>>

    /**
     * Count the number of OPTIONS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OPTIONCountArgs} args - Arguments to filter OPTIONS to count.
     * @example
     * // Count the number of OPTIONS
     * const count = await prisma.oPTION.count({
     *   where: {
     *     // ... the filter for the OPTIONS we want to count
     *   }
     * })
    **/
    count<T extends OPTIONCountArgs>(
      args?: Subset<T, OPTIONCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OPTIONCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OPTION.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OPTIONAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OPTIONAggregateArgs>(args: Subset<T, OPTIONAggregateArgs>): PrismaPromise<GetOPTIONAggregateType<T>>

    /**
     * Group by OPTION.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OPTIONGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OPTIONGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OPTIONGroupByArgs['orderBy'] }
        : { orderBy?: OPTIONGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OPTIONGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOPTIONGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OPTION.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OPTIONClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    MENU<T extends MENUArgs = {}>(args?: Subset<T, MENUArgs>): CheckSelect<T, Prisma__MENUClient<MENU | null >, Prisma__MENUClient<MENUGetPayload<T> | null >>;

    OPTION_ITEM<T extends OPTION_ITEMArgs = {}>(args?: Subset<T, OPTION_ITEMArgs>): CheckSelect<T, Prisma__OPTION_ITEMClient<OPTION_ITEM | null >, Prisma__OPTION_ITEMClient<OPTION_ITEMGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OPTION findUnique
   */
  export type OPTIONFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OPTION
    **/
    select?: OPTIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTIONInclude | null
    /**
     * Throw an Error if a OPTION can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OPTION to fetch.
    **/
    where: OPTIONWhereUniqueInput
  }


  /**
   * OPTION findFirst
   */
  export type OPTIONFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OPTION
    **/
    select?: OPTIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTIONInclude | null
    /**
     * Throw an Error if a OPTION can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OPTION to fetch.
    **/
    where?: OPTIONWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OPTIONS to fetch.
    **/
    orderBy?: Enumerable<OPTIONOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OPTIONS.
    **/
    cursor?: OPTIONWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OPTIONS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OPTIONS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OPTIONS.
    **/
    distinct?: Enumerable<OPTIONScalarFieldEnum>
  }


  /**
   * OPTION findMany
   */
  export type OPTIONFindManyArgs = {
    /**
     * Select specific fields to fetch from the OPTION
    **/
    select?: OPTIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTIONInclude | null
    /**
     * Filter, which OPTIONS to fetch.
    **/
    where?: OPTIONWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OPTIONS to fetch.
    **/
    orderBy?: Enumerable<OPTIONOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OPTIONS.
    **/
    cursor?: OPTIONWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OPTIONS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OPTIONS.
    **/
    skip?: number
    distinct?: Enumerable<OPTIONScalarFieldEnum>
  }


  /**
   * OPTION create
   */
  export type OPTIONCreateArgs = {
    /**
     * Select specific fields to fetch from the OPTION
    **/
    select?: OPTIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTIONInclude | null
    /**
     * The data needed to create a OPTION.
    **/
    data: XOR<OPTIONCreateInput, OPTIONUncheckedCreateInput>
  }


  /**
   * OPTION createMany
   */
  export type OPTIONCreateManyArgs = {
    data: Enumerable<OPTIONCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OPTION update
   */
  export type OPTIONUpdateArgs = {
    /**
     * Select specific fields to fetch from the OPTION
    **/
    select?: OPTIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTIONInclude | null
    /**
     * The data needed to update a OPTION.
    **/
    data: XOR<OPTIONUpdateInput, OPTIONUncheckedUpdateInput>
    /**
     * Choose, which OPTION to update.
    **/
    where: OPTIONWhereUniqueInput
  }


  /**
   * OPTION updateMany
   */
  export type OPTIONUpdateManyArgs = {
    data: XOR<OPTIONUpdateManyMutationInput, OPTIONUncheckedUpdateManyInput>
    where?: OPTIONWhereInput
  }


  /**
   * OPTION upsert
   */
  export type OPTIONUpsertArgs = {
    /**
     * Select specific fields to fetch from the OPTION
    **/
    select?: OPTIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTIONInclude | null
    /**
     * The filter to search for the OPTION to update in case it exists.
    **/
    where: OPTIONWhereUniqueInput
    /**
     * In case the OPTION found by the `where` argument doesn't exist, create a new OPTION with this data.
    **/
    create: XOR<OPTIONCreateInput, OPTIONUncheckedCreateInput>
    /**
     * In case the OPTION was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<OPTIONUpdateInput, OPTIONUncheckedUpdateInput>
  }


  /**
   * OPTION delete
   */
  export type OPTIONDeleteArgs = {
    /**
     * Select specific fields to fetch from the OPTION
    **/
    select?: OPTIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTIONInclude | null
    /**
     * Filter which OPTION to delete.
    **/
    where: OPTIONWhereUniqueInput
  }


  /**
   * OPTION deleteMany
   */
  export type OPTIONDeleteManyArgs = {
    where?: OPTIONWhereInput
  }


  /**
   * OPTION without action
   */
  export type OPTIONArgs = {
    /**
     * Select specific fields to fetch from the OPTION
    **/
    select?: OPTIONSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTIONInclude | null
  }



  /**
   * Model OPTION_ITEM
   */


  export type AggregateOPTION_ITEM = {
    count: OPTION_ITEMCountAggregateOutputType | null
    avg: OPTION_ITEMAvgAggregateOutputType | null
    sum: OPTION_ITEMSumAggregateOutputType | null
    min: OPTION_ITEMMinAggregateOutputType | null
    max: OPTION_ITEMMaxAggregateOutputType | null
  }

  export type OPTION_ITEMAvgAggregateOutputType = {
    seq: number
    price: number
  }

  export type OPTION_ITEMSumAggregateOutputType = {
    seq: number
    price: number
  }

  export type OPTION_ITEMMinAggregateOutputType = {
    seq: number
    content: string | null
    price: number
  }

  export type OPTION_ITEMMaxAggregateOutputType = {
    seq: number
    content: string | null
    price: number
  }

  export type OPTION_ITEMCountAggregateOutputType = {
    seq: number
    content: number | null
    price: number
    _all: number
  }


  export type OPTION_ITEMAvgAggregateInputType = {
    seq?: true
    price?: true
  }

  export type OPTION_ITEMSumAggregateInputType = {
    seq?: true
    price?: true
  }

  export type OPTION_ITEMMinAggregateInputType = {
    seq?: true
    content?: true
    price?: true
  }

  export type OPTION_ITEMMaxAggregateInputType = {
    seq?: true
    content?: true
    price?: true
  }

  export type OPTION_ITEMCountAggregateInputType = {
    seq?: true
    content?: true
    price?: true
    _all?: true
  }

  export type OPTION_ITEMAggregateArgs = {
    /**
     * Filter which OPTION_ITEM to aggregate.
    **/
    where?: OPTION_ITEMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OPTION_ITEMS to fetch.
    **/
    orderBy?: Enumerable<OPTION_ITEMOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: OPTION_ITEMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OPTION_ITEMS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OPTION_ITEMS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OPTION_ITEMS
    **/
    count?: true | OPTION_ITEMCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: OPTION_ITEMAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: OPTION_ITEMSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: OPTION_ITEMMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: OPTION_ITEMMaxAggregateInputType
  }

  export type GetOPTION_ITEMAggregateType<T extends OPTION_ITEMAggregateArgs> = {
    [P in keyof T & keyof AggregateOPTION_ITEM]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOPTION_ITEM[P]>
      : GetScalarType<T[P], AggregateOPTION_ITEM[P]>
  }


    
    
  export type OPTION_ITEMGroupByArgs = {
    where?: OPTION_ITEMWhereInput
    orderBy?: Enumerable<OPTION_ITEMOrderByInput>
    by: Array<OPTION_ITEMScalarFieldEnum>
    having?: OPTION_ITEMScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: OPTION_ITEMCountAggregateInputType | true
    avg?: OPTION_ITEMAvgAggregateInputType
    sum?: OPTION_ITEMSumAggregateInputType
    min?: OPTION_ITEMMinAggregateInputType
    max?: OPTION_ITEMMaxAggregateInputType
  }


  export type OPTION_ITEMGroupByOutputType = {
    seq: number
    content: string
    price: number
    count: OPTION_ITEMCountAggregateOutputType | null
    avg: OPTION_ITEMAvgAggregateOutputType | null
    sum: OPTION_ITEMSumAggregateOutputType | null
    min: OPTION_ITEMMinAggregateOutputType | null
    max: OPTION_ITEMMaxAggregateOutputType | null
  }

  type GetOPTION_ITEMGroupByPayload<T extends OPTION_ITEMGroupByArgs> = Promise<Array<
    PickArray<OPTION_ITEMGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof OPTION_ITEMGroupByOutputType))]: GetScalarType<T[P], OPTION_ITEMGroupByOutputType[P]>
    }
  >>
    

  export type OPTION_ITEMSelect = {
    seq?: boolean
    content?: boolean
    price?: boolean
    OPTION?: boolean | OPTIONArgs
    SELECTED_MENU?: boolean | SELECTED_MENUArgs
  }

  export type OPTION_ITEMInclude = {
    OPTION?: boolean | OPTIONArgs
    SELECTED_MENU?: boolean | SELECTED_MENUArgs
  }

  export type OPTION_ITEMGetPayload<
    S extends boolean | null | undefined | OPTION_ITEMArgs,
    U = keyof S
      > = S extends true
        ? OPTION_ITEM
    : S extends undefined
    ? never
    : S extends OPTION_ITEMArgs | OPTION_ITEMFindManyArgs
    ?'include' extends U
    ? OPTION_ITEM  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'OPTION'
        ? OPTIONGetPayload<S['include'][P]> :
        P extends 'SELECTED_MENU'
        ? SELECTED_MENUGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof OPTION_ITEM ?OPTION_ITEM [P]
  : 
          P extends 'OPTION'
        ? OPTIONGetPayload<S['select'][P]> :
        P extends 'SELECTED_MENU'
        ? SELECTED_MENUGetPayload<S['select'][P]> | null : never
  } 
    : OPTION_ITEM
  : OPTION_ITEM


  type OPTION_ITEMCountArgs = Merge<
    Omit<OPTION_ITEMFindManyArgs, 'select' | 'include'> & {
      select?: OPTION_ITEMCountAggregateInputType | true
    }
  >

  export interface OPTION_ITEMDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one OPTION_ITEM that matches the filter.
     * @param {OPTION_ITEMFindUniqueArgs} args - Arguments to find a OPTION_ITEM
     * @example
     * // Get one OPTION_ITEM
     * const oPTION_ITEM = await prisma.oPTION_ITEM.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OPTION_ITEMFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, OPTION_ITEMFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'OPTION_ITEM'> extends True ? CheckSelect<T, Prisma__OPTION_ITEMClient<OPTION_ITEM>, Prisma__OPTION_ITEMClient<OPTION_ITEMGetPayload<T>>> : CheckSelect<T, Prisma__OPTION_ITEMClient<OPTION_ITEM | null >, Prisma__OPTION_ITEMClient<OPTION_ITEMGetPayload<T> | null >>

    /**
     * Find the first OPTION_ITEM that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OPTION_ITEMFindFirstArgs} args - Arguments to find a OPTION_ITEM
     * @example
     * // Get one OPTION_ITEM
     * const oPTION_ITEM = await prisma.oPTION_ITEM.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OPTION_ITEMFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, OPTION_ITEMFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'OPTION_ITEM'> extends True ? CheckSelect<T, Prisma__OPTION_ITEMClient<OPTION_ITEM>, Prisma__OPTION_ITEMClient<OPTION_ITEMGetPayload<T>>> : CheckSelect<T, Prisma__OPTION_ITEMClient<OPTION_ITEM | null >, Prisma__OPTION_ITEMClient<OPTION_ITEMGetPayload<T> | null >>

    /**
     * Find zero or more OPTION_ITEMS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OPTION_ITEMFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OPTION_ITEMS
     * const oPTION_ITEMS = await prisma.oPTION_ITEM.findMany()
     * 
     * // Get first 10 OPTION_ITEMS
     * const oPTION_ITEMS = await prisma.oPTION_ITEM.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const oPTION_ITEMWithSeqOnly = await prisma.oPTION_ITEM.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends OPTION_ITEMFindManyArgs>(
      args?: SelectSubset<T, OPTION_ITEMFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<OPTION_ITEM>>, PrismaPromise<Array<OPTION_ITEMGetPayload<T>>>>

    /**
     * Create a OPTION_ITEM.
     * @param {OPTION_ITEMCreateArgs} args - Arguments to create a OPTION_ITEM.
     * @example
     * // Create one OPTION_ITEM
     * const OPTION_ITEM = await prisma.oPTION_ITEM.create({
     *   data: {
     *     // ... data to create a OPTION_ITEM
     *   }
     * })
     * 
    **/
    create<T extends OPTION_ITEMCreateArgs>(
      args: SelectSubset<T, OPTION_ITEMCreateArgs>
    ): CheckSelect<T, Prisma__OPTION_ITEMClient<OPTION_ITEM>, Prisma__OPTION_ITEMClient<OPTION_ITEMGetPayload<T>>>

    /**
     * Create many OPTION_ITEMS.
     *     @param {OPTION_ITEMCreateManyArgs} args - Arguments to create many OPTION_ITEMS.
     *     @example
     *     // Create many OPTION_ITEMS
     *     const oPTION_ITEM = await prisma.oPTION_ITEM.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OPTION_ITEMCreateManyArgs>(
      args?: SelectSubset<T, OPTION_ITEMCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a OPTION_ITEM.
     * @param {OPTION_ITEMDeleteArgs} args - Arguments to delete one OPTION_ITEM.
     * @example
     * // Delete one OPTION_ITEM
     * const OPTION_ITEM = await prisma.oPTION_ITEM.delete({
     *   where: {
     *     // ... filter to delete one OPTION_ITEM
     *   }
     * })
     * 
    **/
    delete<T extends OPTION_ITEMDeleteArgs>(
      args: SelectSubset<T, OPTION_ITEMDeleteArgs>
    ): CheckSelect<T, Prisma__OPTION_ITEMClient<OPTION_ITEM>, Prisma__OPTION_ITEMClient<OPTION_ITEMGetPayload<T>>>

    /**
     * Update one OPTION_ITEM.
     * @param {OPTION_ITEMUpdateArgs} args - Arguments to update one OPTION_ITEM.
     * @example
     * // Update one OPTION_ITEM
     * const oPTION_ITEM = await prisma.oPTION_ITEM.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OPTION_ITEMUpdateArgs>(
      args: SelectSubset<T, OPTION_ITEMUpdateArgs>
    ): CheckSelect<T, Prisma__OPTION_ITEMClient<OPTION_ITEM>, Prisma__OPTION_ITEMClient<OPTION_ITEMGetPayload<T>>>

    /**
     * Delete zero or more OPTION_ITEMS.
     * @param {OPTION_ITEMDeleteManyArgs} args - Arguments to filter OPTION_ITEMS to delete.
     * @example
     * // Delete a few OPTION_ITEMS
     * const { count } = await prisma.oPTION_ITEM.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OPTION_ITEMDeleteManyArgs>(
      args?: SelectSubset<T, OPTION_ITEMDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more OPTION_ITEMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OPTION_ITEMUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OPTION_ITEMS
     * const oPTION_ITEM = await prisma.oPTION_ITEM.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OPTION_ITEMUpdateManyArgs>(
      args: SelectSubset<T, OPTION_ITEMUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one OPTION_ITEM.
     * @param {OPTION_ITEMUpsertArgs} args - Arguments to update or create a OPTION_ITEM.
     * @example
     * // Update or create a OPTION_ITEM
     * const oPTION_ITEM = await prisma.oPTION_ITEM.upsert({
     *   create: {
     *     // ... data to create a OPTION_ITEM
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OPTION_ITEM we want to update
     *   }
     * })
    **/
    upsert<T extends OPTION_ITEMUpsertArgs>(
      args: SelectSubset<T, OPTION_ITEMUpsertArgs>
    ): CheckSelect<T, Prisma__OPTION_ITEMClient<OPTION_ITEM>, Prisma__OPTION_ITEMClient<OPTION_ITEMGetPayload<T>>>

    /**
     * Count the number of OPTION_ITEMS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OPTION_ITEMCountArgs} args - Arguments to filter OPTION_ITEMS to count.
     * @example
     * // Count the number of OPTION_ITEMS
     * const count = await prisma.oPTION_ITEM.count({
     *   where: {
     *     // ... the filter for the OPTION_ITEMS we want to count
     *   }
     * })
    **/
    count<T extends OPTION_ITEMCountArgs>(
      args?: Subset<T, OPTION_ITEMCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OPTION_ITEMCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OPTION_ITEM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OPTION_ITEMAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OPTION_ITEMAggregateArgs>(args: Subset<T, OPTION_ITEMAggregateArgs>): PrismaPromise<GetOPTION_ITEMAggregateType<T>>

    /**
     * Group by OPTION_ITEM.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OPTION_ITEMGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OPTION_ITEMGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OPTION_ITEMGroupByArgs['orderBy'] }
        : { orderBy?: OPTION_ITEMGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OPTION_ITEMGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOPTION_ITEMGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for OPTION_ITEM.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__OPTION_ITEMClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    OPTION<T extends OPTIONArgs = {}>(args?: Subset<T, OPTIONArgs>): CheckSelect<T, Prisma__OPTIONClient<OPTION | null >, Prisma__OPTIONClient<OPTIONGetPayload<T> | null >>;

    SELECTED_MENU<T extends SELECTED_MENUArgs = {}>(args?: Subset<T, SELECTED_MENUArgs>): CheckSelect<T, Prisma__SELECTED_MENUClient<SELECTED_MENU | null >, Prisma__SELECTED_MENUClient<SELECTED_MENUGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * OPTION_ITEM findUnique
   */
  export type OPTION_ITEMFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the OPTION_ITEM
    **/
    select?: OPTION_ITEMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTION_ITEMInclude | null
    /**
     * Throw an Error if a OPTION_ITEM can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OPTION_ITEM to fetch.
    **/
    where: OPTION_ITEMWhereUniqueInput
  }


  /**
   * OPTION_ITEM findFirst
   */
  export type OPTION_ITEMFindFirstArgs = {
    /**
     * Select specific fields to fetch from the OPTION_ITEM
    **/
    select?: OPTION_ITEMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTION_ITEMInclude | null
    /**
     * Throw an Error if a OPTION_ITEM can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which OPTION_ITEM to fetch.
    **/
    where?: OPTION_ITEMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OPTION_ITEMS to fetch.
    **/
    orderBy?: Enumerable<OPTION_ITEMOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OPTION_ITEMS.
    **/
    cursor?: OPTION_ITEMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OPTION_ITEMS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OPTION_ITEMS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OPTION_ITEMS.
    **/
    distinct?: Enumerable<OPTION_ITEMScalarFieldEnum>
  }


  /**
   * OPTION_ITEM findMany
   */
  export type OPTION_ITEMFindManyArgs = {
    /**
     * Select specific fields to fetch from the OPTION_ITEM
    **/
    select?: OPTION_ITEMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTION_ITEMInclude | null
    /**
     * Filter, which OPTION_ITEMS to fetch.
    **/
    where?: OPTION_ITEMWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OPTION_ITEMS to fetch.
    **/
    orderBy?: Enumerable<OPTION_ITEMOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OPTION_ITEMS.
    **/
    cursor?: OPTION_ITEMWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OPTION_ITEMS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OPTION_ITEMS.
    **/
    skip?: number
    distinct?: Enumerable<OPTION_ITEMScalarFieldEnum>
  }


  /**
   * OPTION_ITEM create
   */
  export type OPTION_ITEMCreateArgs = {
    /**
     * Select specific fields to fetch from the OPTION_ITEM
    **/
    select?: OPTION_ITEMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTION_ITEMInclude | null
    /**
     * The data needed to create a OPTION_ITEM.
    **/
    data: XOR<OPTION_ITEMCreateInput, OPTION_ITEMUncheckedCreateInput>
  }


  /**
   * OPTION_ITEM createMany
   */
  export type OPTION_ITEMCreateManyArgs = {
    data: Enumerable<OPTION_ITEMCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * OPTION_ITEM update
   */
  export type OPTION_ITEMUpdateArgs = {
    /**
     * Select specific fields to fetch from the OPTION_ITEM
    **/
    select?: OPTION_ITEMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTION_ITEMInclude | null
    /**
     * The data needed to update a OPTION_ITEM.
    **/
    data: XOR<OPTION_ITEMUpdateInput, OPTION_ITEMUncheckedUpdateInput>
    /**
     * Choose, which OPTION_ITEM to update.
    **/
    where: OPTION_ITEMWhereUniqueInput
  }


  /**
   * OPTION_ITEM updateMany
   */
  export type OPTION_ITEMUpdateManyArgs = {
    data: XOR<OPTION_ITEMUpdateManyMutationInput, OPTION_ITEMUncheckedUpdateManyInput>
    where?: OPTION_ITEMWhereInput
  }


  /**
   * OPTION_ITEM upsert
   */
  export type OPTION_ITEMUpsertArgs = {
    /**
     * Select specific fields to fetch from the OPTION_ITEM
    **/
    select?: OPTION_ITEMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTION_ITEMInclude | null
    /**
     * The filter to search for the OPTION_ITEM to update in case it exists.
    **/
    where: OPTION_ITEMWhereUniqueInput
    /**
     * In case the OPTION_ITEM found by the `where` argument doesn't exist, create a new OPTION_ITEM with this data.
    **/
    create: XOR<OPTION_ITEMCreateInput, OPTION_ITEMUncheckedCreateInput>
    /**
     * In case the OPTION_ITEM was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<OPTION_ITEMUpdateInput, OPTION_ITEMUncheckedUpdateInput>
  }


  /**
   * OPTION_ITEM delete
   */
  export type OPTION_ITEMDeleteArgs = {
    /**
     * Select specific fields to fetch from the OPTION_ITEM
    **/
    select?: OPTION_ITEMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTION_ITEMInclude | null
    /**
     * Filter which OPTION_ITEM to delete.
    **/
    where: OPTION_ITEMWhereUniqueInput
  }


  /**
   * OPTION_ITEM deleteMany
   */
  export type OPTION_ITEMDeleteManyArgs = {
    where?: OPTION_ITEMWhereInput
  }


  /**
   * OPTION_ITEM without action
   */
  export type OPTION_ITEMArgs = {
    /**
     * Select specific fields to fetch from the OPTION_ITEM
    **/
    select?: OPTION_ITEMSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: OPTION_ITEMInclude | null
  }



  /**
   * Model ORDER
   */


  export type AggregateORDER = {
    count: ORDERCountAggregateOutputType | null
    avg: ORDERAvgAggregateOutputType | null
    sum: ORDERSumAggregateOutputType | null
    min: ORDERMinAggregateOutputType | null
    max: ORDERMaxAggregateOutputType | null
  }

  export type ORDERAvgAggregateOutputType = {
    seq: number
  }

  export type ORDERSumAggregateOutputType = {
    seq: number
  }

  export type ORDERMinAggregateOutputType = {
    seq: number
    createdAt: Date | null
    updatedAt: Date | null
    deliveryTime: Date | null
    status: ORDER_status | null
  }

  export type ORDERMaxAggregateOutputType = {
    seq: number
    createdAt: Date | null
    updatedAt: Date | null
    deliveryTime: Date | null
    status: ORDER_status | null
  }

  export type ORDERCountAggregateOutputType = {
    seq: number
    createdAt: number | null
    updatedAt: number | null
    deliveryTime: number | null
    status: number | null
    _all: number
  }


  export type ORDERAvgAggregateInputType = {
    seq?: true
  }

  export type ORDERSumAggregateInputType = {
    seq?: true
  }

  export type ORDERMinAggregateInputType = {
    seq?: true
    createdAt?: true
    updatedAt?: true
    deliveryTime?: true
    status?: true
  }

  export type ORDERMaxAggregateInputType = {
    seq?: true
    createdAt?: true
    updatedAt?: true
    deliveryTime?: true
    status?: true
  }

  export type ORDERCountAggregateInputType = {
    seq?: true
    createdAt?: true
    updatedAt?: true
    deliveryTime?: true
    status?: true
    _all?: true
  }

  export type ORDERAggregateArgs = {
    /**
     * Filter which ORDER to aggregate.
    **/
    where?: ORDERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ORDERS to fetch.
    **/
    orderBy?: Enumerable<ORDEROrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: ORDERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ORDERS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ORDERS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ORDERS
    **/
    count?: true | ORDERCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: ORDERAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: ORDERSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: ORDERMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: ORDERMaxAggregateInputType
  }

  export type GetORDERAggregateType<T extends ORDERAggregateArgs> = {
    [P in keyof T & keyof AggregateORDER]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateORDER[P]>
      : GetScalarType<T[P], AggregateORDER[P]>
  }


    
    
  export type ORDERGroupByArgs = {
    where?: ORDERWhereInput
    orderBy?: Enumerable<ORDEROrderByInput>
    by: Array<ORDERScalarFieldEnum>
    having?: ORDERScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: ORDERCountAggregateInputType | true
    avg?: ORDERAvgAggregateInputType
    sum?: ORDERSumAggregateInputType
    min?: ORDERMinAggregateInputType
    max?: ORDERMaxAggregateInputType
  }


  export type ORDERGroupByOutputType = {
    seq: number
    createdAt: Date
    updatedAt: Date
    deliveryTime: Date
    status: ORDER_status | null
    count: ORDERCountAggregateOutputType | null
    avg: ORDERAvgAggregateOutputType | null
    sum: ORDERSumAggregateOutputType | null
    min: ORDERMinAggregateOutputType | null
    max: ORDERMaxAggregateOutputType | null
  }

  type GetORDERGroupByPayload<T extends ORDERGroupByArgs> = Promise<Array<
    PickArray<ORDERGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof ORDERGroupByOutputType))]: GetScalarType<T[P], ORDERGroupByOutputType[P]>
    }
  >>
    

  export type ORDERSelect = {
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deliveryTime?: boolean
    status?: boolean
    RES_REVIEW?: boolean | RES_REVIEWArgs
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: boolean | USER_REVIEWArgs
    CALL?: boolean | CALLArgs
    USER?: boolean | USERArgs
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: boolean | USER_REVIEWArgs
  }

  export type ORDERInclude = {
    RES_REVIEW?: boolean | RES_REVIEWArgs
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: boolean | USER_REVIEWArgs
    CALL?: boolean | CALLArgs
    USER?: boolean | USERArgs
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: boolean | USER_REVIEWArgs
  }

  export type ORDERGetPayload<
    S extends boolean | null | undefined | ORDERArgs,
    U = keyof S
      > = S extends true
        ? ORDER
    : S extends undefined
    ? never
    : S extends ORDERArgs | ORDERFindManyArgs
    ?'include' extends U
    ? ORDER  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'RES_REVIEW'
        ? RES_REVIEWGetPayload<S['include'][P]> :
        P extends 'USER_REVIEW_ORDER_seqToUSER_REVIEW'
        ? USER_REVIEWGetPayload<S['include'][P]> :
        P extends 'CALL'
        ? CALLGetPayload<S['include'][P]> :
        P extends 'USER'
        ? USERGetPayload<S['include'][P]> :
        P extends 'USER_REVIEW_ORDERToUSER_REVIEW_seq'
        ? USER_REVIEWGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof ORDER ?ORDER [P]
  : 
          P extends 'RES_REVIEW'
        ? RES_REVIEWGetPayload<S['select'][P]> :
        P extends 'USER_REVIEW_ORDER_seqToUSER_REVIEW'
        ? USER_REVIEWGetPayload<S['select'][P]> :
        P extends 'CALL'
        ? CALLGetPayload<S['select'][P]> :
        P extends 'USER'
        ? USERGetPayload<S['select'][P]> :
        P extends 'USER_REVIEW_ORDERToUSER_REVIEW_seq'
        ? USER_REVIEWGetPayload<S['select'][P]> | null : never
  } 
    : ORDER
  : ORDER


  type ORDERCountArgs = Merge<
    Omit<ORDERFindManyArgs, 'select' | 'include'> & {
      select?: ORDERCountAggregateInputType | true
    }
  >

  export interface ORDERDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one ORDER that matches the filter.
     * @param {ORDERFindUniqueArgs} args - Arguments to find a ORDER
     * @example
     * // Get one ORDER
     * const oRDER = await prisma.oRDER.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ORDERFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ORDERFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ORDER'> extends True ? CheckSelect<T, Prisma__ORDERClient<ORDER>, Prisma__ORDERClient<ORDERGetPayload<T>>> : CheckSelect<T, Prisma__ORDERClient<ORDER | null >, Prisma__ORDERClient<ORDERGetPayload<T> | null >>

    /**
     * Find the first ORDER that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ORDERFindFirstArgs} args - Arguments to find a ORDER
     * @example
     * // Get one ORDER
     * const oRDER = await prisma.oRDER.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ORDERFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ORDERFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ORDER'> extends True ? CheckSelect<T, Prisma__ORDERClient<ORDER>, Prisma__ORDERClient<ORDERGetPayload<T>>> : CheckSelect<T, Prisma__ORDERClient<ORDER | null >, Prisma__ORDERClient<ORDERGetPayload<T> | null >>

    /**
     * Find zero or more ORDERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ORDERFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ORDERS
     * const oRDERS = await prisma.oRDER.findMany()
     * 
     * // Get first 10 ORDERS
     * const oRDERS = await prisma.oRDER.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const oRDERWithSeqOnly = await prisma.oRDER.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends ORDERFindManyArgs>(
      args?: SelectSubset<T, ORDERFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<ORDER>>, PrismaPromise<Array<ORDERGetPayload<T>>>>

    /**
     * Create a ORDER.
     * @param {ORDERCreateArgs} args - Arguments to create a ORDER.
     * @example
     * // Create one ORDER
     * const ORDER = await prisma.oRDER.create({
     *   data: {
     *     // ... data to create a ORDER
     *   }
     * })
     * 
    **/
    create<T extends ORDERCreateArgs>(
      args: SelectSubset<T, ORDERCreateArgs>
    ): CheckSelect<T, Prisma__ORDERClient<ORDER>, Prisma__ORDERClient<ORDERGetPayload<T>>>

    /**
     * Create many ORDERS.
     *     @param {ORDERCreateManyArgs} args - Arguments to create many ORDERS.
     *     @example
     *     // Create many ORDERS
     *     const oRDER = await prisma.oRDER.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ORDERCreateManyArgs>(
      args?: SelectSubset<T, ORDERCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ORDER.
     * @param {ORDERDeleteArgs} args - Arguments to delete one ORDER.
     * @example
     * // Delete one ORDER
     * const ORDER = await prisma.oRDER.delete({
     *   where: {
     *     // ... filter to delete one ORDER
     *   }
     * })
     * 
    **/
    delete<T extends ORDERDeleteArgs>(
      args: SelectSubset<T, ORDERDeleteArgs>
    ): CheckSelect<T, Prisma__ORDERClient<ORDER>, Prisma__ORDERClient<ORDERGetPayload<T>>>

    /**
     * Update one ORDER.
     * @param {ORDERUpdateArgs} args - Arguments to update one ORDER.
     * @example
     * // Update one ORDER
     * const oRDER = await prisma.oRDER.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ORDERUpdateArgs>(
      args: SelectSubset<T, ORDERUpdateArgs>
    ): CheckSelect<T, Prisma__ORDERClient<ORDER>, Prisma__ORDERClient<ORDERGetPayload<T>>>

    /**
     * Delete zero or more ORDERS.
     * @param {ORDERDeleteManyArgs} args - Arguments to filter ORDERS to delete.
     * @example
     * // Delete a few ORDERS
     * const { count } = await prisma.oRDER.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ORDERDeleteManyArgs>(
      args?: SelectSubset<T, ORDERDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ORDERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ORDERUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ORDERS
     * const oRDER = await prisma.oRDER.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ORDERUpdateManyArgs>(
      args: SelectSubset<T, ORDERUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ORDER.
     * @param {ORDERUpsertArgs} args - Arguments to update or create a ORDER.
     * @example
     * // Update or create a ORDER
     * const oRDER = await prisma.oRDER.upsert({
     *   create: {
     *     // ... data to create a ORDER
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ORDER we want to update
     *   }
     * })
    **/
    upsert<T extends ORDERUpsertArgs>(
      args: SelectSubset<T, ORDERUpsertArgs>
    ): CheckSelect<T, Prisma__ORDERClient<ORDER>, Prisma__ORDERClient<ORDERGetPayload<T>>>

    /**
     * Count the number of ORDERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ORDERCountArgs} args - Arguments to filter ORDERS to count.
     * @example
     * // Count the number of ORDERS
     * const count = await prisma.oRDER.count({
     *   where: {
     *     // ... the filter for the ORDERS we want to count
     *   }
     * })
    **/
    count<T extends ORDERCountArgs>(
      args?: Subset<T, ORDERCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ORDERCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ORDER.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ORDERAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ORDERAggregateArgs>(args: Subset<T, ORDERAggregateArgs>): PrismaPromise<GetORDERAggregateType<T>>

    /**
     * Group by ORDER.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ORDERGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ORDERGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ORDERGroupByArgs['orderBy'] }
        : { orderBy?: ORDERGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ORDERGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetORDERGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for ORDER.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ORDERClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RES_REVIEW<T extends RES_REVIEWArgs = {}>(args?: Subset<T, RES_REVIEWArgs>): CheckSelect<T, Prisma__RES_REVIEWClient<RES_REVIEW | null >, Prisma__RES_REVIEWClient<RES_REVIEWGetPayload<T> | null >>;

    USER_REVIEW_ORDER_seqToUSER_REVIEW<T extends USER_REVIEWArgs = {}>(args?: Subset<T, USER_REVIEWArgs>): CheckSelect<T, Prisma__USER_REVIEWClient<USER_REVIEW | null >, Prisma__USER_REVIEWClient<USER_REVIEWGetPayload<T> | null >>;

    CALL<T extends CALLArgs = {}>(args?: Subset<T, CALLArgs>): CheckSelect<T, Prisma__CALLClient<CALL | null >, Prisma__CALLClient<CALLGetPayload<T> | null >>;

    USER<T extends USERArgs = {}>(args?: Subset<T, USERArgs>): CheckSelect<T, Prisma__USERClient<USER | null >, Prisma__USERClient<USERGetPayload<T> | null >>;

    USER_REVIEW_ORDERToUSER_REVIEW_seq<T extends USER_REVIEWArgs = {}>(args?: Subset<T, USER_REVIEWArgs>): CheckSelect<T, Prisma__USER_REVIEWClient<USER_REVIEW | null >, Prisma__USER_REVIEWClient<USER_REVIEWGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * ORDER findUnique
   */
  export type ORDERFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the ORDER
    **/
    select?: ORDERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ORDERInclude | null
    /**
     * Throw an Error if a ORDER can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ORDER to fetch.
    **/
    where: ORDERWhereUniqueInput
  }


  /**
   * ORDER findFirst
   */
  export type ORDERFindFirstArgs = {
    /**
     * Select specific fields to fetch from the ORDER
    **/
    select?: ORDERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ORDERInclude | null
    /**
     * Throw an Error if a ORDER can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which ORDER to fetch.
    **/
    where?: ORDERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ORDERS to fetch.
    **/
    orderBy?: Enumerable<ORDEROrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ORDERS.
    **/
    cursor?: ORDERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ORDERS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ORDERS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ORDERS.
    **/
    distinct?: Enumerable<ORDERScalarFieldEnum>
  }


  /**
   * ORDER findMany
   */
  export type ORDERFindManyArgs = {
    /**
     * Select specific fields to fetch from the ORDER
    **/
    select?: ORDERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ORDERInclude | null
    /**
     * Filter, which ORDERS to fetch.
    **/
    where?: ORDERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ORDERS to fetch.
    **/
    orderBy?: Enumerable<ORDEROrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ORDERS.
    **/
    cursor?: ORDERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ORDERS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ORDERS.
    **/
    skip?: number
    distinct?: Enumerable<ORDERScalarFieldEnum>
  }


  /**
   * ORDER create
   */
  export type ORDERCreateArgs = {
    /**
     * Select specific fields to fetch from the ORDER
    **/
    select?: ORDERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ORDERInclude | null
    /**
     * The data needed to create a ORDER.
    **/
    data: XOR<ORDERCreateInput, ORDERUncheckedCreateInput>
  }


  /**
   * ORDER createMany
   */
  export type ORDERCreateManyArgs = {
    data: Enumerable<ORDERCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ORDER update
   */
  export type ORDERUpdateArgs = {
    /**
     * Select specific fields to fetch from the ORDER
    **/
    select?: ORDERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ORDERInclude | null
    /**
     * The data needed to update a ORDER.
    **/
    data: XOR<ORDERUpdateInput, ORDERUncheckedUpdateInput>
    /**
     * Choose, which ORDER to update.
    **/
    where: ORDERWhereUniqueInput
  }


  /**
   * ORDER updateMany
   */
  export type ORDERUpdateManyArgs = {
    data: XOR<ORDERUpdateManyMutationInput, ORDERUncheckedUpdateManyInput>
    where?: ORDERWhereInput
  }


  /**
   * ORDER upsert
   */
  export type ORDERUpsertArgs = {
    /**
     * Select specific fields to fetch from the ORDER
    **/
    select?: ORDERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ORDERInclude | null
    /**
     * The filter to search for the ORDER to update in case it exists.
    **/
    where: ORDERWhereUniqueInput
    /**
     * In case the ORDER found by the `where` argument doesn't exist, create a new ORDER with this data.
    **/
    create: XOR<ORDERCreateInput, ORDERUncheckedCreateInput>
    /**
     * In case the ORDER was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<ORDERUpdateInput, ORDERUncheckedUpdateInput>
  }


  /**
   * ORDER delete
   */
  export type ORDERDeleteArgs = {
    /**
     * Select specific fields to fetch from the ORDER
    **/
    select?: ORDERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ORDERInclude | null
    /**
     * Filter which ORDER to delete.
    **/
    where: ORDERWhereUniqueInput
  }


  /**
   * ORDER deleteMany
   */
  export type ORDERDeleteManyArgs = {
    where?: ORDERWhereInput
  }


  /**
   * ORDER without action
   */
  export type ORDERArgs = {
    /**
     * Select specific fields to fetch from the ORDER
    **/
    select?: ORDERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: ORDERInclude | null
  }



  /**
   * Model REPLY
   */


  export type AggregateREPLY = {
    count: REPLYCountAggregateOutputType | null
    avg: REPLYAvgAggregateOutputType | null
    sum: REPLYSumAggregateOutputType | null
    min: REPLYMinAggregateOutputType | null
    max: REPLYMaxAggregateOutputType | null
  }

  export type REPLYAvgAggregateOutputType = {
    seq: number
  }

  export type REPLYSumAggregateOutputType = {
    seq: number
  }

  export type REPLYMinAggregateOutputType = {
    seq: number
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type REPLYMaxAggregateOutputType = {
    seq: number
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type REPLYCountAggregateOutputType = {
    seq: number
    content: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type REPLYAvgAggregateInputType = {
    seq?: true
  }

  export type REPLYSumAggregateInputType = {
    seq?: true
  }

  export type REPLYMinAggregateInputType = {
    seq?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type REPLYMaxAggregateInputType = {
    seq?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type REPLYCountAggregateInputType = {
    seq?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type REPLYAggregateArgs = {
    /**
     * Filter which REPLY to aggregate.
    **/
    where?: REPLYWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPLIES to fetch.
    **/
    orderBy?: Enumerable<REPLYOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: REPLYWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPLIES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPLIES.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REPLIES
    **/
    count?: true | REPLYCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: REPLYAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: REPLYSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: REPLYMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: REPLYMaxAggregateInputType
  }

  export type GetREPLYAggregateType<T extends REPLYAggregateArgs> = {
    [P in keyof T & keyof AggregateREPLY]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREPLY[P]>
      : GetScalarType<T[P], AggregateREPLY[P]>
  }


    
    
  export type REPLYGroupByArgs = {
    where?: REPLYWhereInput
    orderBy?: Enumerable<REPLYOrderByInput>
    by: Array<REPLYScalarFieldEnum>
    having?: REPLYScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: REPLYCountAggregateInputType | true
    avg?: REPLYAvgAggregateInputType
    sum?: REPLYSumAggregateInputType
    min?: REPLYMinAggregateInputType
    max?: REPLYMaxAggregateInputType
  }


  export type REPLYGroupByOutputType = {
    seq: number
    content: string
    createdAt: Date
    updatedAt: Date | null
    count: REPLYCountAggregateOutputType | null
    avg: REPLYAvgAggregateOutputType | null
    sum: REPLYSumAggregateOutputType | null
    min: REPLYMinAggregateOutputType | null
    max: REPLYMaxAggregateOutputType | null
  }

  type GetREPLYGroupByPayload<T extends REPLYGroupByArgs> = Promise<Array<
    PickArray<REPLYGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof REPLYGroupByOutputType))]: GetScalarType<T[P], REPLYGroupByOutputType[P]>
    }
  >>
    

  export type REPLYSelect = {
    seq?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    RESTAURANT?: boolean | RESTAURANTArgs
    RES_REVIEW?: boolean | RES_REVIEWArgs
  }

  export type REPLYInclude = {
    RESTAURANT?: boolean | RESTAURANTArgs
    RES_REVIEW?: boolean | RES_REVIEWArgs
  }

  export type REPLYGetPayload<
    S extends boolean | null | undefined | REPLYArgs,
    U = keyof S
      > = S extends true
        ? REPLY
    : S extends undefined
    ? never
    : S extends REPLYArgs | REPLYFindManyArgs
    ?'include' extends U
    ? REPLY  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'RESTAURANT'
        ? RESTAURANTGetPayload<S['include'][P]> :
        P extends 'RES_REVIEW'
        ? RES_REVIEWGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof REPLY ?REPLY [P]
  : 
          P extends 'RESTAURANT'
        ? RESTAURANTGetPayload<S['select'][P]> :
        P extends 'RES_REVIEW'
        ? RES_REVIEWGetPayload<S['select'][P]> | null : never
  } 
    : REPLY
  : REPLY


  type REPLYCountArgs = Merge<
    Omit<REPLYFindManyArgs, 'select' | 'include'> & {
      select?: REPLYCountAggregateInputType | true
    }
  >

  export interface REPLYDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one REPLY that matches the filter.
     * @param {REPLYFindUniqueArgs} args - Arguments to find a REPLY
     * @example
     * // Get one REPLY
     * const rEPLY = await prisma.rEPLY.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REPLYFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REPLYFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REPLY'> extends True ? CheckSelect<T, Prisma__REPLYClient<REPLY>, Prisma__REPLYClient<REPLYGetPayload<T>>> : CheckSelect<T, Prisma__REPLYClient<REPLY | null >, Prisma__REPLYClient<REPLYGetPayload<T> | null >>

    /**
     * Find the first REPLY that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPLYFindFirstArgs} args - Arguments to find a REPLY
     * @example
     * // Get one REPLY
     * const rEPLY = await prisma.rEPLY.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REPLYFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REPLYFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REPLY'> extends True ? CheckSelect<T, Prisma__REPLYClient<REPLY>, Prisma__REPLYClient<REPLYGetPayload<T>>> : CheckSelect<T, Prisma__REPLYClient<REPLY | null >, Prisma__REPLYClient<REPLYGetPayload<T> | null >>

    /**
     * Find zero or more REPLIES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPLYFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REPLIES
     * const rEPLIES = await prisma.rEPLY.findMany()
     * 
     * // Get first 10 REPLIES
     * const rEPLIES = await prisma.rEPLY.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const rEPLYWithSeqOnly = await prisma.rEPLY.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends REPLYFindManyArgs>(
      args?: SelectSubset<T, REPLYFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<REPLY>>, PrismaPromise<Array<REPLYGetPayload<T>>>>

    /**
     * Create a REPLY.
     * @param {REPLYCreateArgs} args - Arguments to create a REPLY.
     * @example
     * // Create one REPLY
     * const REPLY = await prisma.rEPLY.create({
     *   data: {
     *     // ... data to create a REPLY
     *   }
     * })
     * 
    **/
    create<T extends REPLYCreateArgs>(
      args: SelectSubset<T, REPLYCreateArgs>
    ): CheckSelect<T, Prisma__REPLYClient<REPLY>, Prisma__REPLYClient<REPLYGetPayload<T>>>

    /**
     * Create many REPLIES.
     *     @param {REPLYCreateManyArgs} args - Arguments to create many REPLIES.
     *     @example
     *     // Create many REPLIES
     *     const rEPLY = await prisma.rEPLY.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REPLYCreateManyArgs>(
      args?: SelectSubset<T, REPLYCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a REPLY.
     * @param {REPLYDeleteArgs} args - Arguments to delete one REPLY.
     * @example
     * // Delete one REPLY
     * const REPLY = await prisma.rEPLY.delete({
     *   where: {
     *     // ... filter to delete one REPLY
     *   }
     * })
     * 
    **/
    delete<T extends REPLYDeleteArgs>(
      args: SelectSubset<T, REPLYDeleteArgs>
    ): CheckSelect<T, Prisma__REPLYClient<REPLY>, Prisma__REPLYClient<REPLYGetPayload<T>>>

    /**
     * Update one REPLY.
     * @param {REPLYUpdateArgs} args - Arguments to update one REPLY.
     * @example
     * // Update one REPLY
     * const rEPLY = await prisma.rEPLY.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REPLYUpdateArgs>(
      args: SelectSubset<T, REPLYUpdateArgs>
    ): CheckSelect<T, Prisma__REPLYClient<REPLY>, Prisma__REPLYClient<REPLYGetPayload<T>>>

    /**
     * Delete zero or more REPLIES.
     * @param {REPLYDeleteManyArgs} args - Arguments to filter REPLIES to delete.
     * @example
     * // Delete a few REPLIES
     * const { count } = await prisma.rEPLY.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REPLYDeleteManyArgs>(
      args?: SelectSubset<T, REPLYDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more REPLIES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPLYUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REPLIES
     * const rEPLY = await prisma.rEPLY.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REPLYUpdateManyArgs>(
      args: SelectSubset<T, REPLYUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one REPLY.
     * @param {REPLYUpsertArgs} args - Arguments to update or create a REPLY.
     * @example
     * // Update or create a REPLY
     * const rEPLY = await prisma.rEPLY.upsert({
     *   create: {
     *     // ... data to create a REPLY
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REPLY we want to update
     *   }
     * })
    **/
    upsert<T extends REPLYUpsertArgs>(
      args: SelectSubset<T, REPLYUpsertArgs>
    ): CheckSelect<T, Prisma__REPLYClient<REPLY>, Prisma__REPLYClient<REPLYGetPayload<T>>>

    /**
     * Count the number of REPLIES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPLYCountArgs} args - Arguments to filter REPLIES to count.
     * @example
     * // Count the number of REPLIES
     * const count = await prisma.rEPLY.count({
     *   where: {
     *     // ... the filter for the REPLIES we want to count
     *   }
     * })
    **/
    count<T extends REPLYCountArgs>(
      args?: Subset<T, REPLYCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REPLYCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REPLY.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPLYAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REPLYAggregateArgs>(args: Subset<T, REPLYAggregateArgs>): PrismaPromise<GetREPLYAggregateType<T>>

    /**
     * Group by REPLY.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPLYGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REPLYGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REPLYGroupByArgs['orderBy'] }
        : { orderBy?: REPLYGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REPLYGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREPLYGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for REPLY.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REPLYClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RESTAURANT<T extends RESTAURANTArgs = {}>(args?: Subset<T, RESTAURANTArgs>): CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT | null >, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T> | null >>;

    RES_REVIEW<T extends RES_REVIEWArgs = {}>(args?: Subset<T, RES_REVIEWArgs>): CheckSelect<T, Prisma__RES_REVIEWClient<RES_REVIEW | null >, Prisma__RES_REVIEWClient<RES_REVIEWGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * REPLY findUnique
   */
  export type REPLYFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the REPLY
    **/
    select?: REPLYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPLYInclude | null
    /**
     * Throw an Error if a REPLY can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which REPLY to fetch.
    **/
    where: REPLYWhereUniqueInput
  }


  /**
   * REPLY findFirst
   */
  export type REPLYFindFirstArgs = {
    /**
     * Select specific fields to fetch from the REPLY
    **/
    select?: REPLYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPLYInclude | null
    /**
     * Throw an Error if a REPLY can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which REPLY to fetch.
    **/
    where?: REPLYWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPLIES to fetch.
    **/
    orderBy?: Enumerable<REPLYOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPLIES.
    **/
    cursor?: REPLYWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPLIES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPLIES.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPLIES.
    **/
    distinct?: Enumerable<REPLYScalarFieldEnum>
  }


  /**
   * REPLY findMany
   */
  export type REPLYFindManyArgs = {
    /**
     * Select specific fields to fetch from the REPLY
    **/
    select?: REPLYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPLYInclude | null
    /**
     * Filter, which REPLIES to fetch.
    **/
    where?: REPLYWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPLIES to fetch.
    **/
    orderBy?: Enumerable<REPLYOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REPLIES.
    **/
    cursor?: REPLYWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPLIES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPLIES.
    **/
    skip?: number
    distinct?: Enumerable<REPLYScalarFieldEnum>
  }


  /**
   * REPLY create
   */
  export type REPLYCreateArgs = {
    /**
     * Select specific fields to fetch from the REPLY
    **/
    select?: REPLYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPLYInclude | null
    /**
     * The data needed to create a REPLY.
    **/
    data: XOR<REPLYCreateInput, REPLYUncheckedCreateInput>
  }


  /**
   * REPLY createMany
   */
  export type REPLYCreateManyArgs = {
    data: Enumerable<REPLYCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REPLY update
   */
  export type REPLYUpdateArgs = {
    /**
     * Select specific fields to fetch from the REPLY
    **/
    select?: REPLYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPLYInclude | null
    /**
     * The data needed to update a REPLY.
    **/
    data: XOR<REPLYUpdateInput, REPLYUncheckedUpdateInput>
    /**
     * Choose, which REPLY to update.
    **/
    where: REPLYWhereUniqueInput
  }


  /**
   * REPLY updateMany
   */
  export type REPLYUpdateManyArgs = {
    data: XOR<REPLYUpdateManyMutationInput, REPLYUncheckedUpdateManyInput>
    where?: REPLYWhereInput
  }


  /**
   * REPLY upsert
   */
  export type REPLYUpsertArgs = {
    /**
     * Select specific fields to fetch from the REPLY
    **/
    select?: REPLYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPLYInclude | null
    /**
     * The filter to search for the REPLY to update in case it exists.
    **/
    where: REPLYWhereUniqueInput
    /**
     * In case the REPLY found by the `where` argument doesn't exist, create a new REPLY with this data.
    **/
    create: XOR<REPLYCreateInput, REPLYUncheckedCreateInput>
    /**
     * In case the REPLY was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<REPLYUpdateInput, REPLYUncheckedUpdateInput>
  }


  /**
   * REPLY delete
   */
  export type REPLYDeleteArgs = {
    /**
     * Select specific fields to fetch from the REPLY
    **/
    select?: REPLYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPLYInclude | null
    /**
     * Filter which REPLY to delete.
    **/
    where: REPLYWhereUniqueInput
  }


  /**
   * REPLY deleteMany
   */
  export type REPLYDeleteManyArgs = {
    where?: REPLYWhereInput
  }


  /**
   * REPLY without action
   */
  export type REPLYArgs = {
    /**
     * Select specific fields to fetch from the REPLY
    **/
    select?: REPLYSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPLYInclude | null
  }



  /**
   * Model REPORT
   */


  export type AggregateREPORT = {
    count: REPORTCountAggregateOutputType | null
    avg: REPORTAvgAggregateOutputType | null
    sum: REPORTSumAggregateOutputType | null
    min: REPORTMinAggregateOutputType | null
    max: REPORTMaxAggregateOutputType | null
  }

  export type REPORTAvgAggregateOutputType = {
    seq: number
  }

  export type REPORTSumAggregateOutputType = {
    seq: number
  }

  export type REPORTMinAggregateOutputType = {
    seq: number
    reason: string | null
    isSolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type REPORTMaxAggregateOutputType = {
    seq: number
    reason: string | null
    isSolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type REPORTCountAggregateOutputType = {
    seq: number
    reason: number | null
    isSolved: number | null
    createdAt: number | null
    updatedAt: number | null
    _all: number
  }


  export type REPORTAvgAggregateInputType = {
    seq?: true
  }

  export type REPORTSumAggregateInputType = {
    seq?: true
  }

  export type REPORTMinAggregateInputType = {
    seq?: true
    reason?: true
    isSolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type REPORTMaxAggregateInputType = {
    seq?: true
    reason?: true
    isSolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type REPORTCountAggregateInputType = {
    seq?: true
    reason?: true
    isSolved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type REPORTAggregateArgs = {
    /**
     * Filter which REPORT to aggregate.
    **/
    where?: REPORTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPORTS to fetch.
    **/
    orderBy?: Enumerable<REPORTOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: REPORTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPORTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPORTS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned REPORTS
    **/
    count?: true | REPORTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: REPORTAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: REPORTSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: REPORTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: REPORTMaxAggregateInputType
  }

  export type GetREPORTAggregateType<T extends REPORTAggregateArgs> = {
    [P in keyof T & keyof AggregateREPORT]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateREPORT[P]>
      : GetScalarType<T[P], AggregateREPORT[P]>
  }


    
    
  export type REPORTGroupByArgs = {
    where?: REPORTWhereInput
    orderBy?: Enumerable<REPORTOrderByInput>
    by: Array<REPORTScalarFieldEnum>
    having?: REPORTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: REPORTCountAggregateInputType | true
    avg?: REPORTAvgAggregateInputType
    sum?: REPORTSumAggregateInputType
    min?: REPORTMinAggregateInputType
    max?: REPORTMaxAggregateInputType
  }


  export type REPORTGroupByOutputType = {
    seq: number
    reason: string
    isSolved: boolean
    createdAt: Date
    updatedAt: Date | null
    count: REPORTCountAggregateOutputType | null
    avg: REPORTAvgAggregateOutputType | null
    sum: REPORTSumAggregateOutputType | null
    min: REPORTMinAggregateOutputType | null
    max: REPORTMaxAggregateOutputType | null
  }

  type GetREPORTGroupByPayload<T extends REPORTGroupByArgs> = Promise<Array<
    PickArray<REPORTGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof REPORTGroupByOutputType))]: GetScalarType<T[P], REPORTGroupByOutputType[P]>
    }
  >>
    

  export type REPORTSelect = {
    seq?: boolean
    reason?: boolean
    isSolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    USER?: boolean | USERArgs
  }

  export type REPORTInclude = {
    USER?: boolean | USERArgs
  }

  export type REPORTGetPayload<
    S extends boolean | null | undefined | REPORTArgs,
    U = keyof S
      > = S extends true
        ? REPORT
    : S extends undefined
    ? never
    : S extends REPORTArgs | REPORTFindManyArgs
    ?'include' extends U
    ? REPORT  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'USER'
        ? USERGetPayload<S['include'][P]> : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof REPORT ?REPORT [P]
  : 
          P extends 'USER'
        ? USERGetPayload<S['select'][P]> : never
  } 
    : REPORT
  : REPORT


  type REPORTCountArgs = Merge<
    Omit<REPORTFindManyArgs, 'select' | 'include'> & {
      select?: REPORTCountAggregateInputType | true
    }
  >

  export interface REPORTDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one REPORT that matches the filter.
     * @param {REPORTFindUniqueArgs} args - Arguments to find a REPORT
     * @example
     * // Get one REPORT
     * const rEPORT = await prisma.rEPORT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends REPORTFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, REPORTFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'REPORT'> extends True ? CheckSelect<T, Prisma__REPORTClient<REPORT>, Prisma__REPORTClient<REPORTGetPayload<T>>> : CheckSelect<T, Prisma__REPORTClient<REPORT | null >, Prisma__REPORTClient<REPORTGetPayload<T> | null >>

    /**
     * Find the first REPORT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPORTFindFirstArgs} args - Arguments to find a REPORT
     * @example
     * // Get one REPORT
     * const rEPORT = await prisma.rEPORT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends REPORTFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, REPORTFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'REPORT'> extends True ? CheckSelect<T, Prisma__REPORTClient<REPORT>, Prisma__REPORTClient<REPORTGetPayload<T>>> : CheckSelect<T, Prisma__REPORTClient<REPORT | null >, Prisma__REPORTClient<REPORTGetPayload<T> | null >>

    /**
     * Find zero or more REPORTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPORTFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all REPORTS
     * const rEPORTS = await prisma.rEPORT.findMany()
     * 
     * // Get first 10 REPORTS
     * const rEPORTS = await prisma.rEPORT.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const rEPORTWithSeqOnly = await prisma.rEPORT.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends REPORTFindManyArgs>(
      args?: SelectSubset<T, REPORTFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<REPORT>>, PrismaPromise<Array<REPORTGetPayload<T>>>>

    /**
     * Create a REPORT.
     * @param {REPORTCreateArgs} args - Arguments to create a REPORT.
     * @example
     * // Create one REPORT
     * const REPORT = await prisma.rEPORT.create({
     *   data: {
     *     // ... data to create a REPORT
     *   }
     * })
     * 
    **/
    create<T extends REPORTCreateArgs>(
      args: SelectSubset<T, REPORTCreateArgs>
    ): CheckSelect<T, Prisma__REPORTClient<REPORT>, Prisma__REPORTClient<REPORTGetPayload<T>>>

    /**
     * Create many REPORTS.
     *     @param {REPORTCreateManyArgs} args - Arguments to create many REPORTS.
     *     @example
     *     // Create many REPORTS
     *     const rEPORT = await prisma.rEPORT.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends REPORTCreateManyArgs>(
      args?: SelectSubset<T, REPORTCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a REPORT.
     * @param {REPORTDeleteArgs} args - Arguments to delete one REPORT.
     * @example
     * // Delete one REPORT
     * const REPORT = await prisma.rEPORT.delete({
     *   where: {
     *     // ... filter to delete one REPORT
     *   }
     * })
     * 
    **/
    delete<T extends REPORTDeleteArgs>(
      args: SelectSubset<T, REPORTDeleteArgs>
    ): CheckSelect<T, Prisma__REPORTClient<REPORT>, Prisma__REPORTClient<REPORTGetPayload<T>>>

    /**
     * Update one REPORT.
     * @param {REPORTUpdateArgs} args - Arguments to update one REPORT.
     * @example
     * // Update one REPORT
     * const rEPORT = await prisma.rEPORT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends REPORTUpdateArgs>(
      args: SelectSubset<T, REPORTUpdateArgs>
    ): CheckSelect<T, Prisma__REPORTClient<REPORT>, Prisma__REPORTClient<REPORTGetPayload<T>>>

    /**
     * Delete zero or more REPORTS.
     * @param {REPORTDeleteManyArgs} args - Arguments to filter REPORTS to delete.
     * @example
     * // Delete a few REPORTS
     * const { count } = await prisma.rEPORT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends REPORTDeleteManyArgs>(
      args?: SelectSubset<T, REPORTDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more REPORTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPORTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many REPORTS
     * const rEPORT = await prisma.rEPORT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends REPORTUpdateManyArgs>(
      args: SelectSubset<T, REPORTUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one REPORT.
     * @param {REPORTUpsertArgs} args - Arguments to update or create a REPORT.
     * @example
     * // Update or create a REPORT
     * const rEPORT = await prisma.rEPORT.upsert({
     *   create: {
     *     // ... data to create a REPORT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the REPORT we want to update
     *   }
     * })
    **/
    upsert<T extends REPORTUpsertArgs>(
      args: SelectSubset<T, REPORTUpsertArgs>
    ): CheckSelect<T, Prisma__REPORTClient<REPORT>, Prisma__REPORTClient<REPORTGetPayload<T>>>

    /**
     * Count the number of REPORTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPORTCountArgs} args - Arguments to filter REPORTS to count.
     * @example
     * // Count the number of REPORTS
     * const count = await prisma.rEPORT.count({
     *   where: {
     *     // ... the filter for the REPORTS we want to count
     *   }
     * })
    **/
    count<T extends REPORTCountArgs>(
      args?: Subset<T, REPORTCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], REPORTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a REPORT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPORTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends REPORTAggregateArgs>(args: Subset<T, REPORTAggregateArgs>): PrismaPromise<GetREPORTAggregateType<T>>

    /**
     * Group by REPORT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {REPORTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends REPORTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: REPORTGroupByArgs['orderBy'] }
        : { orderBy?: REPORTGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, REPORTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetREPORTGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for REPORT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__REPORTClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    USER<T extends USERArgs = {}>(args?: Subset<T, USERArgs>): CheckSelect<T, Prisma__USERClient<USER | null >, Prisma__USERClient<USERGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * REPORT findUnique
   */
  export type REPORTFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the REPORT
    **/
    select?: REPORTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPORTInclude | null
    /**
     * Throw an Error if a REPORT can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which REPORT to fetch.
    **/
    where: REPORTWhereUniqueInput
  }


  /**
   * REPORT findFirst
   */
  export type REPORTFindFirstArgs = {
    /**
     * Select specific fields to fetch from the REPORT
    **/
    select?: REPORTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPORTInclude | null
    /**
     * Throw an Error if a REPORT can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which REPORT to fetch.
    **/
    where?: REPORTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPORTS to fetch.
    **/
    orderBy?: Enumerable<REPORTOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for REPORTS.
    **/
    cursor?: REPORTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPORTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPORTS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of REPORTS.
    **/
    distinct?: Enumerable<REPORTScalarFieldEnum>
  }


  /**
   * REPORT findMany
   */
  export type REPORTFindManyArgs = {
    /**
     * Select specific fields to fetch from the REPORT
    **/
    select?: REPORTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPORTInclude | null
    /**
     * Filter, which REPORTS to fetch.
    **/
    where?: REPORTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of REPORTS to fetch.
    **/
    orderBy?: Enumerable<REPORTOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing REPORTS.
    **/
    cursor?: REPORTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` REPORTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` REPORTS.
    **/
    skip?: number
    distinct?: Enumerable<REPORTScalarFieldEnum>
  }


  /**
   * REPORT create
   */
  export type REPORTCreateArgs = {
    /**
     * Select specific fields to fetch from the REPORT
    **/
    select?: REPORTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPORTInclude | null
    /**
     * The data needed to create a REPORT.
    **/
    data: XOR<REPORTCreateInput, REPORTUncheckedCreateInput>
  }


  /**
   * REPORT createMany
   */
  export type REPORTCreateManyArgs = {
    data: Enumerable<REPORTCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * REPORT update
   */
  export type REPORTUpdateArgs = {
    /**
     * Select specific fields to fetch from the REPORT
    **/
    select?: REPORTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPORTInclude | null
    /**
     * The data needed to update a REPORT.
    **/
    data: XOR<REPORTUpdateInput, REPORTUncheckedUpdateInput>
    /**
     * Choose, which REPORT to update.
    **/
    where: REPORTWhereUniqueInput
  }


  /**
   * REPORT updateMany
   */
  export type REPORTUpdateManyArgs = {
    data: XOR<REPORTUpdateManyMutationInput, REPORTUncheckedUpdateManyInput>
    where?: REPORTWhereInput
  }


  /**
   * REPORT upsert
   */
  export type REPORTUpsertArgs = {
    /**
     * Select specific fields to fetch from the REPORT
    **/
    select?: REPORTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPORTInclude | null
    /**
     * The filter to search for the REPORT to update in case it exists.
    **/
    where: REPORTWhereUniqueInput
    /**
     * In case the REPORT found by the `where` argument doesn't exist, create a new REPORT with this data.
    **/
    create: XOR<REPORTCreateInput, REPORTUncheckedCreateInput>
    /**
     * In case the REPORT was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<REPORTUpdateInput, REPORTUncheckedUpdateInput>
  }


  /**
   * REPORT delete
   */
  export type REPORTDeleteArgs = {
    /**
     * Select specific fields to fetch from the REPORT
    **/
    select?: REPORTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPORTInclude | null
    /**
     * Filter which REPORT to delete.
    **/
    where: REPORTWhereUniqueInput
  }


  /**
   * REPORT deleteMany
   */
  export type REPORTDeleteManyArgs = {
    where?: REPORTWhereInput
  }


  /**
   * REPORT without action
   */
  export type REPORTArgs = {
    /**
     * Select specific fields to fetch from the REPORT
    **/
    select?: REPORTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: REPORTInclude | null
  }



  /**
   * Model RES_REVIEW
   */


  export type AggregateRES_REVIEW = {
    count: RES_REVIEWCountAggregateOutputType | null
    avg: RES_REVIEWAvgAggregateOutputType | null
    sum: RES_REVIEWSumAggregateOutputType | null
    min: RES_REVIEWMinAggregateOutputType | null
    max: RES_REVIEWMaxAggregateOutputType | null
  }

  export type RES_REVIEWAvgAggregateOutputType = {
    seq: number
    rate: number
  }

  export type RES_REVIEWSumAggregateOutputType = {
    seq: number
    rate: number
  }

  export type RES_REVIEWMinAggregateOutputType = {
    seq: number
    createdAt: Date | null
    updatedAt: Date | null
    rate: number
    content: string | null
    image: string | null
  }

  export type RES_REVIEWMaxAggregateOutputType = {
    seq: number
    createdAt: Date | null
    updatedAt: Date | null
    rate: number
    content: string | null
    image: string | null
  }

  export type RES_REVIEWCountAggregateOutputType = {
    seq: number
    createdAt: number | null
    updatedAt: number | null
    rate: number
    content: number | null
    image: number | null
    _all: number
  }


  export type RES_REVIEWAvgAggregateInputType = {
    seq?: true
    rate?: true
  }

  export type RES_REVIEWSumAggregateInputType = {
    seq?: true
    rate?: true
  }

  export type RES_REVIEWMinAggregateInputType = {
    seq?: true
    createdAt?: true
    updatedAt?: true
    rate?: true
    content?: true
    image?: true
  }

  export type RES_REVIEWMaxAggregateInputType = {
    seq?: true
    createdAt?: true
    updatedAt?: true
    rate?: true
    content?: true
    image?: true
  }

  export type RES_REVIEWCountAggregateInputType = {
    seq?: true
    createdAt?: true
    updatedAt?: true
    rate?: true
    content?: true
    image?: true
    _all?: true
  }

  export type RES_REVIEWAggregateArgs = {
    /**
     * Filter which RES_REVIEW to aggregate.
    **/
    where?: RES_REVIEWWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RES_REVIEWS to fetch.
    **/
    orderBy?: Enumerable<RES_REVIEWOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: RES_REVIEWWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RES_REVIEWS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RES_REVIEWS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RES_REVIEWS
    **/
    count?: true | RES_REVIEWCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: RES_REVIEWAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: RES_REVIEWSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: RES_REVIEWMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: RES_REVIEWMaxAggregateInputType
  }

  export type GetRES_REVIEWAggregateType<T extends RES_REVIEWAggregateArgs> = {
    [P in keyof T & keyof AggregateRES_REVIEW]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRES_REVIEW[P]>
      : GetScalarType<T[P], AggregateRES_REVIEW[P]>
  }


    
    
  export type RES_REVIEWGroupByArgs = {
    where?: RES_REVIEWWhereInput
    orderBy?: Enumerable<RES_REVIEWOrderByInput>
    by: Array<RES_REVIEWScalarFieldEnum>
    having?: RES_REVIEWScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: RES_REVIEWCountAggregateInputType | true
    avg?: RES_REVIEWAvgAggregateInputType
    sum?: RES_REVIEWSumAggregateInputType
    min?: RES_REVIEWMinAggregateInputType
    max?: RES_REVIEWMaxAggregateInputType
  }


  export type RES_REVIEWGroupByOutputType = {
    seq: number
    createdAt: Date
    updatedAt: Date | null
    rate: number
    content: string
    image: string | null
    count: RES_REVIEWCountAggregateOutputType | null
    avg: RES_REVIEWAvgAggregateOutputType | null
    sum: RES_REVIEWSumAggregateOutputType | null
    min: RES_REVIEWMinAggregateOutputType | null
    max: RES_REVIEWMaxAggregateOutputType | null
  }

  type GetRES_REVIEWGroupByPayload<T extends RES_REVIEWGroupByArgs> = Promise<Array<
    PickArray<RES_REVIEWGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof RES_REVIEWGroupByOutputType))]: GetScalarType<T[P], RES_REVIEWGroupByOutputType[P]>
    }
  >>
    

  export type RES_REVIEWSelect = {
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rate?: boolean
    content?: boolean
    image?: boolean
    RESTAURANT?: boolean | RESTAURANTArgs
    REPLY?: boolean | REPLYArgs
    USER?: boolean | USERArgs
    ORDER?: boolean | ORDERArgs
  }

  export type RES_REVIEWInclude = {
    RESTAURANT?: boolean | RESTAURANTArgs
    REPLY?: boolean | REPLYArgs
    USER?: boolean | USERArgs
    ORDER?: boolean | ORDERArgs
  }

  export type RES_REVIEWGetPayload<
    S extends boolean | null | undefined | RES_REVIEWArgs,
    U = keyof S
      > = S extends true
        ? RES_REVIEW
    : S extends undefined
    ? never
    : S extends RES_REVIEWArgs | RES_REVIEWFindManyArgs
    ?'include' extends U
    ? RES_REVIEW  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'RESTAURANT'
        ? RESTAURANTGetPayload<S['include'][P]> :
        P extends 'REPLY'
        ? REPLYGetPayload<S['include'][P]> :
        P extends 'USER'
        ? USERGetPayload<S['include'][P]> :
        P extends 'ORDER'
        ? ORDERGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RES_REVIEW ?RES_REVIEW [P]
  : 
          P extends 'RESTAURANT'
        ? RESTAURANTGetPayload<S['select'][P]> :
        P extends 'REPLY'
        ? REPLYGetPayload<S['select'][P]> :
        P extends 'USER'
        ? USERGetPayload<S['select'][P]> :
        P extends 'ORDER'
        ? ORDERGetPayload<S['select'][P]> | null : never
  } 
    : RES_REVIEW
  : RES_REVIEW


  type RES_REVIEWCountArgs = Merge<
    Omit<RES_REVIEWFindManyArgs, 'select' | 'include'> & {
      select?: RES_REVIEWCountAggregateInputType | true
    }
  >

  export interface RES_REVIEWDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RES_REVIEW that matches the filter.
     * @param {RES_REVIEWFindUniqueArgs} args - Arguments to find a RES_REVIEW
     * @example
     * // Get one RES_REVIEW
     * const rES_REVIEW = await prisma.rES_REVIEW.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RES_REVIEWFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RES_REVIEWFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RES_REVIEW'> extends True ? CheckSelect<T, Prisma__RES_REVIEWClient<RES_REVIEW>, Prisma__RES_REVIEWClient<RES_REVIEWGetPayload<T>>> : CheckSelect<T, Prisma__RES_REVIEWClient<RES_REVIEW | null >, Prisma__RES_REVIEWClient<RES_REVIEWGetPayload<T> | null >>

    /**
     * Find the first RES_REVIEW that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RES_REVIEWFindFirstArgs} args - Arguments to find a RES_REVIEW
     * @example
     * // Get one RES_REVIEW
     * const rES_REVIEW = await prisma.rES_REVIEW.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RES_REVIEWFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RES_REVIEWFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RES_REVIEW'> extends True ? CheckSelect<T, Prisma__RES_REVIEWClient<RES_REVIEW>, Prisma__RES_REVIEWClient<RES_REVIEWGetPayload<T>>> : CheckSelect<T, Prisma__RES_REVIEWClient<RES_REVIEW | null >, Prisma__RES_REVIEWClient<RES_REVIEWGetPayload<T> | null >>

    /**
     * Find zero or more RES_REVIEWS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RES_REVIEWFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RES_REVIEWS
     * const rES_REVIEWS = await prisma.rES_REVIEW.findMany()
     * 
     * // Get first 10 RES_REVIEWS
     * const rES_REVIEWS = await prisma.rES_REVIEW.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const rES_REVIEWWithSeqOnly = await prisma.rES_REVIEW.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends RES_REVIEWFindManyArgs>(
      args?: SelectSubset<T, RES_REVIEWFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RES_REVIEW>>, PrismaPromise<Array<RES_REVIEWGetPayload<T>>>>

    /**
     * Create a RES_REVIEW.
     * @param {RES_REVIEWCreateArgs} args - Arguments to create a RES_REVIEW.
     * @example
     * // Create one RES_REVIEW
     * const RES_REVIEW = await prisma.rES_REVIEW.create({
     *   data: {
     *     // ... data to create a RES_REVIEW
     *   }
     * })
     * 
    **/
    create<T extends RES_REVIEWCreateArgs>(
      args: SelectSubset<T, RES_REVIEWCreateArgs>
    ): CheckSelect<T, Prisma__RES_REVIEWClient<RES_REVIEW>, Prisma__RES_REVIEWClient<RES_REVIEWGetPayload<T>>>

    /**
     * Create many RES_REVIEWS.
     *     @param {RES_REVIEWCreateManyArgs} args - Arguments to create many RES_REVIEWS.
     *     @example
     *     // Create many RES_REVIEWS
     *     const rES_REVIEW = await prisma.rES_REVIEW.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RES_REVIEWCreateManyArgs>(
      args?: SelectSubset<T, RES_REVIEWCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RES_REVIEW.
     * @param {RES_REVIEWDeleteArgs} args - Arguments to delete one RES_REVIEW.
     * @example
     * // Delete one RES_REVIEW
     * const RES_REVIEW = await prisma.rES_REVIEW.delete({
     *   where: {
     *     // ... filter to delete one RES_REVIEW
     *   }
     * })
     * 
    **/
    delete<T extends RES_REVIEWDeleteArgs>(
      args: SelectSubset<T, RES_REVIEWDeleteArgs>
    ): CheckSelect<T, Prisma__RES_REVIEWClient<RES_REVIEW>, Prisma__RES_REVIEWClient<RES_REVIEWGetPayload<T>>>

    /**
     * Update one RES_REVIEW.
     * @param {RES_REVIEWUpdateArgs} args - Arguments to update one RES_REVIEW.
     * @example
     * // Update one RES_REVIEW
     * const rES_REVIEW = await prisma.rES_REVIEW.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RES_REVIEWUpdateArgs>(
      args: SelectSubset<T, RES_REVIEWUpdateArgs>
    ): CheckSelect<T, Prisma__RES_REVIEWClient<RES_REVIEW>, Prisma__RES_REVIEWClient<RES_REVIEWGetPayload<T>>>

    /**
     * Delete zero or more RES_REVIEWS.
     * @param {RES_REVIEWDeleteManyArgs} args - Arguments to filter RES_REVIEWS to delete.
     * @example
     * // Delete a few RES_REVIEWS
     * const { count } = await prisma.rES_REVIEW.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RES_REVIEWDeleteManyArgs>(
      args?: SelectSubset<T, RES_REVIEWDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RES_REVIEWS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RES_REVIEWUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RES_REVIEWS
     * const rES_REVIEW = await prisma.rES_REVIEW.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RES_REVIEWUpdateManyArgs>(
      args: SelectSubset<T, RES_REVIEWUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RES_REVIEW.
     * @param {RES_REVIEWUpsertArgs} args - Arguments to update or create a RES_REVIEW.
     * @example
     * // Update or create a RES_REVIEW
     * const rES_REVIEW = await prisma.rES_REVIEW.upsert({
     *   create: {
     *     // ... data to create a RES_REVIEW
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RES_REVIEW we want to update
     *   }
     * })
    **/
    upsert<T extends RES_REVIEWUpsertArgs>(
      args: SelectSubset<T, RES_REVIEWUpsertArgs>
    ): CheckSelect<T, Prisma__RES_REVIEWClient<RES_REVIEW>, Prisma__RES_REVIEWClient<RES_REVIEWGetPayload<T>>>

    /**
     * Count the number of RES_REVIEWS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RES_REVIEWCountArgs} args - Arguments to filter RES_REVIEWS to count.
     * @example
     * // Count the number of RES_REVIEWS
     * const count = await prisma.rES_REVIEW.count({
     *   where: {
     *     // ... the filter for the RES_REVIEWS we want to count
     *   }
     * })
    **/
    count<T extends RES_REVIEWCountArgs>(
      args?: Subset<T, RES_REVIEWCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RES_REVIEWCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RES_REVIEW.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RES_REVIEWAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RES_REVIEWAggregateArgs>(args: Subset<T, RES_REVIEWAggregateArgs>): PrismaPromise<GetRES_REVIEWAggregateType<T>>

    /**
     * Group by RES_REVIEW.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RES_REVIEWGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RES_REVIEWGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RES_REVIEWGroupByArgs['orderBy'] }
        : { orderBy?: RES_REVIEWGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RES_REVIEWGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRES_REVIEWGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RES_REVIEW.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RES_REVIEWClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RESTAURANT<T extends RESTAURANTArgs = {}>(args?: Subset<T, RESTAURANTArgs>): CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT | null >, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T> | null >>;

    REPLY<T extends REPLYArgs = {}>(args?: Subset<T, REPLYArgs>): CheckSelect<T, Prisma__REPLYClient<REPLY | null >, Prisma__REPLYClient<REPLYGetPayload<T> | null >>;

    USER<T extends USERArgs = {}>(args?: Subset<T, USERArgs>): CheckSelect<T, Prisma__USERClient<USER | null >, Prisma__USERClient<USERGetPayload<T> | null >>;

    ORDER<T extends ORDERArgs = {}>(args?: Subset<T, ORDERArgs>): CheckSelect<T, Prisma__ORDERClient<ORDER | null >, Prisma__ORDERClient<ORDERGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RES_REVIEW findUnique
   */
  export type RES_REVIEWFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RES_REVIEW
    **/
    select?: RES_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RES_REVIEWInclude | null
    /**
     * Throw an Error if a RES_REVIEW can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RES_REVIEW to fetch.
    **/
    where: RES_REVIEWWhereUniqueInput
  }


  /**
   * RES_REVIEW findFirst
   */
  export type RES_REVIEWFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RES_REVIEW
    **/
    select?: RES_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RES_REVIEWInclude | null
    /**
     * Throw an Error if a RES_REVIEW can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RES_REVIEW to fetch.
    **/
    where?: RES_REVIEWWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RES_REVIEWS to fetch.
    **/
    orderBy?: Enumerable<RES_REVIEWOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RES_REVIEWS.
    **/
    cursor?: RES_REVIEWWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RES_REVIEWS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RES_REVIEWS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RES_REVIEWS.
    **/
    distinct?: Enumerable<RES_REVIEWScalarFieldEnum>
  }


  /**
   * RES_REVIEW findMany
   */
  export type RES_REVIEWFindManyArgs = {
    /**
     * Select specific fields to fetch from the RES_REVIEW
    **/
    select?: RES_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RES_REVIEWInclude | null
    /**
     * Filter, which RES_REVIEWS to fetch.
    **/
    where?: RES_REVIEWWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RES_REVIEWS to fetch.
    **/
    orderBy?: Enumerable<RES_REVIEWOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RES_REVIEWS.
    **/
    cursor?: RES_REVIEWWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RES_REVIEWS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RES_REVIEWS.
    **/
    skip?: number
    distinct?: Enumerable<RES_REVIEWScalarFieldEnum>
  }


  /**
   * RES_REVIEW create
   */
  export type RES_REVIEWCreateArgs = {
    /**
     * Select specific fields to fetch from the RES_REVIEW
    **/
    select?: RES_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RES_REVIEWInclude | null
    /**
     * The data needed to create a RES_REVIEW.
    **/
    data: XOR<RES_REVIEWCreateInput, RES_REVIEWUncheckedCreateInput>
  }


  /**
   * RES_REVIEW createMany
   */
  export type RES_REVIEWCreateManyArgs = {
    data: Enumerable<RES_REVIEWCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RES_REVIEW update
   */
  export type RES_REVIEWUpdateArgs = {
    /**
     * Select specific fields to fetch from the RES_REVIEW
    **/
    select?: RES_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RES_REVIEWInclude | null
    /**
     * The data needed to update a RES_REVIEW.
    **/
    data: XOR<RES_REVIEWUpdateInput, RES_REVIEWUncheckedUpdateInput>
    /**
     * Choose, which RES_REVIEW to update.
    **/
    where: RES_REVIEWWhereUniqueInput
  }


  /**
   * RES_REVIEW updateMany
   */
  export type RES_REVIEWUpdateManyArgs = {
    data: XOR<RES_REVIEWUpdateManyMutationInput, RES_REVIEWUncheckedUpdateManyInput>
    where?: RES_REVIEWWhereInput
  }


  /**
   * RES_REVIEW upsert
   */
  export type RES_REVIEWUpsertArgs = {
    /**
     * Select specific fields to fetch from the RES_REVIEW
    **/
    select?: RES_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RES_REVIEWInclude | null
    /**
     * The filter to search for the RES_REVIEW to update in case it exists.
    **/
    where: RES_REVIEWWhereUniqueInput
    /**
     * In case the RES_REVIEW found by the `where` argument doesn't exist, create a new RES_REVIEW with this data.
    **/
    create: XOR<RES_REVIEWCreateInput, RES_REVIEWUncheckedCreateInput>
    /**
     * In case the RES_REVIEW was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<RES_REVIEWUpdateInput, RES_REVIEWUncheckedUpdateInput>
  }


  /**
   * RES_REVIEW delete
   */
  export type RES_REVIEWDeleteArgs = {
    /**
     * Select specific fields to fetch from the RES_REVIEW
    **/
    select?: RES_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RES_REVIEWInclude | null
    /**
     * Filter which RES_REVIEW to delete.
    **/
    where: RES_REVIEWWhereUniqueInput
  }


  /**
   * RES_REVIEW deleteMany
   */
  export type RES_REVIEWDeleteManyArgs = {
    where?: RES_REVIEWWhereInput
  }


  /**
   * RES_REVIEW without action
   */
  export type RES_REVIEWArgs = {
    /**
     * Select specific fields to fetch from the RES_REVIEW
    **/
    select?: RES_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RES_REVIEWInclude | null
  }



  /**
   * Model RESTAURANT
   */


  export type AggregateRESTAURANT = {
    count: RESTAURANTCountAggregateOutputType | null
    avg: RESTAURANTAvgAggregateOutputType | null
    sum: RESTAURANTSumAggregateOutputType | null
    min: RESTAURANTMinAggregateOutputType | null
    max: RESTAURANTMaxAggregateOutputType | null
  }

  export type RESTAURANTAvgAggregateOutputType = {
    seq: number
    minOrder: number
    deliveryTip: number
    rate: number
  }

  export type RESTAURANTSumAggregateOutputType = {
    seq: number
    minOrder: number
    deliveryTip: number
    rate: number
  }

  export type RESTAURANTMinAggregateOutputType = {
    seq: number
    id: string | null
    password: string | null
    createdAt: Date | null
    dayoff: string | null
    isOpen: boolean | null
    minOrder: number
    deliveryTip: number
    seperatable: boolean | null
    introduction: string | null
    thumbnail: string | null
    rate: number
    category: string | null
  }

  export type RESTAURANTMaxAggregateOutputType = {
    seq: number
    id: string | null
    password: string | null
    createdAt: Date | null
    dayoff: string | null
    isOpen: boolean | null
    minOrder: number
    deliveryTip: number
    seperatable: boolean | null
    introduction: string | null
    thumbnail: string | null
    rate: number
    category: string | null
  }

  export type RESTAURANTCountAggregateOutputType = {
    seq: number
    id: number | null
    password: number | null
    createdAt: number | null
    dayoff: number | null
    isOpen: number | null
    minOrder: number
    deliveryTip: number
    seperatable: number | null
    introduction: number | null
    thumbnail: number | null
    rate: number
    category: number | null
    _all: number
  }


  export type RESTAURANTAvgAggregateInputType = {
    seq?: true
    minOrder?: true
    deliveryTip?: true
    rate?: true
  }

  export type RESTAURANTSumAggregateInputType = {
    seq?: true
    minOrder?: true
    deliveryTip?: true
    rate?: true
  }

  export type RESTAURANTMinAggregateInputType = {
    seq?: true
    id?: true
    password?: true
    createdAt?: true
    dayoff?: true
    isOpen?: true
    minOrder?: true
    deliveryTip?: true
    seperatable?: true
    introduction?: true
    thumbnail?: true
    rate?: true
    category?: true
  }

  export type RESTAURANTMaxAggregateInputType = {
    seq?: true
    id?: true
    password?: true
    createdAt?: true
    dayoff?: true
    isOpen?: true
    minOrder?: true
    deliveryTip?: true
    seperatable?: true
    introduction?: true
    thumbnail?: true
    rate?: true
    category?: true
  }

  export type RESTAURANTCountAggregateInputType = {
    seq?: true
    id?: true
    password?: true
    createdAt?: true
    dayoff?: true
    isOpen?: true
    minOrder?: true
    deliveryTip?: true
    seperatable?: true
    introduction?: true
    thumbnail?: true
    rate?: true
    category?: true
    _all?: true
  }

  export type RESTAURANTAggregateArgs = {
    /**
     * Filter which RESTAURANT to aggregate.
    **/
    where?: RESTAURANTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RESTAURANTS to fetch.
    **/
    orderBy?: Enumerable<RESTAURANTOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: RESTAURANTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RESTAURANTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RESTAURANTS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RESTAURANTS
    **/
    count?: true | RESTAURANTCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: RESTAURANTAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: RESTAURANTSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: RESTAURANTMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: RESTAURANTMaxAggregateInputType
  }

  export type GetRESTAURANTAggregateType<T extends RESTAURANTAggregateArgs> = {
    [P in keyof T & keyof AggregateRESTAURANT]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRESTAURANT[P]>
      : GetScalarType<T[P], AggregateRESTAURANT[P]>
  }


    
    
  export type RESTAURANTGroupByArgs = {
    where?: RESTAURANTWhereInput
    orderBy?: Enumerable<RESTAURANTOrderByInput>
    by: Array<RESTAURANTScalarFieldEnum>
    having?: RESTAURANTScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: RESTAURANTCountAggregateInputType | true
    avg?: RESTAURANTAvgAggregateInputType
    sum?: RESTAURANTSumAggregateInputType
    min?: RESTAURANTMinAggregateInputType
    max?: RESTAURANTMaxAggregateInputType
  }


  export type RESTAURANTGroupByOutputType = {
    seq: number
    id: string
    password: string
    createdAt: Date
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction: string | null
    thumbnail: string | null
    rate: number
    category: string
    count: RESTAURANTCountAggregateOutputType | null
    avg: RESTAURANTAvgAggregateOutputType | null
    sum: RESTAURANTSumAggregateOutputType | null
    min: RESTAURANTMinAggregateOutputType | null
    max: RESTAURANTMaxAggregateOutputType | null
  }

  type GetRESTAURANTGroupByPayload<T extends RESTAURANTGroupByArgs> = Promise<Array<
    PickArray<RESTAURANTGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof RESTAURANTGroupByOutputType))]: GetScalarType<T[P], RESTAURANTGroupByOutputType[P]>
    }
  >>
    

  export type RESTAURANTSelect = {
    seq?: boolean
    id?: boolean
    password?: boolean
    createdAt?: boolean
    dayoff?: boolean
    isOpen?: boolean
    minOrder?: boolean
    deliveryTip?: boolean
    seperatable?: boolean
    introduction?: boolean
    thumbnail?: boolean
    rate?: boolean
    category?: boolean
    LOCATION?: boolean | LOCATIONArgs
    RUN_TIME?: boolean | RUN_TIMEArgs
    CALL?: boolean | CALLArgs
    MENU?: boolean | MENUArgs
    REPLY?: boolean | REPLYArgs
    RES_REVIEW?: boolean | RES_REVIEWArgs
  }

  export type RESTAURANTInclude = {
    LOCATION?: boolean | LOCATIONArgs
    RUN_TIME?: boolean | RUN_TIMEArgs
    CALL?: boolean | CALLArgs
    MENU?: boolean | MENUArgs
    REPLY?: boolean | REPLYArgs
    RES_REVIEW?: boolean | RES_REVIEWArgs
  }

  export type RESTAURANTGetPayload<
    S extends boolean | null | undefined | RESTAURANTArgs,
    U = keyof S
      > = S extends true
        ? RESTAURANT
    : S extends undefined
    ? never
    : S extends RESTAURANTArgs | RESTAURANTFindManyArgs
    ?'include' extends U
    ? RESTAURANT  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'LOCATION'
        ? LOCATIONGetPayload<S['include'][P]> :
        P extends 'RUN_TIME'
        ? RUN_TIMEGetPayload<S['include'][P]> :
        P extends 'CALL'
        ? CALLGetPayload<S['include'][P]> | null :
        P extends 'MENU'
        ? MENUGetPayload<S['include'][P]> | null :
        P extends 'REPLY'
        ? REPLYGetPayload<S['include'][P]> | null :
        P extends 'RES_REVIEW'
        ? RES_REVIEWGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RESTAURANT ?RESTAURANT [P]
  : 
          P extends 'LOCATION'
        ? LOCATIONGetPayload<S['select'][P]> :
        P extends 'RUN_TIME'
        ? RUN_TIMEGetPayload<S['select'][P]> :
        P extends 'CALL'
        ? CALLGetPayload<S['select'][P]> | null :
        P extends 'MENU'
        ? MENUGetPayload<S['select'][P]> | null :
        P extends 'REPLY'
        ? REPLYGetPayload<S['select'][P]> | null :
        P extends 'RES_REVIEW'
        ? RES_REVIEWGetPayload<S['select'][P]> | null : never
  } 
    : RESTAURANT
  : RESTAURANT


  type RESTAURANTCountArgs = Merge<
    Omit<RESTAURANTFindManyArgs, 'select' | 'include'> & {
      select?: RESTAURANTCountAggregateInputType | true
    }
  >

  export interface RESTAURANTDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RESTAURANT that matches the filter.
     * @param {RESTAURANTFindUniqueArgs} args - Arguments to find a RESTAURANT
     * @example
     * // Get one RESTAURANT
     * const rESTAURANT = await prisma.rESTAURANT.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RESTAURANTFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RESTAURANTFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RESTAURANT'> extends True ? CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT>, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T>>> : CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT | null >, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T> | null >>

    /**
     * Find the first RESTAURANT that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RESTAURANTFindFirstArgs} args - Arguments to find a RESTAURANT
     * @example
     * // Get one RESTAURANT
     * const rESTAURANT = await prisma.rESTAURANT.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RESTAURANTFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RESTAURANTFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RESTAURANT'> extends True ? CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT>, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T>>> : CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT | null >, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T> | null >>

    /**
     * Find zero or more RESTAURANTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RESTAURANTFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RESTAURANTS
     * const rESTAURANTS = await prisma.rESTAURANT.findMany()
     * 
     * // Get first 10 RESTAURANTS
     * const rESTAURANTS = await prisma.rESTAURANT.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const rESTAURANTWithSeqOnly = await prisma.rESTAURANT.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends RESTAURANTFindManyArgs>(
      args?: SelectSubset<T, RESTAURANTFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RESTAURANT>>, PrismaPromise<Array<RESTAURANTGetPayload<T>>>>

    /**
     * Create a RESTAURANT.
     * @param {RESTAURANTCreateArgs} args - Arguments to create a RESTAURANT.
     * @example
     * // Create one RESTAURANT
     * const RESTAURANT = await prisma.rESTAURANT.create({
     *   data: {
     *     // ... data to create a RESTAURANT
     *   }
     * })
     * 
    **/
    create<T extends RESTAURANTCreateArgs>(
      args: SelectSubset<T, RESTAURANTCreateArgs>
    ): CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT>, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T>>>

    /**
     * Create many RESTAURANTS.
     *     @param {RESTAURANTCreateManyArgs} args - Arguments to create many RESTAURANTS.
     *     @example
     *     // Create many RESTAURANTS
     *     const rESTAURANT = await prisma.rESTAURANT.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RESTAURANTCreateManyArgs>(
      args?: SelectSubset<T, RESTAURANTCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RESTAURANT.
     * @param {RESTAURANTDeleteArgs} args - Arguments to delete one RESTAURANT.
     * @example
     * // Delete one RESTAURANT
     * const RESTAURANT = await prisma.rESTAURANT.delete({
     *   where: {
     *     // ... filter to delete one RESTAURANT
     *   }
     * })
     * 
    **/
    delete<T extends RESTAURANTDeleteArgs>(
      args: SelectSubset<T, RESTAURANTDeleteArgs>
    ): CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT>, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T>>>

    /**
     * Update one RESTAURANT.
     * @param {RESTAURANTUpdateArgs} args - Arguments to update one RESTAURANT.
     * @example
     * // Update one RESTAURANT
     * const rESTAURANT = await prisma.rESTAURANT.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RESTAURANTUpdateArgs>(
      args: SelectSubset<T, RESTAURANTUpdateArgs>
    ): CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT>, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T>>>

    /**
     * Delete zero or more RESTAURANTS.
     * @param {RESTAURANTDeleteManyArgs} args - Arguments to filter RESTAURANTS to delete.
     * @example
     * // Delete a few RESTAURANTS
     * const { count } = await prisma.rESTAURANT.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RESTAURANTDeleteManyArgs>(
      args?: SelectSubset<T, RESTAURANTDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RESTAURANTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RESTAURANTUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RESTAURANTS
     * const rESTAURANT = await prisma.rESTAURANT.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RESTAURANTUpdateManyArgs>(
      args: SelectSubset<T, RESTAURANTUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RESTAURANT.
     * @param {RESTAURANTUpsertArgs} args - Arguments to update or create a RESTAURANT.
     * @example
     * // Update or create a RESTAURANT
     * const rESTAURANT = await prisma.rESTAURANT.upsert({
     *   create: {
     *     // ... data to create a RESTAURANT
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RESTAURANT we want to update
     *   }
     * })
    **/
    upsert<T extends RESTAURANTUpsertArgs>(
      args: SelectSubset<T, RESTAURANTUpsertArgs>
    ): CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT>, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T>>>

    /**
     * Count the number of RESTAURANTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RESTAURANTCountArgs} args - Arguments to filter RESTAURANTS to count.
     * @example
     * // Count the number of RESTAURANTS
     * const count = await prisma.rESTAURANT.count({
     *   where: {
     *     // ... the filter for the RESTAURANTS we want to count
     *   }
     * })
    **/
    count<T extends RESTAURANTCountArgs>(
      args?: Subset<T, RESTAURANTCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RESTAURANTCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RESTAURANT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RESTAURANTAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RESTAURANTAggregateArgs>(args: Subset<T, RESTAURANTAggregateArgs>): PrismaPromise<GetRESTAURANTAggregateType<T>>

    /**
     * Group by RESTAURANT.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RESTAURANTGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RESTAURANTGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RESTAURANTGroupByArgs['orderBy'] }
        : { orderBy?: RESTAURANTGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RESTAURANTGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRESTAURANTGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RESTAURANT.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RESTAURANTClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    LOCATION<T extends LOCATIONArgs = {}>(args?: Subset<T, LOCATIONArgs>): CheckSelect<T, Prisma__LOCATIONClient<LOCATION | null >, Prisma__LOCATIONClient<LOCATIONGetPayload<T> | null >>;

    RUN_TIME<T extends RUN_TIMEArgs = {}>(args?: Subset<T, RUN_TIMEArgs>): CheckSelect<T, Prisma__RUN_TIMEClient<RUN_TIME | null >, Prisma__RUN_TIMEClient<RUN_TIMEGetPayload<T> | null >>;

    CALL<T extends CALLArgs = {}>(args?: Subset<T, CALLArgs>): CheckSelect<T, Prisma__CALLClient<CALL | null >, Prisma__CALLClient<CALLGetPayload<T> | null >>;

    MENU<T extends MENUArgs = {}>(args?: Subset<T, MENUArgs>): CheckSelect<T, Prisma__MENUClient<MENU | null >, Prisma__MENUClient<MENUGetPayload<T> | null >>;

    REPLY<T extends REPLYArgs = {}>(args?: Subset<T, REPLYArgs>): CheckSelect<T, Prisma__REPLYClient<REPLY | null >, Prisma__REPLYClient<REPLYGetPayload<T> | null >>;

    RES_REVIEW<T extends RES_REVIEWArgs = {}>(args?: Subset<T, RES_REVIEWArgs>): CheckSelect<T, Prisma__RES_REVIEWClient<RES_REVIEW | null >, Prisma__RES_REVIEWClient<RES_REVIEWGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RESTAURANT findUnique
   */
  export type RESTAURANTFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RESTAURANT
    **/
    select?: RESTAURANTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RESTAURANTInclude | null
    /**
     * Throw an Error if a RESTAURANT can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RESTAURANT to fetch.
    **/
    where: RESTAURANTWhereUniqueInput
  }


  /**
   * RESTAURANT findFirst
   */
  export type RESTAURANTFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RESTAURANT
    **/
    select?: RESTAURANTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RESTAURANTInclude | null
    /**
     * Throw an Error if a RESTAURANT can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RESTAURANT to fetch.
    **/
    where?: RESTAURANTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RESTAURANTS to fetch.
    **/
    orderBy?: Enumerable<RESTAURANTOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RESTAURANTS.
    **/
    cursor?: RESTAURANTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RESTAURANTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RESTAURANTS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RESTAURANTS.
    **/
    distinct?: Enumerable<RESTAURANTScalarFieldEnum>
  }


  /**
   * RESTAURANT findMany
   */
  export type RESTAURANTFindManyArgs = {
    /**
     * Select specific fields to fetch from the RESTAURANT
    **/
    select?: RESTAURANTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RESTAURANTInclude | null
    /**
     * Filter, which RESTAURANTS to fetch.
    **/
    where?: RESTAURANTWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RESTAURANTS to fetch.
    **/
    orderBy?: Enumerable<RESTAURANTOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RESTAURANTS.
    **/
    cursor?: RESTAURANTWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RESTAURANTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RESTAURANTS.
    **/
    skip?: number
    distinct?: Enumerable<RESTAURANTScalarFieldEnum>
  }


  /**
   * RESTAURANT create
   */
  export type RESTAURANTCreateArgs = {
    /**
     * Select specific fields to fetch from the RESTAURANT
    **/
    select?: RESTAURANTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RESTAURANTInclude | null
    /**
     * The data needed to create a RESTAURANT.
    **/
    data: XOR<RESTAURANTCreateInput, RESTAURANTUncheckedCreateInput>
  }


  /**
   * RESTAURANT createMany
   */
  export type RESTAURANTCreateManyArgs = {
    data: Enumerable<RESTAURANTCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RESTAURANT update
   */
  export type RESTAURANTUpdateArgs = {
    /**
     * Select specific fields to fetch from the RESTAURANT
    **/
    select?: RESTAURANTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RESTAURANTInclude | null
    /**
     * The data needed to update a RESTAURANT.
    **/
    data: XOR<RESTAURANTUpdateInput, RESTAURANTUncheckedUpdateInput>
    /**
     * Choose, which RESTAURANT to update.
    **/
    where: RESTAURANTWhereUniqueInput
  }


  /**
   * RESTAURANT updateMany
   */
  export type RESTAURANTUpdateManyArgs = {
    data: XOR<RESTAURANTUpdateManyMutationInput, RESTAURANTUncheckedUpdateManyInput>
    where?: RESTAURANTWhereInput
  }


  /**
   * RESTAURANT upsert
   */
  export type RESTAURANTUpsertArgs = {
    /**
     * Select specific fields to fetch from the RESTAURANT
    **/
    select?: RESTAURANTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RESTAURANTInclude | null
    /**
     * The filter to search for the RESTAURANT to update in case it exists.
    **/
    where: RESTAURANTWhereUniqueInput
    /**
     * In case the RESTAURANT found by the `where` argument doesn't exist, create a new RESTAURANT with this data.
    **/
    create: XOR<RESTAURANTCreateInput, RESTAURANTUncheckedCreateInput>
    /**
     * In case the RESTAURANT was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<RESTAURANTUpdateInput, RESTAURANTUncheckedUpdateInput>
  }


  /**
   * RESTAURANT delete
   */
  export type RESTAURANTDeleteArgs = {
    /**
     * Select specific fields to fetch from the RESTAURANT
    **/
    select?: RESTAURANTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RESTAURANTInclude | null
    /**
     * Filter which RESTAURANT to delete.
    **/
    where: RESTAURANTWhereUniqueInput
  }


  /**
   * RESTAURANT deleteMany
   */
  export type RESTAURANTDeleteManyArgs = {
    where?: RESTAURANTWhereInput
  }


  /**
   * RESTAURANT without action
   */
  export type RESTAURANTArgs = {
    /**
     * Select specific fields to fetch from the RESTAURANT
    **/
    select?: RESTAURANTSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RESTAURANTInclude | null
  }



  /**
   * Model RUN_TIME
   */


  export type AggregateRUN_TIME = {
    count: RUN_TIMECountAggregateOutputType | null
    avg: RUN_TIMEAvgAggregateOutputType | null
    sum: RUN_TIMESumAggregateOutputType | null
    min: RUN_TIMEMinAggregateOutputType | null
    max: RUN_TIMEMaxAggregateOutputType | null
  }

  export type RUN_TIMEAvgAggregateOutputType = {
    seq: number
  }

  export type RUN_TIMESumAggregateOutputType = {
    seq: number
  }

  export type RUN_TIMEMinAggregateOutputType = {
    seq: number
    day: string | null
    open: Date | null
    close: Date | null
  }

  export type RUN_TIMEMaxAggregateOutputType = {
    seq: number
    day: string | null
    open: Date | null
    close: Date | null
  }

  export type RUN_TIMECountAggregateOutputType = {
    seq: number
    day: number | null
    open: number | null
    close: number | null
    _all: number
  }


  export type RUN_TIMEAvgAggregateInputType = {
    seq?: true
  }

  export type RUN_TIMESumAggregateInputType = {
    seq?: true
  }

  export type RUN_TIMEMinAggregateInputType = {
    seq?: true
    day?: true
    open?: true
    close?: true
  }

  export type RUN_TIMEMaxAggregateInputType = {
    seq?: true
    day?: true
    open?: true
    close?: true
  }

  export type RUN_TIMECountAggregateInputType = {
    seq?: true
    day?: true
    open?: true
    close?: true
    _all?: true
  }

  export type RUN_TIMEAggregateArgs = {
    /**
     * Filter which RUN_TIME to aggregate.
    **/
    where?: RUN_TIMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RUN_TIMES to fetch.
    **/
    orderBy?: Enumerable<RUN_TIMEOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: RUN_TIMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RUN_TIMES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RUN_TIMES.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RUN_TIMES
    **/
    count?: true | RUN_TIMECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: RUN_TIMEAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: RUN_TIMESumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: RUN_TIMEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: RUN_TIMEMaxAggregateInputType
  }

  export type GetRUN_TIMEAggregateType<T extends RUN_TIMEAggregateArgs> = {
    [P in keyof T & keyof AggregateRUN_TIME]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRUN_TIME[P]>
      : GetScalarType<T[P], AggregateRUN_TIME[P]>
  }


    
    
  export type RUN_TIMEGroupByArgs = {
    where?: RUN_TIMEWhereInput
    orderBy?: Enumerable<RUN_TIMEOrderByInput>
    by: Array<RUN_TIMEScalarFieldEnum>
    having?: RUN_TIMEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: RUN_TIMECountAggregateInputType | true
    avg?: RUN_TIMEAvgAggregateInputType
    sum?: RUN_TIMESumAggregateInputType
    min?: RUN_TIMEMinAggregateInputType
    max?: RUN_TIMEMaxAggregateInputType
  }


  export type RUN_TIMEGroupByOutputType = {
    seq: number
    day: string
    open: Date
    close: Date
    count: RUN_TIMECountAggregateOutputType | null
    avg: RUN_TIMEAvgAggregateOutputType | null
    sum: RUN_TIMESumAggregateOutputType | null
    min: RUN_TIMEMinAggregateOutputType | null
    max: RUN_TIMEMaxAggregateOutputType | null
  }

  type GetRUN_TIMEGroupByPayload<T extends RUN_TIMEGroupByArgs> = Promise<Array<
    PickArray<RUN_TIMEGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof RUN_TIMEGroupByOutputType))]: GetScalarType<T[P], RUN_TIMEGroupByOutputType[P]>
    }
  >>
    

  export type RUN_TIMESelect = {
    seq?: boolean
    day?: boolean
    open?: boolean
    close?: boolean
    RESTAURANT?: boolean | RESTAURANTArgs
  }

  export type RUN_TIMEInclude = {
    RESTAURANT?: boolean | RESTAURANTArgs
  }

  export type RUN_TIMEGetPayload<
    S extends boolean | null | undefined | RUN_TIMEArgs,
    U = keyof S
      > = S extends true
        ? RUN_TIME
    : S extends undefined
    ? never
    : S extends RUN_TIMEArgs | RUN_TIMEFindManyArgs
    ?'include' extends U
    ? RUN_TIME  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'RESTAURANT'
        ? RESTAURANTGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof RUN_TIME ?RUN_TIME [P]
  : 
          P extends 'RESTAURANT'
        ? RESTAURANTGetPayload<S['select'][P]> | null : never
  } 
    : RUN_TIME
  : RUN_TIME


  type RUN_TIMECountArgs = Merge<
    Omit<RUN_TIMEFindManyArgs, 'select' | 'include'> & {
      select?: RUN_TIMECountAggregateInputType | true
    }
  >

  export interface RUN_TIMEDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one RUN_TIME that matches the filter.
     * @param {RUN_TIMEFindUniqueArgs} args - Arguments to find a RUN_TIME
     * @example
     * // Get one RUN_TIME
     * const rUN_TIME = await prisma.rUN_TIME.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RUN_TIMEFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, RUN_TIMEFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'RUN_TIME'> extends True ? CheckSelect<T, Prisma__RUN_TIMEClient<RUN_TIME>, Prisma__RUN_TIMEClient<RUN_TIMEGetPayload<T>>> : CheckSelect<T, Prisma__RUN_TIMEClient<RUN_TIME | null >, Prisma__RUN_TIMEClient<RUN_TIMEGetPayload<T> | null >>

    /**
     * Find the first RUN_TIME that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RUN_TIMEFindFirstArgs} args - Arguments to find a RUN_TIME
     * @example
     * // Get one RUN_TIME
     * const rUN_TIME = await prisma.rUN_TIME.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RUN_TIMEFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, RUN_TIMEFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'RUN_TIME'> extends True ? CheckSelect<T, Prisma__RUN_TIMEClient<RUN_TIME>, Prisma__RUN_TIMEClient<RUN_TIMEGetPayload<T>>> : CheckSelect<T, Prisma__RUN_TIMEClient<RUN_TIME | null >, Prisma__RUN_TIMEClient<RUN_TIMEGetPayload<T> | null >>

    /**
     * Find zero or more RUN_TIMES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RUN_TIMEFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RUN_TIMES
     * const rUN_TIMES = await prisma.rUN_TIME.findMany()
     * 
     * // Get first 10 RUN_TIMES
     * const rUN_TIMES = await prisma.rUN_TIME.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const rUN_TIMEWithSeqOnly = await prisma.rUN_TIME.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends RUN_TIMEFindManyArgs>(
      args?: SelectSubset<T, RUN_TIMEFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<RUN_TIME>>, PrismaPromise<Array<RUN_TIMEGetPayload<T>>>>

    /**
     * Create a RUN_TIME.
     * @param {RUN_TIMECreateArgs} args - Arguments to create a RUN_TIME.
     * @example
     * // Create one RUN_TIME
     * const RUN_TIME = await prisma.rUN_TIME.create({
     *   data: {
     *     // ... data to create a RUN_TIME
     *   }
     * })
     * 
    **/
    create<T extends RUN_TIMECreateArgs>(
      args: SelectSubset<T, RUN_TIMECreateArgs>
    ): CheckSelect<T, Prisma__RUN_TIMEClient<RUN_TIME>, Prisma__RUN_TIMEClient<RUN_TIMEGetPayload<T>>>

    /**
     * Create many RUN_TIMES.
     *     @param {RUN_TIMECreateManyArgs} args - Arguments to create many RUN_TIMES.
     *     @example
     *     // Create many RUN_TIMES
     *     const rUN_TIME = await prisma.rUN_TIME.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RUN_TIMECreateManyArgs>(
      args?: SelectSubset<T, RUN_TIMECreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a RUN_TIME.
     * @param {RUN_TIMEDeleteArgs} args - Arguments to delete one RUN_TIME.
     * @example
     * // Delete one RUN_TIME
     * const RUN_TIME = await prisma.rUN_TIME.delete({
     *   where: {
     *     // ... filter to delete one RUN_TIME
     *   }
     * })
     * 
    **/
    delete<T extends RUN_TIMEDeleteArgs>(
      args: SelectSubset<T, RUN_TIMEDeleteArgs>
    ): CheckSelect<T, Prisma__RUN_TIMEClient<RUN_TIME>, Prisma__RUN_TIMEClient<RUN_TIMEGetPayload<T>>>

    /**
     * Update one RUN_TIME.
     * @param {RUN_TIMEUpdateArgs} args - Arguments to update one RUN_TIME.
     * @example
     * // Update one RUN_TIME
     * const rUN_TIME = await prisma.rUN_TIME.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RUN_TIMEUpdateArgs>(
      args: SelectSubset<T, RUN_TIMEUpdateArgs>
    ): CheckSelect<T, Prisma__RUN_TIMEClient<RUN_TIME>, Prisma__RUN_TIMEClient<RUN_TIMEGetPayload<T>>>

    /**
     * Delete zero or more RUN_TIMES.
     * @param {RUN_TIMEDeleteManyArgs} args - Arguments to filter RUN_TIMES to delete.
     * @example
     * // Delete a few RUN_TIMES
     * const { count } = await prisma.rUN_TIME.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RUN_TIMEDeleteManyArgs>(
      args?: SelectSubset<T, RUN_TIMEDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more RUN_TIMES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RUN_TIMEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RUN_TIMES
     * const rUN_TIME = await prisma.rUN_TIME.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RUN_TIMEUpdateManyArgs>(
      args: SelectSubset<T, RUN_TIMEUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one RUN_TIME.
     * @param {RUN_TIMEUpsertArgs} args - Arguments to update or create a RUN_TIME.
     * @example
     * // Update or create a RUN_TIME
     * const rUN_TIME = await prisma.rUN_TIME.upsert({
     *   create: {
     *     // ... data to create a RUN_TIME
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RUN_TIME we want to update
     *   }
     * })
    **/
    upsert<T extends RUN_TIMEUpsertArgs>(
      args: SelectSubset<T, RUN_TIMEUpsertArgs>
    ): CheckSelect<T, Prisma__RUN_TIMEClient<RUN_TIME>, Prisma__RUN_TIMEClient<RUN_TIMEGetPayload<T>>>

    /**
     * Count the number of RUN_TIMES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RUN_TIMECountArgs} args - Arguments to filter RUN_TIMES to count.
     * @example
     * // Count the number of RUN_TIMES
     * const count = await prisma.rUN_TIME.count({
     *   where: {
     *     // ... the filter for the RUN_TIMES we want to count
     *   }
     * })
    **/
    count<T extends RUN_TIMECountArgs>(
      args?: Subset<T, RUN_TIMECountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RUN_TIMECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RUN_TIME.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RUN_TIMEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RUN_TIMEAggregateArgs>(args: Subset<T, RUN_TIMEAggregateArgs>): PrismaPromise<GetRUN_TIMEAggregateType<T>>

    /**
     * Group by RUN_TIME.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RUN_TIMEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RUN_TIMEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RUN_TIMEGroupByArgs['orderBy'] }
        : { orderBy?: RUN_TIMEGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RUN_TIMEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRUN_TIMEGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for RUN_TIME.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__RUN_TIMEClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    RESTAURANT<T extends RESTAURANTArgs = {}>(args?: Subset<T, RESTAURANTArgs>): CheckSelect<T, Prisma__RESTAURANTClient<RESTAURANT | null >, Prisma__RESTAURANTClient<RESTAURANTGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * RUN_TIME findUnique
   */
  export type RUN_TIMEFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the RUN_TIME
    **/
    select?: RUN_TIMESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RUN_TIMEInclude | null
    /**
     * Throw an Error if a RUN_TIME can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RUN_TIME to fetch.
    **/
    where: RUN_TIMEWhereUniqueInput
  }


  /**
   * RUN_TIME findFirst
   */
  export type RUN_TIMEFindFirstArgs = {
    /**
     * Select specific fields to fetch from the RUN_TIME
    **/
    select?: RUN_TIMESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RUN_TIMEInclude | null
    /**
     * Throw an Error if a RUN_TIME can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which RUN_TIME to fetch.
    **/
    where?: RUN_TIMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RUN_TIMES to fetch.
    **/
    orderBy?: Enumerable<RUN_TIMEOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RUN_TIMES.
    **/
    cursor?: RUN_TIMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RUN_TIMES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RUN_TIMES.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RUN_TIMES.
    **/
    distinct?: Enumerable<RUN_TIMEScalarFieldEnum>
  }


  /**
   * RUN_TIME findMany
   */
  export type RUN_TIMEFindManyArgs = {
    /**
     * Select specific fields to fetch from the RUN_TIME
    **/
    select?: RUN_TIMESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RUN_TIMEInclude | null
    /**
     * Filter, which RUN_TIMES to fetch.
    **/
    where?: RUN_TIMEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RUN_TIMES to fetch.
    **/
    orderBy?: Enumerable<RUN_TIMEOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RUN_TIMES.
    **/
    cursor?: RUN_TIMEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RUN_TIMES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RUN_TIMES.
    **/
    skip?: number
    distinct?: Enumerable<RUN_TIMEScalarFieldEnum>
  }


  /**
   * RUN_TIME create
   */
  export type RUN_TIMECreateArgs = {
    /**
     * Select specific fields to fetch from the RUN_TIME
    **/
    select?: RUN_TIMESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RUN_TIMEInclude | null
    /**
     * The data needed to create a RUN_TIME.
    **/
    data: XOR<RUN_TIMECreateInput, RUN_TIMEUncheckedCreateInput>
  }


  /**
   * RUN_TIME createMany
   */
  export type RUN_TIMECreateManyArgs = {
    data: Enumerable<RUN_TIMECreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * RUN_TIME update
   */
  export type RUN_TIMEUpdateArgs = {
    /**
     * Select specific fields to fetch from the RUN_TIME
    **/
    select?: RUN_TIMESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RUN_TIMEInclude | null
    /**
     * The data needed to update a RUN_TIME.
    **/
    data: XOR<RUN_TIMEUpdateInput, RUN_TIMEUncheckedUpdateInput>
    /**
     * Choose, which RUN_TIME to update.
    **/
    where: RUN_TIMEWhereUniqueInput
  }


  /**
   * RUN_TIME updateMany
   */
  export type RUN_TIMEUpdateManyArgs = {
    data: XOR<RUN_TIMEUpdateManyMutationInput, RUN_TIMEUncheckedUpdateManyInput>
    where?: RUN_TIMEWhereInput
  }


  /**
   * RUN_TIME upsert
   */
  export type RUN_TIMEUpsertArgs = {
    /**
     * Select specific fields to fetch from the RUN_TIME
    **/
    select?: RUN_TIMESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RUN_TIMEInclude | null
    /**
     * The filter to search for the RUN_TIME to update in case it exists.
    **/
    where: RUN_TIMEWhereUniqueInput
    /**
     * In case the RUN_TIME found by the `where` argument doesn't exist, create a new RUN_TIME with this data.
    **/
    create: XOR<RUN_TIMECreateInput, RUN_TIMEUncheckedCreateInput>
    /**
     * In case the RUN_TIME was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<RUN_TIMEUpdateInput, RUN_TIMEUncheckedUpdateInput>
  }


  /**
   * RUN_TIME delete
   */
  export type RUN_TIMEDeleteArgs = {
    /**
     * Select specific fields to fetch from the RUN_TIME
    **/
    select?: RUN_TIMESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RUN_TIMEInclude | null
    /**
     * Filter which RUN_TIME to delete.
    **/
    where: RUN_TIMEWhereUniqueInput
  }


  /**
   * RUN_TIME deleteMany
   */
  export type RUN_TIMEDeleteManyArgs = {
    where?: RUN_TIMEWhereInput
  }


  /**
   * RUN_TIME without action
   */
  export type RUN_TIMEArgs = {
    /**
     * Select specific fields to fetch from the RUN_TIME
    **/
    select?: RUN_TIMESelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: RUN_TIMEInclude | null
  }



  /**
   * Model SELECTED_MENU
   */


  export type AggregateSELECTED_MENU = {
    count: SELECTED_MENUCountAggregateOutputType | null
    avg: SELECTED_MENUAvgAggregateOutputType | null
    sum: SELECTED_MENUSumAggregateOutputType | null
    min: SELECTED_MENUMinAggregateOutputType | null
    max: SELECTED_MENUMaxAggregateOutputType | null
  }

  export type SELECTED_MENUAvgAggregateOutputType = {
    seq: number
    count: number
  }

  export type SELECTED_MENUSumAggregateOutputType = {
    seq: number
    count: number
  }

  export type SELECTED_MENUMinAggregateOutputType = {
    seq: number
    count: number
  }

  export type SELECTED_MENUMaxAggregateOutputType = {
    seq: number
    count: number
  }

  export type SELECTED_MENUCountAggregateOutputType = {
    seq: number
    count: number
    _all: number
  }


  export type SELECTED_MENUAvgAggregateInputType = {
    seq?: true
    count?: true
  }

  export type SELECTED_MENUSumAggregateInputType = {
    seq?: true
    count?: true
  }

  export type SELECTED_MENUMinAggregateInputType = {
    seq?: true
    count?: true
  }

  export type SELECTED_MENUMaxAggregateInputType = {
    seq?: true
    count?: true
  }

  export type SELECTED_MENUCountAggregateInputType = {
    seq?: true
    count?: true
    _all?: true
  }

  export type SELECTED_MENUAggregateArgs = {
    /**
     * Filter which SELECTED_MENU to aggregate.
    **/
    where?: SELECTED_MENUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SELECTED_MENUS to fetch.
    **/
    orderBy?: Enumerable<SELECTED_MENUOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: SELECTED_MENUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SELECTED_MENUS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SELECTED_MENUS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SELECTED_MENUS
    **/
    count?: true | SELECTED_MENUCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SELECTED_MENUAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SELECTED_MENUSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SELECTED_MENUMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SELECTED_MENUMaxAggregateInputType
  }

  export type GetSELECTED_MENUAggregateType<T extends SELECTED_MENUAggregateArgs> = {
    [P in keyof T & keyof AggregateSELECTED_MENU]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSELECTED_MENU[P]>
      : GetScalarType<T[P], AggregateSELECTED_MENU[P]>
  }


    
    
  export type SELECTED_MENUGroupByArgs = {
    where?: SELECTED_MENUWhereInput
    orderBy?: Enumerable<SELECTED_MENUOrderByInput>
    by: Array<SELECTED_MENUScalarFieldEnum>
    having?: SELECTED_MENUScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: SELECTED_MENUCountAggregateInputType | true
    avg?: SELECTED_MENUAvgAggregateInputType
    sum?: SELECTED_MENUSumAggregateInputType
    min?: SELECTED_MENUMinAggregateInputType
    max?: SELECTED_MENUMaxAggregateInputType
  }


  export type SELECTED_MENUGroupByOutputType = {
    seq: number
    count: number
    count: SELECTED_MENUCountAggregateOutputType | null
    avg: SELECTED_MENUAvgAggregateOutputType | null
    sum: SELECTED_MENUSumAggregateOutputType | null
    min: SELECTED_MENUMinAggregateOutputType | null
    max: SELECTED_MENUMaxAggregateOutputType | null
  }

  type GetSELECTED_MENUGroupByPayload<T extends SELECTED_MENUGroupByArgs> = Promise<Array<
    PickArray<SELECTED_MENUGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof SELECTED_MENUGroupByOutputType))]: GetScalarType<T[P], SELECTED_MENUGroupByOutputType[P]>
    }
  >>
    

  export type SELECTED_MENUSelect = {
    seq?: boolean
    count?: boolean
    OPTION_ITEM?: boolean | OPTION_ITEMArgs
    MENU?: boolean | MENUArgs
    CART?: boolean | CARTArgs
  }

  export type SELECTED_MENUInclude = {
    OPTION_ITEM?: boolean | OPTION_ITEMArgs
    MENU?: boolean | MENUArgs
    CART?: boolean | CARTArgs
  }

  export type SELECTED_MENUGetPayload<
    S extends boolean | null | undefined | SELECTED_MENUArgs,
    U = keyof S
      > = S extends true
        ? SELECTED_MENU
    : S extends undefined
    ? never
    : S extends SELECTED_MENUArgs | SELECTED_MENUFindManyArgs
    ?'include' extends U
    ? SELECTED_MENU  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'OPTION_ITEM'
        ? OPTION_ITEMGetPayload<S['include'][P]> :
        P extends 'MENU'
        ? MENUGetPayload<S['include'][P]> :
        P extends 'CART'
        ? CARTGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SELECTED_MENU ?SELECTED_MENU [P]
  : 
          P extends 'OPTION_ITEM'
        ? OPTION_ITEMGetPayload<S['select'][P]> :
        P extends 'MENU'
        ? MENUGetPayload<S['select'][P]> :
        P extends 'CART'
        ? CARTGetPayload<S['select'][P]> | null : never
  } 
    : SELECTED_MENU
  : SELECTED_MENU


  type SELECTED_MENUCountArgs = Merge<
    Omit<SELECTED_MENUFindManyArgs, 'select' | 'include'> & {
      select?: SELECTED_MENUCountAggregateInputType | true
    }
  >

  export interface SELECTED_MENUDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SELECTED_MENU that matches the filter.
     * @param {SELECTED_MENUFindUniqueArgs} args - Arguments to find a SELECTED_MENU
     * @example
     * // Get one SELECTED_MENU
     * const sELECTED_MENU = await prisma.sELECTED_MENU.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SELECTED_MENUFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SELECTED_MENUFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SELECTED_MENU'> extends True ? CheckSelect<T, Prisma__SELECTED_MENUClient<SELECTED_MENU>, Prisma__SELECTED_MENUClient<SELECTED_MENUGetPayload<T>>> : CheckSelect<T, Prisma__SELECTED_MENUClient<SELECTED_MENU | null >, Prisma__SELECTED_MENUClient<SELECTED_MENUGetPayload<T> | null >>

    /**
     * Find the first SELECTED_MENU that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SELECTED_MENUFindFirstArgs} args - Arguments to find a SELECTED_MENU
     * @example
     * // Get one SELECTED_MENU
     * const sELECTED_MENU = await prisma.sELECTED_MENU.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SELECTED_MENUFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SELECTED_MENUFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SELECTED_MENU'> extends True ? CheckSelect<T, Prisma__SELECTED_MENUClient<SELECTED_MENU>, Prisma__SELECTED_MENUClient<SELECTED_MENUGetPayload<T>>> : CheckSelect<T, Prisma__SELECTED_MENUClient<SELECTED_MENU | null >, Prisma__SELECTED_MENUClient<SELECTED_MENUGetPayload<T> | null >>

    /**
     * Find zero or more SELECTED_MENUS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SELECTED_MENUFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SELECTED_MENUS
     * const sELECTED_MENUS = await prisma.sELECTED_MENU.findMany()
     * 
     * // Get first 10 SELECTED_MENUS
     * const sELECTED_MENUS = await prisma.sELECTED_MENU.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const sELECTED_MENUWithSeqOnly = await prisma.sELECTED_MENU.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends SELECTED_MENUFindManyArgs>(
      args?: SelectSubset<T, SELECTED_MENUFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SELECTED_MENU>>, PrismaPromise<Array<SELECTED_MENUGetPayload<T>>>>

    /**
     * Create a SELECTED_MENU.
     * @param {SELECTED_MENUCreateArgs} args - Arguments to create a SELECTED_MENU.
     * @example
     * // Create one SELECTED_MENU
     * const SELECTED_MENU = await prisma.sELECTED_MENU.create({
     *   data: {
     *     // ... data to create a SELECTED_MENU
     *   }
     * })
     * 
    **/
    create<T extends SELECTED_MENUCreateArgs>(
      args: SelectSubset<T, SELECTED_MENUCreateArgs>
    ): CheckSelect<T, Prisma__SELECTED_MENUClient<SELECTED_MENU>, Prisma__SELECTED_MENUClient<SELECTED_MENUGetPayload<T>>>

    /**
     * Create many SELECTED_MENUS.
     *     @param {SELECTED_MENUCreateManyArgs} args - Arguments to create many SELECTED_MENUS.
     *     @example
     *     // Create many SELECTED_MENUS
     *     const sELECTED_MENU = await prisma.sELECTED_MENU.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SELECTED_MENUCreateManyArgs>(
      args?: SelectSubset<T, SELECTED_MENUCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SELECTED_MENU.
     * @param {SELECTED_MENUDeleteArgs} args - Arguments to delete one SELECTED_MENU.
     * @example
     * // Delete one SELECTED_MENU
     * const SELECTED_MENU = await prisma.sELECTED_MENU.delete({
     *   where: {
     *     // ... filter to delete one SELECTED_MENU
     *   }
     * })
     * 
    **/
    delete<T extends SELECTED_MENUDeleteArgs>(
      args: SelectSubset<T, SELECTED_MENUDeleteArgs>
    ): CheckSelect<T, Prisma__SELECTED_MENUClient<SELECTED_MENU>, Prisma__SELECTED_MENUClient<SELECTED_MENUGetPayload<T>>>

    /**
     * Update one SELECTED_MENU.
     * @param {SELECTED_MENUUpdateArgs} args - Arguments to update one SELECTED_MENU.
     * @example
     * // Update one SELECTED_MENU
     * const sELECTED_MENU = await prisma.sELECTED_MENU.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SELECTED_MENUUpdateArgs>(
      args: SelectSubset<T, SELECTED_MENUUpdateArgs>
    ): CheckSelect<T, Prisma__SELECTED_MENUClient<SELECTED_MENU>, Prisma__SELECTED_MENUClient<SELECTED_MENUGetPayload<T>>>

    /**
     * Delete zero or more SELECTED_MENUS.
     * @param {SELECTED_MENUDeleteManyArgs} args - Arguments to filter SELECTED_MENUS to delete.
     * @example
     * // Delete a few SELECTED_MENUS
     * const { count } = await prisma.sELECTED_MENU.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SELECTED_MENUDeleteManyArgs>(
      args?: SelectSubset<T, SELECTED_MENUDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SELECTED_MENUS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SELECTED_MENUUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SELECTED_MENUS
     * const sELECTED_MENU = await prisma.sELECTED_MENU.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SELECTED_MENUUpdateManyArgs>(
      args: SelectSubset<T, SELECTED_MENUUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SELECTED_MENU.
     * @param {SELECTED_MENUUpsertArgs} args - Arguments to update or create a SELECTED_MENU.
     * @example
     * // Update or create a SELECTED_MENU
     * const sELECTED_MENU = await prisma.sELECTED_MENU.upsert({
     *   create: {
     *     // ... data to create a SELECTED_MENU
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SELECTED_MENU we want to update
     *   }
     * })
    **/
    upsert<T extends SELECTED_MENUUpsertArgs>(
      args: SelectSubset<T, SELECTED_MENUUpsertArgs>
    ): CheckSelect<T, Prisma__SELECTED_MENUClient<SELECTED_MENU>, Prisma__SELECTED_MENUClient<SELECTED_MENUGetPayload<T>>>

    /**
     * Count the number of SELECTED_MENUS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SELECTED_MENUCountArgs} args - Arguments to filter SELECTED_MENUS to count.
     * @example
     * // Count the number of SELECTED_MENUS
     * const count = await prisma.sELECTED_MENU.count({
     *   where: {
     *     // ... the filter for the SELECTED_MENUS we want to count
     *   }
     * })
    **/
    count<T extends SELECTED_MENUCountArgs>(
      args?: Subset<T, SELECTED_MENUCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SELECTED_MENUCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SELECTED_MENU.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SELECTED_MENUAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SELECTED_MENUAggregateArgs>(args: Subset<T, SELECTED_MENUAggregateArgs>): PrismaPromise<GetSELECTED_MENUAggregateType<T>>

    /**
     * Group by SELECTED_MENU.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SELECTED_MENUGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SELECTED_MENUGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SELECTED_MENUGroupByArgs['orderBy'] }
        : { orderBy?: SELECTED_MENUGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SELECTED_MENUGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSELECTED_MENUGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SELECTED_MENU.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SELECTED_MENUClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    OPTION_ITEM<T extends OPTION_ITEMArgs = {}>(args?: Subset<T, OPTION_ITEMArgs>): CheckSelect<T, Prisma__OPTION_ITEMClient<OPTION_ITEM | null >, Prisma__OPTION_ITEMClient<OPTION_ITEMGetPayload<T> | null >>;

    MENU<T extends MENUArgs = {}>(args?: Subset<T, MENUArgs>): CheckSelect<T, Prisma__MENUClient<MENU | null >, Prisma__MENUClient<MENUGetPayload<T> | null >>;

    CART<T extends CARTArgs = {}>(args?: Subset<T, CARTArgs>): CheckSelect<T, Prisma__CARTClient<CART | null >, Prisma__CARTClient<CARTGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SELECTED_MENU findUnique
   */
  export type SELECTED_MENUFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SELECTED_MENU
    **/
    select?: SELECTED_MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SELECTED_MENUInclude | null
    /**
     * Throw an Error if a SELECTED_MENU can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SELECTED_MENU to fetch.
    **/
    where: SELECTED_MENUWhereUniqueInput
  }


  /**
   * SELECTED_MENU findFirst
   */
  export type SELECTED_MENUFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SELECTED_MENU
    **/
    select?: SELECTED_MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SELECTED_MENUInclude | null
    /**
     * Throw an Error if a SELECTED_MENU can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SELECTED_MENU to fetch.
    **/
    where?: SELECTED_MENUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SELECTED_MENUS to fetch.
    **/
    orderBy?: Enumerable<SELECTED_MENUOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SELECTED_MENUS.
    **/
    cursor?: SELECTED_MENUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SELECTED_MENUS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SELECTED_MENUS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SELECTED_MENUS.
    **/
    distinct?: Enumerable<SELECTED_MENUScalarFieldEnum>
  }


  /**
   * SELECTED_MENU findMany
   */
  export type SELECTED_MENUFindManyArgs = {
    /**
     * Select specific fields to fetch from the SELECTED_MENU
    **/
    select?: SELECTED_MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SELECTED_MENUInclude | null
    /**
     * Filter, which SELECTED_MENUS to fetch.
    **/
    where?: SELECTED_MENUWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SELECTED_MENUS to fetch.
    **/
    orderBy?: Enumerable<SELECTED_MENUOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SELECTED_MENUS.
    **/
    cursor?: SELECTED_MENUWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SELECTED_MENUS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SELECTED_MENUS.
    **/
    skip?: number
    distinct?: Enumerable<SELECTED_MENUScalarFieldEnum>
  }


  /**
   * SELECTED_MENU create
   */
  export type SELECTED_MENUCreateArgs = {
    /**
     * Select specific fields to fetch from the SELECTED_MENU
    **/
    select?: SELECTED_MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SELECTED_MENUInclude | null
    /**
     * The data needed to create a SELECTED_MENU.
    **/
    data: XOR<SELECTED_MENUCreateInput, SELECTED_MENUUncheckedCreateInput>
  }


  /**
   * SELECTED_MENU createMany
   */
  export type SELECTED_MENUCreateManyArgs = {
    data: Enumerable<SELECTED_MENUCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SELECTED_MENU update
   */
  export type SELECTED_MENUUpdateArgs = {
    /**
     * Select specific fields to fetch from the SELECTED_MENU
    **/
    select?: SELECTED_MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SELECTED_MENUInclude | null
    /**
     * The data needed to update a SELECTED_MENU.
    **/
    data: XOR<SELECTED_MENUUpdateInput, SELECTED_MENUUncheckedUpdateInput>
    /**
     * Choose, which SELECTED_MENU to update.
    **/
    where: SELECTED_MENUWhereUniqueInput
  }


  /**
   * SELECTED_MENU updateMany
   */
  export type SELECTED_MENUUpdateManyArgs = {
    data: XOR<SELECTED_MENUUpdateManyMutationInput, SELECTED_MENUUncheckedUpdateManyInput>
    where?: SELECTED_MENUWhereInput
  }


  /**
   * SELECTED_MENU upsert
   */
  export type SELECTED_MENUUpsertArgs = {
    /**
     * Select specific fields to fetch from the SELECTED_MENU
    **/
    select?: SELECTED_MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SELECTED_MENUInclude | null
    /**
     * The filter to search for the SELECTED_MENU to update in case it exists.
    **/
    where: SELECTED_MENUWhereUniqueInput
    /**
     * In case the SELECTED_MENU found by the `where` argument doesn't exist, create a new SELECTED_MENU with this data.
    **/
    create: XOR<SELECTED_MENUCreateInput, SELECTED_MENUUncheckedCreateInput>
    /**
     * In case the SELECTED_MENU was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<SELECTED_MENUUpdateInput, SELECTED_MENUUncheckedUpdateInput>
  }


  /**
   * SELECTED_MENU delete
   */
  export type SELECTED_MENUDeleteArgs = {
    /**
     * Select specific fields to fetch from the SELECTED_MENU
    **/
    select?: SELECTED_MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SELECTED_MENUInclude | null
    /**
     * Filter which SELECTED_MENU to delete.
    **/
    where: SELECTED_MENUWhereUniqueInput
  }


  /**
   * SELECTED_MENU deleteMany
   */
  export type SELECTED_MENUDeleteManyArgs = {
    where?: SELECTED_MENUWhereInput
  }


  /**
   * SELECTED_MENU without action
   */
  export type SELECTED_MENUArgs = {
    /**
     * Select specific fields to fetch from the SELECTED_MENU
    **/
    select?: SELECTED_MENUSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: SELECTED_MENUInclude | null
  }



  /**
   * Model USER
   */


  export type AggregateUSER = {
    count: USERCountAggregateOutputType | null
    avg: USERAvgAggregateOutputType | null
    sum: USERSumAggregateOutputType | null
    min: USERMinAggregateOutputType | null
    max: USERMaxAggregateOutputType | null
  }

  export type USERAvgAggregateOutputType = {
    seq: number
  }

  export type USERSumAggregateOutputType = {
    seq: number
  }

  export type USERMinAggregateOutputType = {
    seq: number
    ID: string | null
    password: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    thumbnail: string | null
    token: string | null
    status: USER_status | null
  }

  export type USERMaxAggregateOutputType = {
    seq: number
    ID: string | null
    password: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    thumbnail: string | null
    token: string | null
    status: USER_status | null
  }

  export type USERCountAggregateOutputType = {
    seq: number
    ID: number | null
    password: number | null
    name: number | null
    createdAt: number | null
    updatedAt: number | null
    thumbnail: number | null
    token: number | null
    status: number | null
    _all: number
  }


  export type USERAvgAggregateInputType = {
    seq?: true
  }

  export type USERSumAggregateInputType = {
    seq?: true
  }

  export type USERMinAggregateInputType = {
    seq?: true
    ID?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    thumbnail?: true
    token?: true
    status?: true
  }

  export type USERMaxAggregateInputType = {
    seq?: true
    ID?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    thumbnail?: true
    token?: true
    status?: true
  }

  export type USERCountAggregateInputType = {
    seq?: true
    ID?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    thumbnail?: true
    token?: true
    status?: true
    _all?: true
  }

  export type USERAggregateArgs = {
    /**
     * Filter which USER to aggregate.
    **/
    where?: USERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USERS to fetch.
    **/
    orderBy?: Enumerable<USEROrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: USERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USERS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USERS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned USERS
    **/
    count?: true | USERCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: USERAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: USERSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: USERMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: USERMaxAggregateInputType
  }

  export type GetUSERAggregateType<T extends USERAggregateArgs> = {
    [P in keyof T & keyof AggregateUSER]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUSER[P]>
      : GetScalarType<T[P], AggregateUSER[P]>
  }


    
    
  export type USERGroupByArgs = {
    where?: USERWhereInput
    orderBy?: Enumerable<USEROrderByInput>
    by: Array<USERScalarFieldEnum>
    having?: USERScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: USERCountAggregateInputType | true
    avg?: USERAvgAggregateInputType
    sum?: USERSumAggregateInputType
    min?: USERMinAggregateInputType
    max?: USERMaxAggregateInputType
  }


  export type USERGroupByOutputType = {
    seq: number
    ID: string
    password: string
    name: string
    createdAt: Date | null
    updatedAt: Date | null
    thumbnail: string | null
    token: string
    status: USER_status
    count: USERCountAggregateOutputType | null
    avg: USERAvgAggregateOutputType | null
    sum: USERSumAggregateOutputType | null
    min: USERMinAggregateOutputType | null
    max: USERMaxAggregateOutputType | null
  }

  type GetUSERGroupByPayload<T extends USERGroupByArgs> = Promise<Array<
    PickArray<USERGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof USERGroupByOutputType))]: GetScalarType<T[P], USERGroupByOutputType[P]>
    }
  >>
    

  export type USERSelect = {
    seq?: boolean
    ID?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thumbnail?: boolean
    token?: boolean
    status?: boolean
    CALL?: boolean | CALLArgs
    CART?: boolean | CARTArgs
    CHAT?: boolean | CHATArgs
    MESSAGE?: boolean | MESSAGEArgs
    ORDER?: boolean | ORDERArgs
    REPORT?: boolean | REPORTArgs
    RES_REVIEW?: boolean | RES_REVIEWArgs
    USER_REVIEW?: boolean | USER_REVIEWArgs
  }

  export type USERInclude = {
    CALL?: boolean | CALLArgs
    CART?: boolean | CARTArgs
    CHAT?: boolean | CHATArgs
    MESSAGE?: boolean | MESSAGEArgs
    ORDER?: boolean | ORDERArgs
    REPORT?: boolean | REPORTArgs
    RES_REVIEW?: boolean | RES_REVIEWArgs
    USER_REVIEW?: boolean | USER_REVIEWArgs
  }

  export type USERGetPayload<
    S extends boolean | null | undefined | USERArgs,
    U = keyof S
      > = S extends true
        ? USER
    : S extends undefined
    ? never
    : S extends USERArgs | USERFindManyArgs
    ?'include' extends U
    ? USER  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CALL'
        ? CALLGetPayload<S['include'][P]> | null :
        P extends 'CART'
        ? CARTGetPayload<S['include'][P]> | null :
        P extends 'CHAT'
        ? CHATGetPayload<S['include'][P]> | null :
        P extends 'MESSAGE'
        ? MESSAGEGetPayload<S['include'][P]> | null :
        P extends 'ORDER'
        ? ORDERGetPayload<S['include'][P]> | null :
        P extends 'REPORT'
        ? REPORTGetPayload<S['include'][P]> | null :
        P extends 'RES_REVIEW'
        ? RES_REVIEWGetPayload<S['include'][P]> | null :
        P extends 'USER_REVIEW'
        ? USER_REVIEWGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof USER ?USER [P]
  : 
          P extends 'CALL'
        ? CALLGetPayload<S['select'][P]> | null :
        P extends 'CART'
        ? CARTGetPayload<S['select'][P]> | null :
        P extends 'CHAT'
        ? CHATGetPayload<S['select'][P]> | null :
        P extends 'MESSAGE'
        ? MESSAGEGetPayload<S['select'][P]> | null :
        P extends 'ORDER'
        ? ORDERGetPayload<S['select'][P]> | null :
        P extends 'REPORT'
        ? REPORTGetPayload<S['select'][P]> | null :
        P extends 'RES_REVIEW'
        ? RES_REVIEWGetPayload<S['select'][P]> | null :
        P extends 'USER_REVIEW'
        ? USER_REVIEWGetPayload<S['select'][P]> | null : never
  } 
    : USER
  : USER


  type USERCountArgs = Merge<
    Omit<USERFindManyArgs, 'select' | 'include'> & {
      select?: USERCountAggregateInputType | true
    }
  >

  export interface USERDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one USER that matches the filter.
     * @param {USERFindUniqueArgs} args - Arguments to find a USER
     * @example
     * // Get one USER
     * const uSER = await prisma.uSER.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends USERFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, USERFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'USER'> extends True ? CheckSelect<T, Prisma__USERClient<USER>, Prisma__USERClient<USERGetPayload<T>>> : CheckSelect<T, Prisma__USERClient<USER | null >, Prisma__USERClient<USERGetPayload<T> | null >>

    /**
     * Find the first USER that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USERFindFirstArgs} args - Arguments to find a USER
     * @example
     * // Get one USER
     * const uSER = await prisma.uSER.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends USERFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, USERFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'USER'> extends True ? CheckSelect<T, Prisma__USERClient<USER>, Prisma__USERClient<USERGetPayload<T>>> : CheckSelect<T, Prisma__USERClient<USER | null >, Prisma__USERClient<USERGetPayload<T> | null >>

    /**
     * Find zero or more USERS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USERFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all USERS
     * const uSERS = await prisma.uSER.findMany()
     * 
     * // Get first 10 USERS
     * const uSERS = await prisma.uSER.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const uSERWithSeqOnly = await prisma.uSER.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends USERFindManyArgs>(
      args?: SelectSubset<T, USERFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<USER>>, PrismaPromise<Array<USERGetPayload<T>>>>

    /**
     * Create a USER.
     * @param {USERCreateArgs} args - Arguments to create a USER.
     * @example
     * // Create one USER
     * const USER = await prisma.uSER.create({
     *   data: {
     *     // ... data to create a USER
     *   }
     * })
     * 
    **/
    create<T extends USERCreateArgs>(
      args: SelectSubset<T, USERCreateArgs>
    ): CheckSelect<T, Prisma__USERClient<USER>, Prisma__USERClient<USERGetPayload<T>>>

    /**
     * Create many USERS.
     *     @param {USERCreateManyArgs} args - Arguments to create many USERS.
     *     @example
     *     // Create many USERS
     *     const uSER = await prisma.uSER.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends USERCreateManyArgs>(
      args?: SelectSubset<T, USERCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a USER.
     * @param {USERDeleteArgs} args - Arguments to delete one USER.
     * @example
     * // Delete one USER
     * const USER = await prisma.uSER.delete({
     *   where: {
     *     // ... filter to delete one USER
     *   }
     * })
     * 
    **/
    delete<T extends USERDeleteArgs>(
      args: SelectSubset<T, USERDeleteArgs>
    ): CheckSelect<T, Prisma__USERClient<USER>, Prisma__USERClient<USERGetPayload<T>>>

    /**
     * Update one USER.
     * @param {USERUpdateArgs} args - Arguments to update one USER.
     * @example
     * // Update one USER
     * const uSER = await prisma.uSER.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends USERUpdateArgs>(
      args: SelectSubset<T, USERUpdateArgs>
    ): CheckSelect<T, Prisma__USERClient<USER>, Prisma__USERClient<USERGetPayload<T>>>

    /**
     * Delete zero or more USERS.
     * @param {USERDeleteManyArgs} args - Arguments to filter USERS to delete.
     * @example
     * // Delete a few USERS
     * const { count } = await prisma.uSER.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends USERDeleteManyArgs>(
      args?: SelectSubset<T, USERDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more USERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USERUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many USERS
     * const uSER = await prisma.uSER.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends USERUpdateManyArgs>(
      args: SelectSubset<T, USERUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one USER.
     * @param {USERUpsertArgs} args - Arguments to update or create a USER.
     * @example
     * // Update or create a USER
     * const uSER = await prisma.uSER.upsert({
     *   create: {
     *     // ... data to create a USER
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the USER we want to update
     *   }
     * })
    **/
    upsert<T extends USERUpsertArgs>(
      args: SelectSubset<T, USERUpsertArgs>
    ): CheckSelect<T, Prisma__USERClient<USER>, Prisma__USERClient<USERGetPayload<T>>>

    /**
     * Count the number of USERS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USERCountArgs} args - Arguments to filter USERS to count.
     * @example
     * // Count the number of USERS
     * const count = await prisma.uSER.count({
     *   where: {
     *     // ... the filter for the USERS we want to count
     *   }
     * })
    **/
    count<T extends USERCountArgs>(
      args?: Subset<T, USERCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], USERCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a USER.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USERAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends USERAggregateArgs>(args: Subset<T, USERAggregateArgs>): PrismaPromise<GetUSERAggregateType<T>>

    /**
     * Group by USER.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USERGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends USERGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: USERGroupByArgs['orderBy'] }
        : { orderBy?: USERGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, USERGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUSERGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for USER.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__USERClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CALL<T extends CALLArgs = {}>(args?: Subset<T, CALLArgs>): CheckSelect<T, Prisma__CALLClient<CALL | null >, Prisma__CALLClient<CALLGetPayload<T> | null >>;

    CART<T extends CARTArgs = {}>(args?: Subset<T, CARTArgs>): CheckSelect<T, Prisma__CARTClient<CART | null >, Prisma__CARTClient<CARTGetPayload<T> | null >>;

    CHAT<T extends CHATArgs = {}>(args?: Subset<T, CHATArgs>): CheckSelect<T, Prisma__CHATClient<CHAT | null >, Prisma__CHATClient<CHATGetPayload<T> | null >>;

    MESSAGE<T extends MESSAGEArgs = {}>(args?: Subset<T, MESSAGEArgs>): CheckSelect<T, Prisma__MESSAGEClient<MESSAGE | null >, Prisma__MESSAGEClient<MESSAGEGetPayload<T> | null >>;

    ORDER<T extends ORDERArgs = {}>(args?: Subset<T, ORDERArgs>): CheckSelect<T, Prisma__ORDERClient<ORDER | null >, Prisma__ORDERClient<ORDERGetPayload<T> | null >>;

    REPORT<T extends REPORTArgs = {}>(args?: Subset<T, REPORTArgs>): CheckSelect<T, Prisma__REPORTClient<REPORT | null >, Prisma__REPORTClient<REPORTGetPayload<T> | null >>;

    RES_REVIEW<T extends RES_REVIEWArgs = {}>(args?: Subset<T, RES_REVIEWArgs>): CheckSelect<T, Prisma__RES_REVIEWClient<RES_REVIEW | null >, Prisma__RES_REVIEWClient<RES_REVIEWGetPayload<T> | null >>;

    USER_REVIEW<T extends USER_REVIEWArgs = {}>(args?: Subset<T, USER_REVIEWArgs>): CheckSelect<T, Prisma__USER_REVIEWClient<USER_REVIEW | null >, Prisma__USER_REVIEWClient<USER_REVIEWGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * USER findUnique
   */
  export type USERFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the USER
    **/
    select?: USERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USERInclude | null
    /**
     * Throw an Error if a USER can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which USER to fetch.
    **/
    where: USERWhereUniqueInput
  }


  /**
   * USER findFirst
   */
  export type USERFindFirstArgs = {
    /**
     * Select specific fields to fetch from the USER
    **/
    select?: USERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USERInclude | null
    /**
     * Throw an Error if a USER can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which USER to fetch.
    **/
    where?: USERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USERS to fetch.
    **/
    orderBy?: Enumerable<USEROrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for USERS.
    **/
    cursor?: USERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USERS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USERS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of USERS.
    **/
    distinct?: Enumerable<USERScalarFieldEnum>
  }


  /**
   * USER findMany
   */
  export type USERFindManyArgs = {
    /**
     * Select specific fields to fetch from the USER
    **/
    select?: USERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USERInclude | null
    /**
     * Filter, which USERS to fetch.
    **/
    where?: USERWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USERS to fetch.
    **/
    orderBy?: Enumerable<USEROrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing USERS.
    **/
    cursor?: USERWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USERS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USERS.
    **/
    skip?: number
    distinct?: Enumerable<USERScalarFieldEnum>
  }


  /**
   * USER create
   */
  export type USERCreateArgs = {
    /**
     * Select specific fields to fetch from the USER
    **/
    select?: USERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USERInclude | null
    /**
     * The data needed to create a USER.
    **/
    data: XOR<USERCreateInput, USERUncheckedCreateInput>
  }


  /**
   * USER createMany
   */
  export type USERCreateManyArgs = {
    data: Enumerable<USERCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * USER update
   */
  export type USERUpdateArgs = {
    /**
     * Select specific fields to fetch from the USER
    **/
    select?: USERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USERInclude | null
    /**
     * The data needed to update a USER.
    **/
    data: XOR<USERUpdateInput, USERUncheckedUpdateInput>
    /**
     * Choose, which USER to update.
    **/
    where: USERWhereUniqueInput
  }


  /**
   * USER updateMany
   */
  export type USERUpdateManyArgs = {
    data: XOR<USERUpdateManyMutationInput, USERUncheckedUpdateManyInput>
    where?: USERWhereInput
  }


  /**
   * USER upsert
   */
  export type USERUpsertArgs = {
    /**
     * Select specific fields to fetch from the USER
    **/
    select?: USERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USERInclude | null
    /**
     * The filter to search for the USER to update in case it exists.
    **/
    where: USERWhereUniqueInput
    /**
     * In case the USER found by the `where` argument doesn't exist, create a new USER with this data.
    **/
    create: XOR<USERCreateInput, USERUncheckedCreateInput>
    /**
     * In case the USER was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<USERUpdateInput, USERUncheckedUpdateInput>
  }


  /**
   * USER delete
   */
  export type USERDeleteArgs = {
    /**
     * Select specific fields to fetch from the USER
    **/
    select?: USERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USERInclude | null
    /**
     * Filter which USER to delete.
    **/
    where: USERWhereUniqueInput
  }


  /**
   * USER deleteMany
   */
  export type USERDeleteManyArgs = {
    where?: USERWhereInput
  }


  /**
   * USER without action
   */
  export type USERArgs = {
    /**
     * Select specific fields to fetch from the USER
    **/
    select?: USERSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USERInclude | null
  }



  /**
   * Model USER_REVIEW
   */


  export type AggregateUSER_REVIEW = {
    count: USER_REVIEWCountAggregateOutputType | null
    avg: USER_REVIEWAvgAggregateOutputType | null
    sum: USER_REVIEWSumAggregateOutputType | null
    min: USER_REVIEWMinAggregateOutputType | null
    max: USER_REVIEWMaxAggregateOutputType | null
  }

  export type USER_REVIEWAvgAggregateOutputType = {
    seq: number
    rate: number
  }

  export type USER_REVIEWSumAggregateOutputType = {
    seq: number
    rate: number
  }

  export type USER_REVIEWMinAggregateOutputType = {
    seq: number
    createdAt: Date | null
    updatedAt: Date | null
    rate: number
    content: string | null
  }

  export type USER_REVIEWMaxAggregateOutputType = {
    seq: number
    createdAt: Date | null
    updatedAt: Date | null
    rate: number
    content: string | null
  }

  export type USER_REVIEWCountAggregateOutputType = {
    seq: number
    createdAt: number | null
    updatedAt: number | null
    rate: number
    content: number | null
    _all: number
  }


  export type USER_REVIEWAvgAggregateInputType = {
    seq?: true
    rate?: true
  }

  export type USER_REVIEWSumAggregateInputType = {
    seq?: true
    rate?: true
  }

  export type USER_REVIEWMinAggregateInputType = {
    seq?: true
    createdAt?: true
    updatedAt?: true
    rate?: true
    content?: true
  }

  export type USER_REVIEWMaxAggregateInputType = {
    seq?: true
    createdAt?: true
    updatedAt?: true
    rate?: true
    content?: true
  }

  export type USER_REVIEWCountAggregateInputType = {
    seq?: true
    createdAt?: true
    updatedAt?: true
    rate?: true
    content?: true
    _all?: true
  }

  export type USER_REVIEWAggregateArgs = {
    /**
     * Filter which USER_REVIEW to aggregate.
    **/
    where?: USER_REVIEWWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USER_REVIEWS to fetch.
    **/
    orderBy?: Enumerable<USER_REVIEWOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: USER_REVIEWWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USER_REVIEWS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USER_REVIEWS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned USER_REVIEWS
    **/
    count?: true | USER_REVIEWCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: USER_REVIEWAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: USER_REVIEWSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: USER_REVIEWMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: USER_REVIEWMaxAggregateInputType
  }

  export type GetUSER_REVIEWAggregateType<T extends USER_REVIEWAggregateArgs> = {
    [P in keyof T & keyof AggregateUSER_REVIEW]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUSER_REVIEW[P]>
      : GetScalarType<T[P], AggregateUSER_REVIEW[P]>
  }


    
    
  export type USER_REVIEWGroupByArgs = {
    where?: USER_REVIEWWhereInput
    orderBy?: Enumerable<USER_REVIEWOrderByInput>
    by: Array<USER_REVIEWScalarFieldEnum>
    having?: USER_REVIEWScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    count?: USER_REVIEWCountAggregateInputType | true
    avg?: USER_REVIEWAvgAggregateInputType
    sum?: USER_REVIEWSumAggregateInputType
    min?: USER_REVIEWMinAggregateInputType
    max?: USER_REVIEWMaxAggregateInputType
  }


  export type USER_REVIEWGroupByOutputType = {
    seq: number
    createdAt: Date
    updatedAt: Date | null
    rate: number
    content: string | null
    count: USER_REVIEWCountAggregateOutputType | null
    avg: USER_REVIEWAvgAggregateOutputType | null
    sum: USER_REVIEWSumAggregateOutputType | null
    min: USER_REVIEWMinAggregateOutputType | null
    max: USER_REVIEWMaxAggregateOutputType | null
  }

  type GetUSER_REVIEWGroupByPayload<T extends USER_REVIEWGroupByArgs> = Promise<Array<
    PickArray<USER_REVIEWGroupByOutputType, T['by']> & {
      [P in ((keyof T) & (keyof USER_REVIEWGroupByOutputType))]: GetScalarType<T[P], USER_REVIEWGroupByOutputType[P]>
    }
  >>
    

  export type USER_REVIEWSelect = {
    seq?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rate?: boolean
    content?: boolean
    ORDER_ORDERToUSER_REVIEW_seq?: boolean | ORDERArgs
    USER?: boolean | USERArgs
    ORDER_ORDER_seqToUSER_REVIEW?: boolean | ORDERArgs
  }

  export type USER_REVIEWInclude = {
    ORDER_ORDERToUSER_REVIEW_seq?: boolean | ORDERArgs
    USER?: boolean | USERArgs
    ORDER_ORDER_seqToUSER_REVIEW?: boolean | ORDERArgs
  }

  export type USER_REVIEWGetPayload<
    S extends boolean | null | undefined | USER_REVIEWArgs,
    U = keyof S
      > = S extends true
        ? USER_REVIEW
    : S extends undefined
    ? never
    : S extends USER_REVIEWArgs | USER_REVIEWFindManyArgs
    ?'include' extends U
    ? USER_REVIEW  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'ORDER_ORDERToUSER_REVIEW_seq'
        ? ORDERGetPayload<S['include'][P]> :
        P extends 'USER'
        ? USERGetPayload<S['include'][P]> :
        P extends 'ORDER_ORDER_seqToUSER_REVIEW'
        ? ORDERGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof USER_REVIEW ?USER_REVIEW [P]
  : 
          P extends 'ORDER_ORDERToUSER_REVIEW_seq'
        ? ORDERGetPayload<S['select'][P]> :
        P extends 'USER'
        ? USERGetPayload<S['select'][P]> :
        P extends 'ORDER_ORDER_seqToUSER_REVIEW'
        ? ORDERGetPayload<S['select'][P]> | null : never
  } 
    : USER_REVIEW
  : USER_REVIEW


  type USER_REVIEWCountArgs = Merge<
    Omit<USER_REVIEWFindManyArgs, 'select' | 'include'> & {
      select?: USER_REVIEWCountAggregateInputType | true
    }
  >

  export interface USER_REVIEWDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one USER_REVIEW that matches the filter.
     * @param {USER_REVIEWFindUniqueArgs} args - Arguments to find a USER_REVIEW
     * @example
     * // Get one USER_REVIEW
     * const uSER_REVIEW = await prisma.uSER_REVIEW.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends USER_REVIEWFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, USER_REVIEWFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'USER_REVIEW'> extends True ? CheckSelect<T, Prisma__USER_REVIEWClient<USER_REVIEW>, Prisma__USER_REVIEWClient<USER_REVIEWGetPayload<T>>> : CheckSelect<T, Prisma__USER_REVIEWClient<USER_REVIEW | null >, Prisma__USER_REVIEWClient<USER_REVIEWGetPayload<T> | null >>

    /**
     * Find the first USER_REVIEW that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_REVIEWFindFirstArgs} args - Arguments to find a USER_REVIEW
     * @example
     * // Get one USER_REVIEW
     * const uSER_REVIEW = await prisma.uSER_REVIEW.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends USER_REVIEWFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, USER_REVIEWFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'USER_REVIEW'> extends True ? CheckSelect<T, Prisma__USER_REVIEWClient<USER_REVIEW>, Prisma__USER_REVIEWClient<USER_REVIEWGetPayload<T>>> : CheckSelect<T, Prisma__USER_REVIEWClient<USER_REVIEW | null >, Prisma__USER_REVIEWClient<USER_REVIEWGetPayload<T> | null >>

    /**
     * Find zero or more USER_REVIEWS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_REVIEWFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all USER_REVIEWS
     * const uSER_REVIEWS = await prisma.uSER_REVIEW.findMany()
     * 
     * // Get first 10 USER_REVIEWS
     * const uSER_REVIEWS = await prisma.uSER_REVIEW.findMany({ take: 10 })
     * 
     * // Only select the `seq`
     * const uSER_REVIEWWithSeqOnly = await prisma.uSER_REVIEW.findMany({ select: { seq: true } })
     * 
    **/
    findMany<T extends USER_REVIEWFindManyArgs>(
      args?: SelectSubset<T, USER_REVIEWFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<USER_REVIEW>>, PrismaPromise<Array<USER_REVIEWGetPayload<T>>>>

    /**
     * Create a USER_REVIEW.
     * @param {USER_REVIEWCreateArgs} args - Arguments to create a USER_REVIEW.
     * @example
     * // Create one USER_REVIEW
     * const USER_REVIEW = await prisma.uSER_REVIEW.create({
     *   data: {
     *     // ... data to create a USER_REVIEW
     *   }
     * })
     * 
    **/
    create<T extends USER_REVIEWCreateArgs>(
      args: SelectSubset<T, USER_REVIEWCreateArgs>
    ): CheckSelect<T, Prisma__USER_REVIEWClient<USER_REVIEW>, Prisma__USER_REVIEWClient<USER_REVIEWGetPayload<T>>>

    /**
     * Create many USER_REVIEWS.
     *     @param {USER_REVIEWCreateManyArgs} args - Arguments to create many USER_REVIEWS.
     *     @example
     *     // Create many USER_REVIEWS
     *     const uSER_REVIEW = await prisma.uSER_REVIEW.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends USER_REVIEWCreateManyArgs>(
      args?: SelectSubset<T, USER_REVIEWCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a USER_REVIEW.
     * @param {USER_REVIEWDeleteArgs} args - Arguments to delete one USER_REVIEW.
     * @example
     * // Delete one USER_REVIEW
     * const USER_REVIEW = await prisma.uSER_REVIEW.delete({
     *   where: {
     *     // ... filter to delete one USER_REVIEW
     *   }
     * })
     * 
    **/
    delete<T extends USER_REVIEWDeleteArgs>(
      args: SelectSubset<T, USER_REVIEWDeleteArgs>
    ): CheckSelect<T, Prisma__USER_REVIEWClient<USER_REVIEW>, Prisma__USER_REVIEWClient<USER_REVIEWGetPayload<T>>>

    /**
     * Update one USER_REVIEW.
     * @param {USER_REVIEWUpdateArgs} args - Arguments to update one USER_REVIEW.
     * @example
     * // Update one USER_REVIEW
     * const uSER_REVIEW = await prisma.uSER_REVIEW.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends USER_REVIEWUpdateArgs>(
      args: SelectSubset<T, USER_REVIEWUpdateArgs>
    ): CheckSelect<T, Prisma__USER_REVIEWClient<USER_REVIEW>, Prisma__USER_REVIEWClient<USER_REVIEWGetPayload<T>>>

    /**
     * Delete zero or more USER_REVIEWS.
     * @param {USER_REVIEWDeleteManyArgs} args - Arguments to filter USER_REVIEWS to delete.
     * @example
     * // Delete a few USER_REVIEWS
     * const { count } = await prisma.uSER_REVIEW.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends USER_REVIEWDeleteManyArgs>(
      args?: SelectSubset<T, USER_REVIEWDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more USER_REVIEWS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_REVIEWUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many USER_REVIEWS
     * const uSER_REVIEW = await prisma.uSER_REVIEW.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends USER_REVIEWUpdateManyArgs>(
      args: SelectSubset<T, USER_REVIEWUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one USER_REVIEW.
     * @param {USER_REVIEWUpsertArgs} args - Arguments to update or create a USER_REVIEW.
     * @example
     * // Update or create a USER_REVIEW
     * const uSER_REVIEW = await prisma.uSER_REVIEW.upsert({
     *   create: {
     *     // ... data to create a USER_REVIEW
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the USER_REVIEW we want to update
     *   }
     * })
    **/
    upsert<T extends USER_REVIEWUpsertArgs>(
      args: SelectSubset<T, USER_REVIEWUpsertArgs>
    ): CheckSelect<T, Prisma__USER_REVIEWClient<USER_REVIEW>, Prisma__USER_REVIEWClient<USER_REVIEWGetPayload<T>>>

    /**
     * Count the number of USER_REVIEWS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_REVIEWCountArgs} args - Arguments to filter USER_REVIEWS to count.
     * @example
     * // Count the number of USER_REVIEWS
     * const count = await prisma.uSER_REVIEW.count({
     *   where: {
     *     // ... the filter for the USER_REVIEWS we want to count
     *   }
     * })
    **/
    count<T extends USER_REVIEWCountArgs>(
      args?: Subset<T, USER_REVIEWCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], USER_REVIEWCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a USER_REVIEW.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_REVIEWAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends USER_REVIEWAggregateArgs>(args: Subset<T, USER_REVIEWAggregateArgs>): PrismaPromise<GetUSER_REVIEWAggregateType<T>>

    /**
     * Group by USER_REVIEW.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {USER_REVIEWGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends USER_REVIEWGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: USER_REVIEWGroupByArgs['orderBy'] }
        : { orderBy?: USER_REVIEWGroupByArgs['orderBy'] },
      OrderFields extends Keys<MaybeTupleToUnion<T['orderBy']>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, USER_REVIEWGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUSER_REVIEWGroupByPayload<T> : Promise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for USER_REVIEW.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__USER_REVIEWClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    ORDER_ORDERToUSER_REVIEW_seq<T extends ORDERArgs = {}>(args?: Subset<T, ORDERArgs>): CheckSelect<T, Prisma__ORDERClient<ORDER | null >, Prisma__ORDERClient<ORDERGetPayload<T> | null >>;

    USER<T extends USERArgs = {}>(args?: Subset<T, USERArgs>): CheckSelect<T, Prisma__USERClient<USER | null >, Prisma__USERClient<USERGetPayload<T> | null >>;

    ORDER_ORDER_seqToUSER_REVIEW<T extends ORDERArgs = {}>(args?: Subset<T, ORDERArgs>): CheckSelect<T, Prisma__ORDERClient<ORDER | null >, Prisma__ORDERClient<ORDERGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * USER_REVIEW findUnique
   */
  export type USER_REVIEWFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the USER_REVIEW
    **/
    select?: USER_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USER_REVIEWInclude | null
    /**
     * Throw an Error if a USER_REVIEW can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which USER_REVIEW to fetch.
    **/
    where: USER_REVIEWWhereUniqueInput
  }


  /**
   * USER_REVIEW findFirst
   */
  export type USER_REVIEWFindFirstArgs = {
    /**
     * Select specific fields to fetch from the USER_REVIEW
    **/
    select?: USER_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USER_REVIEWInclude | null
    /**
     * Throw an Error if a USER_REVIEW can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which USER_REVIEW to fetch.
    **/
    where?: USER_REVIEWWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USER_REVIEWS to fetch.
    **/
    orderBy?: Enumerable<USER_REVIEWOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for USER_REVIEWS.
    **/
    cursor?: USER_REVIEWWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USER_REVIEWS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USER_REVIEWS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of USER_REVIEWS.
    **/
    distinct?: Enumerable<USER_REVIEWScalarFieldEnum>
  }


  /**
   * USER_REVIEW findMany
   */
  export type USER_REVIEWFindManyArgs = {
    /**
     * Select specific fields to fetch from the USER_REVIEW
    **/
    select?: USER_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USER_REVIEWInclude | null
    /**
     * Filter, which USER_REVIEWS to fetch.
    **/
    where?: USER_REVIEWWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of USER_REVIEWS to fetch.
    **/
    orderBy?: Enumerable<USER_REVIEWOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing USER_REVIEWS.
    **/
    cursor?: USER_REVIEWWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` USER_REVIEWS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` USER_REVIEWS.
    **/
    skip?: number
    distinct?: Enumerable<USER_REVIEWScalarFieldEnum>
  }


  /**
   * USER_REVIEW create
   */
  export type USER_REVIEWCreateArgs = {
    /**
     * Select specific fields to fetch from the USER_REVIEW
    **/
    select?: USER_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USER_REVIEWInclude | null
    /**
     * The data needed to create a USER_REVIEW.
    **/
    data: XOR<USER_REVIEWCreateInput, USER_REVIEWUncheckedCreateInput>
  }


  /**
   * USER_REVIEW createMany
   */
  export type USER_REVIEWCreateManyArgs = {
    data: Enumerable<USER_REVIEWCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * USER_REVIEW update
   */
  export type USER_REVIEWUpdateArgs = {
    /**
     * Select specific fields to fetch from the USER_REVIEW
    **/
    select?: USER_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USER_REVIEWInclude | null
    /**
     * The data needed to update a USER_REVIEW.
    **/
    data: XOR<USER_REVIEWUpdateInput, USER_REVIEWUncheckedUpdateInput>
    /**
     * Choose, which USER_REVIEW to update.
    **/
    where: USER_REVIEWWhereUniqueInput
  }


  /**
   * USER_REVIEW updateMany
   */
  export type USER_REVIEWUpdateManyArgs = {
    data: XOR<USER_REVIEWUpdateManyMutationInput, USER_REVIEWUncheckedUpdateManyInput>
    where?: USER_REVIEWWhereInput
  }


  /**
   * USER_REVIEW upsert
   */
  export type USER_REVIEWUpsertArgs = {
    /**
     * Select specific fields to fetch from the USER_REVIEW
    **/
    select?: USER_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USER_REVIEWInclude | null
    /**
     * The filter to search for the USER_REVIEW to update in case it exists.
    **/
    where: USER_REVIEWWhereUniqueInput
    /**
     * In case the USER_REVIEW found by the `where` argument doesn't exist, create a new USER_REVIEW with this data.
    **/
    create: XOR<USER_REVIEWCreateInput, USER_REVIEWUncheckedCreateInput>
    /**
     * In case the USER_REVIEW was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<USER_REVIEWUpdateInput, USER_REVIEWUncheckedUpdateInput>
  }


  /**
   * USER_REVIEW delete
   */
  export type USER_REVIEWDeleteArgs = {
    /**
     * Select specific fields to fetch from the USER_REVIEW
    **/
    select?: USER_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USER_REVIEWInclude | null
    /**
     * Filter which USER_REVIEW to delete.
    **/
    where: USER_REVIEWWhereUniqueInput
  }


  /**
   * USER_REVIEW deleteMany
   */
  export type USER_REVIEWDeleteManyArgs = {
    where?: USER_REVIEWWhereInput
  }


  /**
   * USER_REVIEW without action
   */
  export type USER_REVIEWArgs = {
    /**
     * Select specific fields to fetch from the USER_REVIEW
    **/
    select?: USER_REVIEWSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: USER_REVIEWInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CALLScalarFieldEnum: {
    seq: 'seq',
    createdAt: 'createdAt',
    expiredAt: 'expiredAt',
    status: 'status',
    calltext: 'calltext',
    price: 'price'
  };

  export type CALLScalarFieldEnum = (typeof CALLScalarFieldEnum)[keyof typeof CALLScalarFieldEnum]


  export const CARTScalarFieldEnum: {
    seq: 'seq',
    request: 'request'
  };

  export type CARTScalarFieldEnum = (typeof CARTScalarFieldEnum)[keyof typeof CARTScalarFieldEnum]


  export const CHATScalarFieldEnum: {
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CHATScalarFieldEnum = (typeof CHATScalarFieldEnum)[keyof typeof CHATScalarFieldEnum]


  export const LOCATIONScalarFieldEnum: {
    seq: 'seq',
    latitude: 'latitude',
    longitude: 'longitude',
    address: 'address'
  };

  export type LOCATIONScalarFieldEnum = (typeof LOCATIONScalarFieldEnum)[keyof typeof LOCATIONScalarFieldEnum]


  export const MENUScalarFieldEnum: {
    seq: 'seq',
    name: 'name',
    thumbnail: 'thumbnail',
    description: 'description',
    price: 'price',
    isAvailable: 'isAvailable',
    bestmenu: 'bestmenu'
  };

  export type MENUScalarFieldEnum = (typeof MENUScalarFieldEnum)[keyof typeof MENUScalarFieldEnum]


  export const MESSAGEScalarFieldEnum: {
    seq: 'seq',
    text: 'text',
    isRead: 'isRead',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MESSAGEScalarFieldEnum = (typeof MESSAGEScalarFieldEnum)[keyof typeof MESSAGEScalarFieldEnum]


  export const OPTIONScalarFieldEnum: {
    seq: 'seq',
    category: 'category',
    isRequired: 'isRequired',
    isMultiple: 'isMultiple'
  };

  export type OPTIONScalarFieldEnum = (typeof OPTIONScalarFieldEnum)[keyof typeof OPTIONScalarFieldEnum]


  export const OPTION_ITEMScalarFieldEnum: {
    seq: 'seq',
    content: 'content',
    price: 'price'
  };

  export type OPTION_ITEMScalarFieldEnum = (typeof OPTION_ITEMScalarFieldEnum)[keyof typeof OPTION_ITEMScalarFieldEnum]


  export const ORDERScalarFieldEnum: {
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deliveryTime: 'deliveryTime',
    status: 'status'
  };

  export type ORDERScalarFieldEnum = (typeof ORDERScalarFieldEnum)[keyof typeof ORDERScalarFieldEnum]


  export const REPLYScalarFieldEnum: {
    seq: 'seq',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type REPLYScalarFieldEnum = (typeof REPLYScalarFieldEnum)[keyof typeof REPLYScalarFieldEnum]


  export const REPORTScalarFieldEnum: {
    seq: 'seq',
    reason: 'reason',
    isSolved: 'isSolved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type REPORTScalarFieldEnum = (typeof REPORTScalarFieldEnum)[keyof typeof REPORTScalarFieldEnum]


  export const RES_REVIEWScalarFieldEnum: {
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    rate: 'rate',
    content: 'content',
    image: 'image'
  };

  export type RES_REVIEWScalarFieldEnum = (typeof RES_REVIEWScalarFieldEnum)[keyof typeof RES_REVIEWScalarFieldEnum]


  export const RESTAURANTScalarFieldEnum: {
    seq: 'seq',
    id: 'id',
    password: 'password',
    createdAt: 'createdAt',
    dayoff: 'dayoff',
    isOpen: 'isOpen',
    minOrder: 'minOrder',
    deliveryTip: 'deliveryTip',
    seperatable: 'seperatable',
    introduction: 'introduction',
    thumbnail: 'thumbnail',
    rate: 'rate',
    category: 'category'
  };

  export type RESTAURANTScalarFieldEnum = (typeof RESTAURANTScalarFieldEnum)[keyof typeof RESTAURANTScalarFieldEnum]


  export const RUN_TIMEScalarFieldEnum: {
    seq: 'seq',
    day: 'day',
    open: 'open',
    close: 'close'
  };

  export type RUN_TIMEScalarFieldEnum = (typeof RUN_TIMEScalarFieldEnum)[keyof typeof RUN_TIMEScalarFieldEnum]


  export const SELECTED_MENUScalarFieldEnum: {
    seq: 'seq',
    count: 'count'
  };

  export type SELECTED_MENUScalarFieldEnum = (typeof SELECTED_MENUScalarFieldEnum)[keyof typeof SELECTED_MENUScalarFieldEnum]


  export const USERScalarFieldEnum: {
    seq: 'seq',
    ID: 'ID',
    password: 'password',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    thumbnail: 'thumbnail',
    token: 'token',
    status: 'status'
  };

  export type USERScalarFieldEnum = (typeof USERScalarFieldEnum)[keyof typeof USERScalarFieldEnum]


  export const USER_REVIEWScalarFieldEnum: {
    seq: 'seq',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    rate: 'rate',
    content: 'content'
  };

  export type USER_REVIEWScalarFieldEnum = (typeof USER_REVIEWScalarFieldEnum)[keyof typeof USER_REVIEWScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type CALLWhereInput = {
    AND?: Enumerable<CALLWhereInput>
    OR?: Enumerable<CALLWhereInput>
    NOT?: Enumerable<CALLWhereInput>
    seq?: IntFilter | number
    createdAt?: DateTimeNullableFilter | Date | string | null
    expiredAt?: DateTimeNullableFilter | Date | string | null
    status?: EnumCALL_statusNullableFilter | CALL_status | null
    calltext?: StringNullableFilter | string | null
    price?: IntFilter | number
    RESTAURANT?: XOR<RESTAURANTRelationFilter, RESTAURANTWhereInput>
    LOCATION?: XOR<LOCATIONRelationFilter, LOCATIONWhereInput>
    USER?: XOR<USERRelationFilter, USERWhereInput>
    CART?: XOR<CARTRelationFilter, CARTWhereInput> | null
    ORDER?: XOR<ORDERRelationFilter, ORDERWhereInput> | null
  }

  export type CALLOrderByInput = {
    seq?: SortOrder
    createdAt?: SortOrder
    expiredAt?: SortOrder
    status?: SortOrder
    calltext?: SortOrder
    price?: SortOrder
  }

  export type CALLWhereUniqueInput = {
    seq?: number
  }

  export type CALLScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CALLScalarWhereWithAggregatesInput>
    OR?: Enumerable<CALLScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CALLScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    expiredAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    status?: EnumCALL_statusNullableWithAggregatesFilter | CALL_status | null
    calltext?: StringNullableWithAggregatesFilter | string | null
    price?: IntWithAggregatesFilter | number
  }

  export type CARTWhereInput = {
    AND?: Enumerable<CARTWhereInput>
    OR?: Enumerable<CARTWhereInput>
    NOT?: Enumerable<CARTWhereInput>
    seq?: IntFilter | number
    request?: StringNullableFilter | string | null
    CALL?: XOR<CALLRelationFilter, CALLWhereInput>
    SELECTED_MENU?: XOR<SELECTED_MENURelationFilter, SELECTED_MENUWhereInput>
    USER?: XOR<USERRelationFilter, USERWhereInput>
  }

  export type CARTOrderByInput = {
    seq?: SortOrder
    request?: SortOrder
  }

  export type CARTWhereUniqueInput = {
    seq?: number
  }

  export type CARTScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CARTScalarWhereWithAggregatesInput>
    OR?: Enumerable<CARTScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CARTScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    request?: StringNullableWithAggregatesFilter | string | null
  }

  export type CHATWhereInput = {
    AND?: Enumerable<CHATWhereInput>
    OR?: Enumerable<CHATWhereInput>
    NOT?: Enumerable<CHATWhereInput>
    seq?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    USER?: XOR<USERRelationFilter, USERWhereInput>
    MESSAGE_CHAT_seqToMESSAGE?: XOR<MESSAGERelationFilter, MESSAGEWhereInput>
    MESSAGE_CHATToMESSAGE_seq?: XOR<MESSAGERelationFilter, MESSAGEWhereInput> | null
  }

  export type CHATOrderByInput = {
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CHATWhereUniqueInput = {
    seq?: number
  }

  export type CHATScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CHATScalarWhereWithAggregatesInput>
    OR?: Enumerable<CHATScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CHATScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type LOCATIONWhereInput = {
    AND?: Enumerable<LOCATIONWhereInput>
    OR?: Enumerable<LOCATIONWhereInput>
    NOT?: Enumerable<LOCATIONWhereInput>
    seq?: IntFilter | number
    latitude?: FloatFilter | number
    longitude?: FloatFilter | number
    address?: StringFilter | string
    CALL?: XOR<CALLRelationFilter, CALLWhereInput> | null
    RESTAURANT?: XOR<RESTAURANTRelationFilter, RESTAURANTWhereInput> | null
  }

  export type LOCATIONOrderByInput = {
    seq?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    address?: SortOrder
  }

  export type LOCATIONWhereUniqueInput = {
    seq?: number
  }

  export type LOCATIONScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LOCATIONScalarWhereWithAggregatesInput>
    OR?: Enumerable<LOCATIONScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LOCATIONScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    latitude?: FloatWithAggregatesFilter | number
    longitude?: FloatWithAggregatesFilter | number
    address?: StringWithAggregatesFilter | string
  }

  export type MENUWhereInput = {
    AND?: Enumerable<MENUWhereInput>
    OR?: Enumerable<MENUWhereInput>
    NOT?: Enumerable<MENUWhereInput>
    seq?: IntFilter | number
    name?: StringFilter | string
    thumbnail?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    price?: IntFilter | number
    isAvailable?: BoolFilter | boolean
    bestmenu?: BoolFilter | boolean
    RESTAURANT?: XOR<RESTAURANTRelationFilter, RESTAURANTWhereInput>
    OPTION?: XOR<OPTIONRelationFilter, OPTIONWhereInput> | null
    SELECTED_MENU?: XOR<SELECTED_MENURelationFilter, SELECTED_MENUWhereInput> | null
  }

  export type MENUOrderByInput = {
    seq?: SortOrder
    name?: SortOrder
    thumbnail?: SortOrder
    description?: SortOrder
    price?: SortOrder
    isAvailable?: SortOrder
    bestmenu?: SortOrder
  }

  export type MENUWhereUniqueInput = {
    seq?: number
  }

  export type MENUScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MENUScalarWhereWithAggregatesInput>
    OR?: Enumerable<MENUScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MENUScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    thumbnail?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
    price?: IntWithAggregatesFilter | number
    isAvailable?: BoolWithAggregatesFilter | boolean
    bestmenu?: BoolWithAggregatesFilter | boolean
  }

  export type MESSAGEWhereInput = {
    AND?: Enumerable<MESSAGEWhereInput>
    OR?: Enumerable<MESSAGEWhereInput>
    NOT?: Enumerable<MESSAGEWhereInput>
    seq?: IntFilter | number
    text?: StringFilter | string
    isRead?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    USER?: XOR<USERRelationFilter, USERWhereInput>
    CHAT_CHATToMESSAGE_seq?: XOR<CHATRelationFilter, CHATWhereInput>
    CHAT_CHAT_seqToMESSAGE?: XOR<CHATRelationFilter, CHATWhereInput> | null
  }

  export type MESSAGEOrderByInput = {
    seq?: SortOrder
    text?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MESSAGEWhereUniqueInput = {
    seq?: number
  }

  export type MESSAGEScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MESSAGEScalarWhereWithAggregatesInput>
    OR?: Enumerable<MESSAGEScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MESSAGEScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    text?: StringWithAggregatesFilter | string
    isRead?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type OPTIONWhereInput = {
    AND?: Enumerable<OPTIONWhereInput>
    OR?: Enumerable<OPTIONWhereInput>
    NOT?: Enumerable<OPTIONWhereInput>
    seq?: IntFilter | number
    category?: StringFilter | string
    isRequired?: BoolFilter | boolean
    isMultiple?: BoolFilter | boolean
    MENU?: XOR<MENURelationFilter, MENUWhereInput>
    OPTION_ITEM?: XOR<OPTION_ITEMRelationFilter, OPTION_ITEMWhereInput> | null
  }

  export type OPTIONOrderByInput = {
    seq?: SortOrder
    category?: SortOrder
    isRequired?: SortOrder
    isMultiple?: SortOrder
  }

  export type OPTIONWhereUniqueInput = {
    seq?: number
  }

  export type OPTIONScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OPTIONScalarWhereWithAggregatesInput>
    OR?: Enumerable<OPTIONScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OPTIONScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    category?: StringWithAggregatesFilter | string
    isRequired?: BoolWithAggregatesFilter | boolean
    isMultiple?: BoolWithAggregatesFilter | boolean
  }

  export type OPTION_ITEMWhereInput = {
    AND?: Enumerable<OPTION_ITEMWhereInput>
    OR?: Enumerable<OPTION_ITEMWhereInput>
    NOT?: Enumerable<OPTION_ITEMWhereInput>
    seq?: IntFilter | number
    content?: StringFilter | string
    price?: IntFilter | number
    OPTION?: XOR<OPTIONRelationFilter, OPTIONWhereInput>
    SELECTED_MENU?: XOR<SELECTED_MENURelationFilter, SELECTED_MENUWhereInput> | null
  }

  export type OPTION_ITEMOrderByInput = {
    seq?: SortOrder
    content?: SortOrder
    price?: SortOrder
  }

  export type OPTION_ITEMWhereUniqueInput = {
    seq?: number
  }

  export type OPTION_ITEMScalarWhereWithAggregatesInput = {
    AND?: Enumerable<OPTION_ITEMScalarWhereWithAggregatesInput>
    OR?: Enumerable<OPTION_ITEMScalarWhereWithAggregatesInput>
    NOT?: Enumerable<OPTION_ITEMScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
    price?: IntWithAggregatesFilter | number
  }

  export type ORDERWhereInput = {
    AND?: Enumerable<ORDERWhereInput>
    OR?: Enumerable<ORDERWhereInput>
    NOT?: Enumerable<ORDERWhereInput>
    seq?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    deliveryTime?: DateTimeFilter | Date | string
    status?: EnumORDER_statusNullableFilter | ORDER_status | null
    RES_REVIEW?: XOR<RES_REVIEWRelationFilter, RES_REVIEWWhereInput>
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: XOR<USER_REVIEWRelationFilter, USER_REVIEWWhereInput>
    CALL?: XOR<CALLRelationFilter, CALLWhereInput>
    USER?: XOR<USERRelationFilter, USERWhereInput>
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: XOR<USER_REVIEWRelationFilter, USER_REVIEWWhereInput> | null
  }

  export type ORDEROrderByInput = {
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deliveryTime?: SortOrder
    status?: SortOrder
  }

  export type ORDERWhereUniqueInput = {
    seq?: number
  }

  export type ORDERScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ORDERScalarWhereWithAggregatesInput>
    OR?: Enumerable<ORDERScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ORDERScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    deliveryTime?: DateTimeWithAggregatesFilter | Date | string
    status?: EnumORDER_statusNullableWithAggregatesFilter | ORDER_status | null
  }

  export type REPLYWhereInput = {
    AND?: Enumerable<REPLYWhereInput>
    OR?: Enumerable<REPLYWhereInput>
    NOT?: Enumerable<REPLYWhereInput>
    seq?: IntFilter | number
    content?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    RESTAURANT?: XOR<RESTAURANTRelationFilter, RESTAURANTWhereInput>
    RES_REVIEW?: XOR<RES_REVIEWRelationFilter, RES_REVIEWWhereInput> | null
  }

  export type REPLYOrderByInput = {
    seq?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type REPLYWhereUniqueInput = {
    seq?: number
  }

  export type REPLYScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REPLYScalarWhereWithAggregatesInput>
    OR?: Enumerable<REPLYScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REPLYScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type REPORTWhereInput = {
    AND?: Enumerable<REPORTWhereInput>
    OR?: Enumerable<REPORTWhereInput>
    NOT?: Enumerable<REPORTWhereInput>
    seq?: IntFilter | number
    reason?: StringFilter | string
    isSolved?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    USER?: XOR<USERRelationFilter, USERWhereInput>
  }

  export type REPORTOrderByInput = {
    seq?: SortOrder
    reason?: SortOrder
    isSolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type REPORTWhereUniqueInput = {
    seq?: number
  }

  export type REPORTScalarWhereWithAggregatesInput = {
    AND?: Enumerable<REPORTScalarWhereWithAggregatesInput>
    OR?: Enumerable<REPORTScalarWhereWithAggregatesInput>
    NOT?: Enumerable<REPORTScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    reason?: StringWithAggregatesFilter | string
    isSolved?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
  }

  export type RES_REVIEWWhereInput = {
    AND?: Enumerable<RES_REVIEWWhereInput>
    OR?: Enumerable<RES_REVIEWWhereInput>
    NOT?: Enumerable<RES_REVIEWWhereInput>
    seq?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    rate?: FloatFilter | number
    content?: StringFilter | string
    image?: StringNullableFilter | string | null
    RESTAURANT?: XOR<RESTAURANTRelationFilter, RESTAURANTWhereInput>
    REPLY?: XOR<REPLYRelationFilter, REPLYWhereInput>
    USER?: XOR<USERRelationFilter, USERWhereInput>
    ORDER?: XOR<ORDERRelationFilter, ORDERWhereInput> | null
  }

  export type RES_REVIEWOrderByInput = {
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rate?: SortOrder
    content?: SortOrder
    image?: SortOrder
  }

  export type RES_REVIEWWhereUniqueInput = {
    seq?: number
  }

  export type RES_REVIEWScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RES_REVIEWScalarWhereWithAggregatesInput>
    OR?: Enumerable<RES_REVIEWScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RES_REVIEWScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    rate?: FloatWithAggregatesFilter | number
    content?: StringWithAggregatesFilter | string
    image?: StringNullableWithAggregatesFilter | string | null
  }

  export type RESTAURANTWhereInput = {
    AND?: Enumerable<RESTAURANTWhereInput>
    OR?: Enumerable<RESTAURANTWhereInput>
    NOT?: Enumerable<RESTAURANTWhereInput>
    seq?: IntFilter | number
    id?: StringFilter | string
    password?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    dayoff?: StringFilter | string
    isOpen?: BoolFilter | boolean
    minOrder?: IntFilter | number
    deliveryTip?: IntFilter | number
    seperatable?: BoolFilter | boolean
    introduction?: StringNullableFilter | string | null
    thumbnail?: StringNullableFilter | string | null
    rate?: FloatFilter | number
    category?: StringFilter | string
    LOCATION?: XOR<LOCATIONRelationFilter, LOCATIONWhereInput>
    RUN_TIME?: XOR<RUN_TIMERelationFilter, RUN_TIMEWhereInput>
    CALL?: XOR<CALLRelationFilter, CALLWhereInput> | null
    MENU?: XOR<MENURelationFilter, MENUWhereInput> | null
    REPLY?: XOR<REPLYRelationFilter, REPLYWhereInput> | null
    RES_REVIEW?: XOR<RES_REVIEWRelationFilter, RES_REVIEWWhereInput> | null
  }

  export type RESTAURANTOrderByInput = {
    seq?: SortOrder
    id?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    dayoff?: SortOrder
    isOpen?: SortOrder
    minOrder?: SortOrder
    deliveryTip?: SortOrder
    seperatable?: SortOrder
    introduction?: SortOrder
    thumbnail?: SortOrder
    rate?: SortOrder
    category?: SortOrder
  }

  export type RESTAURANTWhereUniqueInput = {
    seq?: number
  }

  export type RESTAURANTScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RESTAURANTScalarWhereWithAggregatesInput>
    OR?: Enumerable<RESTAURANTScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RESTAURANTScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    id?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    dayoff?: StringWithAggregatesFilter | string
    isOpen?: BoolWithAggregatesFilter | boolean
    minOrder?: IntWithAggregatesFilter | number
    deliveryTip?: IntWithAggregatesFilter | number
    seperatable?: BoolWithAggregatesFilter | boolean
    introduction?: StringNullableWithAggregatesFilter | string | null
    thumbnail?: StringNullableWithAggregatesFilter | string | null
    rate?: FloatWithAggregatesFilter | number
    category?: StringWithAggregatesFilter | string
  }

  export type RUN_TIMEWhereInput = {
    AND?: Enumerable<RUN_TIMEWhereInput>
    OR?: Enumerable<RUN_TIMEWhereInput>
    NOT?: Enumerable<RUN_TIMEWhereInput>
    seq?: IntFilter | number
    day?: StringFilter | string
    open?: DateTimeFilter | Date | string
    close?: DateTimeFilter | Date | string
    RESTAURANT?: XOR<RESTAURANTRelationFilter, RESTAURANTWhereInput> | null
  }

  export type RUN_TIMEOrderByInput = {
    seq?: SortOrder
    day?: SortOrder
    open?: SortOrder
    close?: SortOrder
  }

  export type RUN_TIMEWhereUniqueInput = {
    seq?: number
  }

  export type RUN_TIMEScalarWhereWithAggregatesInput = {
    AND?: Enumerable<RUN_TIMEScalarWhereWithAggregatesInput>
    OR?: Enumerable<RUN_TIMEScalarWhereWithAggregatesInput>
    NOT?: Enumerable<RUN_TIMEScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    day?: StringWithAggregatesFilter | string
    open?: DateTimeWithAggregatesFilter | Date | string
    close?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SELECTED_MENUWhereInput = {
    AND?: Enumerable<SELECTED_MENUWhereInput>
    OR?: Enumerable<SELECTED_MENUWhereInput>
    NOT?: Enumerable<SELECTED_MENUWhereInput>
    seq?: IntFilter | number
    count?: IntFilter | number
    OPTION_ITEM?: XOR<OPTION_ITEMRelationFilter, OPTION_ITEMWhereInput>
    MENU?: XOR<MENURelationFilter, MENUWhereInput>
    CART?: XOR<CARTRelationFilter, CARTWhereInput> | null
  }

  export type SELECTED_MENUOrderByInput = {
    seq?: SortOrder
    count?: SortOrder
  }

  export type SELECTED_MENUWhereUniqueInput = {
    seq?: number
  }

  export type SELECTED_MENUScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SELECTED_MENUScalarWhereWithAggregatesInput>
    OR?: Enumerable<SELECTED_MENUScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SELECTED_MENUScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    count?: IntWithAggregatesFilter | number
  }

  export type USERWhereInput = {
    AND?: Enumerable<USERWhereInput>
    OR?: Enumerable<USERWhereInput>
    NOT?: Enumerable<USERWhereInput>
    seq?: IntFilter | number
    ID?: StringFilter | string
    password?: StringFilter | string
    name?: StringFilter | string
    createdAt?: DateTimeNullableFilter | Date | string | null
    updatedAt?: DateTimeNullableFilter | Date | string | null
    thumbnail?: StringNullableFilter | string | null
    token?: StringFilter | string
    status?: EnumUSER_statusFilter | USER_status
    CALL?: XOR<CALLRelationFilter, CALLWhereInput> | null
    CART?: XOR<CARTRelationFilter, CARTWhereInput> | null
    CHAT?: XOR<CHATRelationFilter, CHATWhereInput> | null
    MESSAGE?: XOR<MESSAGERelationFilter, MESSAGEWhereInput> | null
    ORDER?: XOR<ORDERRelationFilter, ORDERWhereInput> | null
    REPORT?: XOR<REPORTRelationFilter, REPORTWhereInput> | null
    RES_REVIEW?: XOR<RES_REVIEWRelationFilter, RES_REVIEWWhereInput> | null
    USER_REVIEW?: XOR<USER_REVIEWRelationFilter, USER_REVIEWWhereInput> | null
  }

  export type USEROrderByInput = {
    seq?: SortOrder
    ID?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thumbnail?: SortOrder
    token?: SortOrder
    status?: SortOrder
  }

  export type USERWhereUniqueInput = {
    seq?: number
  }

  export type USERScalarWhereWithAggregatesInput = {
    AND?: Enumerable<USERScalarWhereWithAggregatesInput>
    OR?: Enumerable<USERScalarWhereWithAggregatesInput>
    NOT?: Enumerable<USERScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    ID?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    createdAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    thumbnail?: StringNullableWithAggregatesFilter | string | null
    token?: StringWithAggregatesFilter | string
    status?: EnumUSER_statusWithAggregatesFilter | USER_status
  }

  export type USER_REVIEWWhereInput = {
    AND?: Enumerable<USER_REVIEWWhereInput>
    OR?: Enumerable<USER_REVIEWWhereInput>
    NOT?: Enumerable<USER_REVIEWWhereInput>
    seq?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeNullableFilter | Date | string | null
    rate?: IntFilter | number
    content?: StringNullableFilter | string | null
    ORDER_ORDERToUSER_REVIEW_seq?: XOR<ORDERRelationFilter, ORDERWhereInput>
    USER?: XOR<USERRelationFilter, USERWhereInput>
    ORDER_ORDER_seqToUSER_REVIEW?: XOR<ORDERRelationFilter, ORDERWhereInput> | null
  }

  export type USER_REVIEWOrderByInput = {
    seq?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rate?: SortOrder
    content?: SortOrder
  }

  export type USER_REVIEWWhereUniqueInput = {
    seq?: number
  }

  export type USER_REVIEWScalarWhereWithAggregatesInput = {
    AND?: Enumerable<USER_REVIEWScalarWhereWithAggregatesInput>
    OR?: Enumerable<USER_REVIEWScalarWhereWithAggregatesInput>
    NOT?: Enumerable<USER_REVIEWScalarWhereWithAggregatesInput>
    seq?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeNullableWithAggregatesFilter | Date | string | null
    rate?: IntWithAggregatesFilter | number
    content?: StringNullableWithAggregatesFilter | string | null
  }

  export type CALLCreateInput = {
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutCALLInput
    LOCATION?: LOCATIONCreateNestedOneWithoutCALLInput
    USER?: USERCreateNestedOneWithoutCALLInput
    CART?: CARTCreateNestedOneWithoutCALLInput
    ORDER?: ORDERCreateNestedOneWithoutCALLInput
  }

  export type CALLUncheckedCreateInput = {
    seq?: number
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
    CART?: CARTUncheckedCreateNestedOneWithoutCALLInput
    ORDER?: ORDERUncheckedCreateNestedOneWithoutCALLInput
  }

  export type CALLUpdateInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutCALLInput
    LOCATION?: LOCATIONUpdateOneRequiredWithoutCALLInput
    USER?: USERUpdateOneRequiredWithoutCALLInput
    CART?: CARTUpdateOneWithoutCALLInput
    ORDER?: ORDERUpdateOneWithoutCALLInput
  }

  export type CALLUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    CART?: CARTUncheckedUpdateOneWithoutCALLInput
    ORDER?: ORDERUncheckedUpdateOneWithoutCALLInput
  }

  export type CALLCreateManyInput = {
    seq?: number
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
  }

  export type CALLUpdateManyMutationInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
  }

  export type CALLUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
  }

  export type CARTCreateInput = {
    request?: string | null
    CALL?: CALLCreateNestedOneWithoutCARTInput
    SELECTED_MENU?: SELECTED_MENUCreateNestedOneWithoutCARTInput
    USER?: USERCreateNestedOneWithoutCARTInput
  }

  export type CARTUncheckedCreateInput = {
    seq?: number
    request?: string | null
  }

  export type CARTUpdateInput = {
    request?: NullableStringFieldUpdateOperationsInput | string | null
    CALL?: CALLUpdateOneRequiredWithoutCARTInput
    SELECTED_MENU?: SELECTED_MENUUpdateOneRequiredWithoutCARTInput
    USER?: USERUpdateOneRequiredWithoutCARTInput
  }

  export type CARTUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    request?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CARTCreateManyInput = {
    seq?: number
    request?: string | null
  }

  export type CARTUpdateManyMutationInput = {
    request?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CARTUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    request?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CHATCreateInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    USER?: USERCreateNestedOneWithoutCHATInput
    MESSAGE_CHAT_seqToMESSAGE?: MESSAGECreateNestedOneWithoutCHAT_CHAT_seqToMESSAGEInput
    MESSAGE_CHATToMESSAGE_seq?: MESSAGECreateNestedOneWithoutCHAT_CHATToMESSAGE_seqInput
  }

  export type CHATUncheckedCreateInput = {
    seq?: number
    createdAt: Date | string
    updatedAt?: Date | string | null
    MESSAGE_CHATToMESSAGE_seq?: MESSAGEUncheckedCreateNestedOneWithoutCHAT_CHATToMESSAGE_seqInput
  }

  export type CHATUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    USER?: USERUpdateOneRequiredWithoutCHATInput
    MESSAGE_CHAT_seqToMESSAGE?: MESSAGEUpdateOneRequiredWithoutCHAT_CHAT_seqToMESSAGEInput
    MESSAGE_CHATToMESSAGE_seq?: MESSAGEUpdateOneWithoutCHAT_CHATToMESSAGE_seqInput
  }

  export type CHATUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MESSAGE_CHATToMESSAGE_seq?: MESSAGEUncheckedUpdateOneWithoutCHAT_CHATToMESSAGE_seqInput
  }

  export type CHATCreateManyInput = {
    seq?: number
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type CHATUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CHATUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LOCATIONCreateInput = {
    latitude: number
    longitude: number
    address: string
    CALL?: CALLCreateNestedOneWithoutLOCATIONInput
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutLOCATIONInput
  }

  export type LOCATIONUncheckedCreateInput = {
    seq?: number
    latitude: number
    longitude: number
    address: string
    CALL?: CALLUncheckedCreateNestedOneWithoutLOCATIONInput
    RESTAURANT?: RESTAURANTUncheckedCreateNestedOneWithoutLOCATIONInput
  }

  export type LOCATIONUpdateInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    CALL?: CALLUpdateOneWithoutLOCATIONInput
    RESTAURANT?: RESTAURANTUpdateOneWithoutLOCATIONInput
  }

  export type LOCATIONUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    CALL?: CALLUncheckedUpdateOneWithoutLOCATIONInput
    RESTAURANT?: RESTAURANTUncheckedUpdateOneWithoutLOCATIONInput
  }

  export type LOCATIONCreateManyInput = {
    seq?: number
    latitude: number
    longitude: number
    address: string
  }

  export type LOCATIONUpdateManyMutationInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
  }

  export type LOCATIONUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
  }

  export type MENUCreateInput = {
    name: string
    thumbnail?: string | null
    description?: string | null
    price: number
    isAvailable?: boolean
    bestmenu?: boolean
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutMENUInput
    OPTION?: OPTIONCreateNestedOneWithoutMENUInput
    SELECTED_MENU?: SELECTED_MENUCreateNestedOneWithoutMENUInput
  }

  export type MENUUncheckedCreateInput = {
    seq?: number
    name: string
    thumbnail?: string | null
    description?: string | null
    price: number
    isAvailable?: boolean
    bestmenu?: boolean
    OPTION?: OPTIONUncheckedCreateNestedOneWithoutMENUInput
    SELECTED_MENU?: SELECTED_MENUUncheckedCreateNestedOneWithoutMENUInput
  }

  export type MENUUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bestmenu?: BoolFieldUpdateOperationsInput | boolean
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutMENUInput
    OPTION?: OPTIONUpdateOneWithoutMENUInput
    SELECTED_MENU?: SELECTED_MENUUpdateOneWithoutMENUInput
  }

  export type MENUUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bestmenu?: BoolFieldUpdateOperationsInput | boolean
    OPTION?: OPTIONUncheckedUpdateOneWithoutMENUInput
    SELECTED_MENU?: SELECTED_MENUUncheckedUpdateOneWithoutMENUInput
  }

  export type MENUCreateManyInput = {
    seq?: number
    name: string
    thumbnail?: string | null
    description?: string | null
    price: number
    isAvailable?: boolean
    bestmenu?: boolean
  }

  export type MENUUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bestmenu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MENUUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bestmenu?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MESSAGECreateInput = {
    text: string
    isRead?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
    USER?: USERCreateNestedOneWithoutMESSAGEInput
    CHAT_CHATToMESSAGE_seq?: CHATCreateNestedOneWithoutMESSAGE_CHATToMESSAGE_seqInput
    CHAT_CHAT_seqToMESSAGE?: CHATCreateNestedOneWithoutMESSAGE_CHAT_seqToMESSAGEInput
  }

  export type MESSAGEUncheckedCreateInput = {
    seq?: number
    text: string
    isRead?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
    CHAT_CHAT_seqToMESSAGE?: CHATUncheckedCreateNestedOneWithoutMESSAGE_CHAT_seqToMESSAGEInput
  }

  export type MESSAGEUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    USER?: USERUpdateOneRequiredWithoutMESSAGEInput
    CHAT_CHATToMESSAGE_seq?: CHATUpdateOneRequiredWithoutMESSAGE_CHATToMESSAGE_seqInput
    CHAT_CHAT_seqToMESSAGE?: CHATUpdateOneWithoutMESSAGE_CHAT_seqToMESSAGEInput
  }

  export type MESSAGEUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CHAT_CHAT_seqToMESSAGE?: CHATUncheckedUpdateOneWithoutMESSAGE_CHAT_seqToMESSAGEInput
  }

  export type MESSAGECreateManyInput = {
    seq?: number
    text: string
    isRead?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type MESSAGEUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MESSAGEUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OPTIONCreateInput = {
    category: string
    isRequired: boolean
    isMultiple: boolean
    MENU?: MENUCreateNestedOneWithoutOPTIONInput
    OPTION_ITEM?: OPTION_ITEMCreateNestedOneWithoutOPTIONInput
  }

  export type OPTIONUncheckedCreateInput = {
    seq?: number
    category: string
    isRequired: boolean
    isMultiple: boolean
    OPTION_ITEM?: OPTION_ITEMUncheckedCreateNestedOneWithoutOPTIONInput
  }

  export type OPTIONUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    MENU?: MENUUpdateOneRequiredWithoutOPTIONInput
    OPTION_ITEM?: OPTION_ITEMUpdateOneWithoutOPTIONInput
  }

  export type OPTIONUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    OPTION_ITEM?: OPTION_ITEMUncheckedUpdateOneWithoutOPTIONInput
  }

  export type OPTIONCreateManyInput = {
    seq?: number
    category: string
    isRequired: boolean
    isMultiple: boolean
  }

  export type OPTIONUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OPTIONUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OPTION_ITEMCreateInput = {
    content: string
    price: number
    OPTION?: OPTIONCreateNestedOneWithoutOPTION_ITEMInput
    SELECTED_MENU?: SELECTED_MENUCreateNestedOneWithoutOPTION_ITEMInput
  }

  export type OPTION_ITEMUncheckedCreateInput = {
    seq?: number
    content: string
    price: number
    SELECTED_MENU?: SELECTED_MENUUncheckedCreateNestedOneWithoutOPTION_ITEMInput
  }

  export type OPTION_ITEMUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    OPTION?: OPTIONUpdateOneRequiredWithoutOPTION_ITEMInput
    SELECTED_MENU?: SELECTED_MENUUpdateOneWithoutOPTION_ITEMInput
  }

  export type OPTION_ITEMUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    SELECTED_MENU?: SELECTED_MENUUncheckedUpdateOneWithoutOPTION_ITEMInput
  }

  export type OPTION_ITEMCreateManyInput = {
    seq?: number
    content: string
    price: number
  }

  export type OPTION_ITEMUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type OPTION_ITEMUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type ORDERCreateInput = {
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutORDERInput
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: USER_REVIEWCreateNestedOneWithoutORDER_ORDER_seqToUSER_REVIEWInput
    CALL?: CALLCreateNestedOneWithoutORDERInput
    USER?: USERCreateNestedOneWithoutORDERInput
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWCreateNestedOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERUncheckedCreateInput = {
    seq?: number
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUncheckedCreateNestedOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
    RES_REVIEW?: RES_REVIEWUpdateOneRequiredWithoutORDERInput
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: USER_REVIEWUpdateOneRequiredWithoutORDER_ORDER_seqToUSER_REVIEWInput
    CALL?: CALLUpdateOneRequiredWithoutORDERInput
    USER?: USERUpdateOneRequiredWithoutORDERInput
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUpdateOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUncheckedUpdateOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERCreateManyInput = {
    seq?: number
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
  }

  export type ORDERUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
  }

  export type ORDERUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
  }

  export type REPLYCreateInput = {
    content: string
    createdAt: Date | string
    updatedAt?: Date | string | null
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutREPLYInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutREPLYInput
  }

  export type REPLYUncheckedCreateInput = {
    seq?: number
    content: string
    createdAt: Date | string
    updatedAt?: Date | string | null
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutREPLYInput
  }

  export type REPLYUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutREPLYInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutREPLYInput
  }

  export type REPLYUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutREPLYInput
  }

  export type REPLYCreateManyInput = {
    seq?: number
    content: string
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type REPLYUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type REPLYUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type REPORTCreateInput = {
    reason: string
    isSolved?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
    USER?: USERCreateNestedOneWithoutREPORTInput
  }

  export type REPORTUncheckedCreateInput = {
    seq?: number
    reason: string
    isSolved?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type REPORTUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    USER?: USERUpdateOneRequiredWithoutREPORTInput
  }

  export type REPORTUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type REPORTCreateManyInput = {
    seq?: number
    reason: string
    isSolved?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type REPORTUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type REPORTUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RES_REVIEWCreateInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content: string
    image?: string | null
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutRES_REVIEWInput
    REPLY?: REPLYCreateNestedOneWithoutRES_REVIEWInput
    USER?: USERCreateNestedOneWithoutRES_REVIEWInput
    ORDER?: ORDERCreateNestedOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWUncheckedCreateInput = {
    seq?: number
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content: string
    image?: string | null
    ORDER?: ORDERUncheckedCreateNestedOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutRES_REVIEWInput
    REPLY?: REPLYUpdateOneRequiredWithoutRES_REVIEWInput
    USER?: USERUpdateOneRequiredWithoutRES_REVIEWInput
    ORDER?: ORDERUpdateOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    ORDER?: ORDERUncheckedUpdateOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWCreateManyInput = {
    seq?: number
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content: string
    image?: string | null
  }

  export type RES_REVIEWUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RES_REVIEWUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RESTAURANTCreateInput = {
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    LOCATION?: LOCATIONCreateNestedOneWithoutRESTAURANTInput
    RUN_TIME?: RUN_TIMECreateNestedOneWithoutRESTAURANTInput
    CALL?: CALLCreateNestedOneWithoutRESTAURANTInput
    MENU?: MENUCreateNestedOneWithoutRESTAURANTInput
    REPLY?: REPLYCreateNestedOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedCreateInput = {
    seq?: number
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    CALL?: CALLUncheckedCreateNestedOneWithoutRESTAURANTInput
    MENU?: MENUUncheckedCreateNestedOneWithoutRESTAURANTInput
    REPLY?: REPLYUncheckedCreateNestedOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    LOCATION?: LOCATIONUpdateOneRequiredWithoutRESTAURANTInput
    RUN_TIME?: RUN_TIMEUpdateOneRequiredWithoutRESTAURANTInput
    CALL?: CALLUpdateOneWithoutRESTAURANTInput
    MENU?: MENUUpdateOneWithoutRESTAURANTInput
    REPLY?: REPLYUpdateOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    CALL?: CALLUncheckedUpdateOneWithoutRESTAURANTInput
    MENU?: MENUUncheckedUpdateOneWithoutRESTAURANTInput
    REPLY?: REPLYUncheckedUpdateOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutRESTAURANTInput
  }

  export type RESTAURANTCreateManyInput = {
    seq?: number
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
  }

  export type RESTAURANTUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type RESTAURANTUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
  }

  export type RUN_TIMECreateInput = {
    day: string
    open: Date | string
    close: Date | string
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutRUN_TIMEInput
  }

  export type RUN_TIMEUncheckedCreateInput = {
    seq?: number
    day: string
    open: Date | string
    close: Date | string
    RESTAURANT?: RESTAURANTUncheckedCreateNestedOneWithoutRUN_TIMEInput
  }

  export type RUN_TIMEUpdateInput = {
    day?: StringFieldUpdateOperationsInput | string
    open?: DateTimeFieldUpdateOperationsInput | Date | string
    close?: DateTimeFieldUpdateOperationsInput | Date | string
    RESTAURANT?: RESTAURANTUpdateOneWithoutRUN_TIMEInput
  }

  export type RUN_TIMEUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    open?: DateTimeFieldUpdateOperationsInput | Date | string
    close?: DateTimeFieldUpdateOperationsInput | Date | string
    RESTAURANT?: RESTAURANTUncheckedUpdateOneWithoutRUN_TIMEInput
  }

  export type RUN_TIMECreateManyInput = {
    seq?: number
    day: string
    open: Date | string
    close: Date | string
  }

  export type RUN_TIMEUpdateManyMutationInput = {
    day?: StringFieldUpdateOperationsInput | string
    open?: DateTimeFieldUpdateOperationsInput | Date | string
    close?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RUN_TIMEUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    open?: DateTimeFieldUpdateOperationsInput | Date | string
    close?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SELECTED_MENUCreateInput = {
    count?: number
    OPTION_ITEM?: OPTION_ITEMCreateNestedOneWithoutSELECTED_MENUInput
    MENU?: MENUCreateNestedOneWithoutSELECTED_MENUInput
    CART?: CARTCreateNestedOneWithoutSELECTED_MENUInput
  }

  export type SELECTED_MENUUncheckedCreateInput = {
    seq?: number
    count?: number
    CART?: CARTUncheckedCreateNestedOneWithoutSELECTED_MENUInput
  }

  export type SELECTED_MENUUpdateInput = {
    count?: IntFieldUpdateOperationsInput | number
    OPTION_ITEM?: OPTION_ITEMUpdateOneRequiredWithoutSELECTED_MENUInput
    MENU?: MENUUpdateOneRequiredWithoutSELECTED_MENUInput
    CART?: CARTUpdateOneWithoutSELECTED_MENUInput
  }

  export type SELECTED_MENUUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
    CART?: CARTUncheckedUpdateOneWithoutSELECTED_MENUInput
  }

  export type SELECTED_MENUCreateManyInput = {
    seq?: number
    count?: number
  }

  export type SELECTED_MENUUpdateManyMutationInput = {
    count?: IntFieldUpdateOperationsInput | number
  }

  export type SELECTED_MENUUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type USERCreateInput = {
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLCreateNestedOneWithoutUSERInput
    CART?: CARTCreateNestedOneWithoutUSERInput
    CHAT?: CHATCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGECreateNestedOneWithoutUSERInput
    ORDER?: ORDERCreateNestedOneWithoutUSERInput
    REPORT?: REPORTCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWCreateNestedOneWithoutUSERInput
  }

  export type USERUncheckedCreateInput = {
    seq?: number
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLUncheckedCreateNestedOneWithoutUSERInput
    CART?: CARTUncheckedCreateNestedOneWithoutUSERInput
    CHAT?: CHATUncheckedCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedCreateNestedOneWithoutUSERInput
    ORDER?: ORDERUncheckedCreateNestedOneWithoutUSERInput
    REPORT?: REPORTUncheckedCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedCreateNestedOneWithoutUSERInput
  }

  export type USERUpdateInput = {
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUpdateOneWithoutUSERInput
    CART?: CARTUpdateOneWithoutUSERInput
    CHAT?: CHATUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUpdateOneWithoutUSERInput
    ORDER?: ORDERUpdateOneWithoutUSERInput
    REPORT?: REPORTUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUpdateOneWithoutUSERInput
  }

  export type USERUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUncheckedUpdateOneWithoutUSERInput
    CART?: CARTUncheckedUpdateOneWithoutUSERInput
    CHAT?: CHATUncheckedUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedUpdateOneWithoutUSERInput
    ORDER?: ORDERUncheckedUpdateOneWithoutUSERInput
    REPORT?: REPORTUncheckedUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedUpdateOneWithoutUSERInput
  }

  export type USERCreateManyInput = {
    seq?: number
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
  }

  export type USERUpdateManyMutationInput = {
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
  }

  export type USERUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
  }

  export type USER_REVIEWCreateInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content?: string | null
    ORDER_ORDERToUSER_REVIEW_seq?: ORDERCreateNestedOneWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput
    USER?: USERCreateNestedOneWithoutUSER_REVIEWInput
    ORDER_ORDER_seqToUSER_REVIEW?: ORDERCreateNestedOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
  }

  export type USER_REVIEWUncheckedCreateInput = {
    seq?: number
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content?: string | null
    ORDER_ORDER_seqToUSER_REVIEW?: ORDERUncheckedCreateNestedOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
  }

  export type USER_REVIEWUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ORDER_ORDERToUSER_REVIEW_seq?: ORDERUpdateOneRequiredWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput
    USER?: USERUpdateOneRequiredWithoutUSER_REVIEWInput
    ORDER_ORDER_seqToUSER_REVIEW?: ORDERUpdateOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
  }

  export type USER_REVIEWUncheckedUpdateInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ORDER_ORDER_seqToUSER_REVIEW?: ORDERUncheckedUpdateOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
  }

  export type USER_REVIEWCreateManyInput = {
    seq?: number
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content?: string | null
  }

  export type USER_REVIEWUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type USER_REVIEWUncheckedUpdateManyInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type EnumCALL_statusNullableFilter = {
    equals?: CALL_status | null
    in?: Enumerable<CALL_status> | null
    notIn?: Enumerable<CALL_status> | null
    not?: NestedEnumCALL_statusNullableFilter | CALL_status | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type RESTAURANTRelationFilter = {
    is?: RESTAURANTWhereInput | null
    isNot?: RESTAURANTWhereInput | null
  }

  export type LOCATIONRelationFilter = {
    is?: LOCATIONWhereInput
    isNot?: LOCATIONWhereInput
  }

  export type USERRelationFilter = {
    is?: USERWhereInput
    isNot?: USERWhereInput
  }

  export type CARTRelationFilter = {
    is?: CARTWhereInput | null
    isNot?: CARTWhereInput | null
  }

  export type ORDERRelationFilter = {
    is?: ORDERWhereInput | null
    isNot?: ORDERWhereInput | null
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedIntFilter
    min?: NestedIntFilter
    max?: NestedIntFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    count?: NestedIntNullableFilter
    min?: NestedDateTimeNullableFilter
    max?: NestedDateTimeNullableFilter
  }

  export type EnumCALL_statusNullableWithAggregatesFilter = {
    equals?: CALL_status | null
    in?: Enumerable<CALL_status> | null
    notIn?: Enumerable<CALL_status> | null
    not?: NestedEnumCALL_statusNullableWithAggregatesFilter | CALL_status | null
    count?: NestedIntNullableFilter
    min?: NestedEnumCALL_statusNullableFilter
    max?: NestedEnumCALL_statusNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    count?: NestedIntNullableFilter
    min?: NestedStringNullableFilter
    max?: NestedStringNullableFilter
  }

  export type CALLRelationFilter = {
    is?: CALLWhereInput | null
    isNot?: CALLWhereInput | null
  }

  export type SELECTED_MENURelationFilter = {
    is?: SELECTED_MENUWhereInput
    isNot?: SELECTED_MENUWhereInput
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type MESSAGERelationFilter = {
    is?: MESSAGEWhereInput
    isNot?: MESSAGEWhereInput
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    count?: NestedIntFilter
    min?: NestedDateTimeFilter
    max?: NestedDateTimeFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedFloatFilter
    min?: NestedFloatFilter
    max?: NestedFloatFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    count?: NestedIntFilter
    min?: NestedStringFilter
    max?: NestedStringFilter
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type OPTIONRelationFilter = {
    is?: OPTIONWhereInput
    isNot?: OPTIONWhereInput
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    count?: NestedIntFilter
    min?: NestedBoolFilter
    max?: NestedBoolFilter
  }

  export type CHATRelationFilter = {
    is?: CHATWhereInput
    isNot?: CHATWhereInput
  }

  export type MENURelationFilter = {
    is?: MENUWhereInput
    isNot?: MENUWhereInput
  }

  export type OPTION_ITEMRelationFilter = {
    is?: OPTION_ITEMWhereInput
    isNot?: OPTION_ITEMWhereInput
  }

  export type EnumORDER_statusNullableFilter = {
    equals?: ORDER_status | null
    in?: Enumerable<ORDER_status> | null
    notIn?: Enumerable<ORDER_status> | null
    not?: NestedEnumORDER_statusNullableFilter | ORDER_status | null
  }

  export type RES_REVIEWRelationFilter = {
    is?: RES_REVIEWWhereInput | null
    isNot?: RES_REVIEWWhereInput | null
  }

  export type USER_REVIEWRelationFilter = {
    is?: USER_REVIEWWhereInput
    isNot?: USER_REVIEWWhereInput
  }

  export type EnumORDER_statusNullableWithAggregatesFilter = {
    equals?: ORDER_status | null
    in?: Enumerable<ORDER_status> | null
    notIn?: Enumerable<ORDER_status> | null
    not?: NestedEnumORDER_statusNullableWithAggregatesFilter | ORDER_status | null
    count?: NestedIntNullableFilter
    min?: NestedEnumORDER_statusNullableFilter
    max?: NestedEnumORDER_statusNullableFilter
  }

  export type REPLYRelationFilter = {
    is?: REPLYWhereInput
    isNot?: REPLYWhereInput
  }

  export type RUN_TIMERelationFilter = {
    is?: RUN_TIMEWhereInput
    isNot?: RUN_TIMEWhereInput
  }

  export type EnumUSER_statusFilter = {
    equals?: USER_status
    in?: Enumerable<USER_status>
    notIn?: Enumerable<USER_status>
    not?: NestedEnumUSER_statusFilter | USER_status
  }

  export type REPORTRelationFilter = {
    is?: REPORTWhereInput | null
    isNot?: REPORTWhereInput | null
  }

  export type EnumUSER_statusWithAggregatesFilter = {
    equals?: USER_status
    in?: Enumerable<USER_status>
    notIn?: Enumerable<USER_status>
    not?: NestedEnumUSER_statusWithAggregatesFilter | USER_status
    count?: NestedIntFilter
    min?: NestedEnumUSER_statusFilter
    max?: NestedEnumUSER_statusFilter
  }

  export type RESTAURANTCreateNestedOneWithoutCALLInput = {
    create?: XOR<RESTAURANTCreateWithoutCALLInput, RESTAURANTUncheckedCreateWithoutCALLInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutCALLInput
    connect?: RESTAURANTWhereUniqueInput
  }

  export type LOCATIONCreateNestedOneWithoutCALLInput = {
    create?: XOR<LOCATIONCreateWithoutCALLInput, LOCATIONUncheckedCreateWithoutCALLInput>
    connectOrCreate?: LOCATIONCreateOrConnectWithoutCALLInput
    connect?: LOCATIONWhereUniqueInput
  }

  export type USERCreateNestedOneWithoutCALLInput = {
    create?: XOR<USERCreateWithoutCALLInput, USERUncheckedCreateWithoutCALLInput>
    connectOrCreate?: USERCreateOrConnectWithoutCALLInput
    connect?: USERWhereUniqueInput
  }

  export type CARTCreateNestedOneWithoutCALLInput = {
    create?: XOR<CARTCreateWithoutCALLInput, CARTUncheckedCreateWithoutCALLInput>
    connectOrCreate?: CARTCreateOrConnectWithoutCALLInput
    connect?: CARTWhereUniqueInput
  }

  export type ORDERCreateNestedOneWithoutCALLInput = {
    create?: XOR<ORDERCreateWithoutCALLInput, ORDERUncheckedCreateWithoutCALLInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutCALLInput
    connect?: ORDERWhereUniqueInput
  }

  export type CARTUncheckedCreateNestedOneWithoutCALLInput = {
    create?: XOR<CARTCreateWithoutCALLInput, CARTUncheckedCreateWithoutCALLInput>
    connectOrCreate?: CARTCreateOrConnectWithoutCALLInput
    connect?: CARTWhereUniqueInput
  }

  export type ORDERUncheckedCreateNestedOneWithoutCALLInput = {
    create?: XOR<ORDERCreateWithoutCALLInput, ORDERUncheckedCreateWithoutCALLInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutCALLInput
    connect?: ORDERWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumCALL_statusFieldUpdateOperationsInput = {
    set?: CALL_status | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RESTAURANTUpdateOneRequiredWithoutCALLInput = {
    create?: XOR<RESTAURANTCreateWithoutCALLInput, RESTAURANTUncheckedCreateWithoutCALLInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutCALLInput
    upsert?: RESTAURANTUpsertWithoutCALLInput
    connect?: RESTAURANTWhereUniqueInput
    update?: XOR<RESTAURANTUpdateWithoutCALLInput, RESTAURANTUncheckedUpdateWithoutCALLInput>
  }

  export type LOCATIONUpdateOneRequiredWithoutCALLInput = {
    create?: XOR<LOCATIONCreateWithoutCALLInput, LOCATIONUncheckedCreateWithoutCALLInput>
    connectOrCreate?: LOCATIONCreateOrConnectWithoutCALLInput
    upsert?: LOCATIONUpsertWithoutCALLInput
    connect?: LOCATIONWhereUniqueInput
    update?: XOR<LOCATIONUpdateWithoutCALLInput, LOCATIONUncheckedUpdateWithoutCALLInput>
  }

  export type USERUpdateOneRequiredWithoutCALLInput = {
    create?: XOR<USERCreateWithoutCALLInput, USERUncheckedCreateWithoutCALLInput>
    connectOrCreate?: USERCreateOrConnectWithoutCALLInput
    upsert?: USERUpsertWithoutCALLInput
    connect?: USERWhereUniqueInput
    update?: XOR<USERUpdateWithoutCALLInput, USERUncheckedUpdateWithoutCALLInput>
  }

  export type CARTUpdateOneWithoutCALLInput = {
    create?: XOR<CARTCreateWithoutCALLInput, CARTUncheckedCreateWithoutCALLInput>
    connectOrCreate?: CARTCreateOrConnectWithoutCALLInput
    upsert?: CARTUpsertWithoutCALLInput
    connect?: CARTWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CARTUpdateWithoutCALLInput, CARTUncheckedUpdateWithoutCALLInput>
  }

  export type ORDERUpdateOneWithoutCALLInput = {
    create?: XOR<ORDERCreateWithoutCALLInput, ORDERUncheckedCreateWithoutCALLInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutCALLInput
    upsert?: ORDERUpsertWithoutCALLInput
    connect?: ORDERWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ORDERUpdateWithoutCALLInput, ORDERUncheckedUpdateWithoutCALLInput>
  }

  export type CARTUncheckedUpdateOneWithoutCALLInput = {
    create?: XOR<CARTCreateWithoutCALLInput, CARTUncheckedCreateWithoutCALLInput>
    connectOrCreate?: CARTCreateOrConnectWithoutCALLInput
    upsert?: CARTUpsertWithoutCALLInput
    connect?: CARTWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CARTUpdateWithoutCALLInput, CARTUncheckedUpdateWithoutCALLInput>
  }

  export type ORDERUncheckedUpdateOneWithoutCALLInput = {
    create?: XOR<ORDERCreateWithoutCALLInput, ORDERUncheckedCreateWithoutCALLInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutCALLInput
    upsert?: ORDERUpsertWithoutCALLInput
    connect?: ORDERWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ORDERUpdateWithoutCALLInput, ORDERUncheckedUpdateWithoutCALLInput>
  }

  export type CALLCreateNestedOneWithoutCARTInput = {
    create?: XOR<CALLCreateWithoutCARTInput, CALLUncheckedCreateWithoutCARTInput>
    connectOrCreate?: CALLCreateOrConnectWithoutCARTInput
    connect?: CALLWhereUniqueInput
  }

  export type SELECTED_MENUCreateNestedOneWithoutCARTInput = {
    create?: XOR<SELECTED_MENUCreateWithoutCARTInput, SELECTED_MENUUncheckedCreateWithoutCARTInput>
    connectOrCreate?: SELECTED_MENUCreateOrConnectWithoutCARTInput
    connect?: SELECTED_MENUWhereUniqueInput
  }

  export type USERCreateNestedOneWithoutCARTInput = {
    create?: XOR<USERCreateWithoutCARTInput, USERUncheckedCreateWithoutCARTInput>
    connectOrCreate?: USERCreateOrConnectWithoutCARTInput
    connect?: USERWhereUniqueInput
  }

  export type CALLUpdateOneRequiredWithoutCARTInput = {
    create?: XOR<CALLCreateWithoutCARTInput, CALLUncheckedCreateWithoutCARTInput>
    connectOrCreate?: CALLCreateOrConnectWithoutCARTInput
    upsert?: CALLUpsertWithoutCARTInput
    connect?: CALLWhereUniqueInput
    update?: XOR<CALLUpdateWithoutCARTInput, CALLUncheckedUpdateWithoutCARTInput>
  }

  export type SELECTED_MENUUpdateOneRequiredWithoutCARTInput = {
    create?: XOR<SELECTED_MENUCreateWithoutCARTInput, SELECTED_MENUUncheckedCreateWithoutCARTInput>
    connectOrCreate?: SELECTED_MENUCreateOrConnectWithoutCARTInput
    upsert?: SELECTED_MENUUpsertWithoutCARTInput
    connect?: SELECTED_MENUWhereUniqueInput
    update?: XOR<SELECTED_MENUUpdateWithoutCARTInput, SELECTED_MENUUncheckedUpdateWithoutCARTInput>
  }

  export type USERUpdateOneRequiredWithoutCARTInput = {
    create?: XOR<USERCreateWithoutCARTInput, USERUncheckedCreateWithoutCARTInput>
    connectOrCreate?: USERCreateOrConnectWithoutCARTInput
    upsert?: USERUpsertWithoutCARTInput
    connect?: USERWhereUniqueInput
    update?: XOR<USERUpdateWithoutCARTInput, USERUncheckedUpdateWithoutCARTInput>
  }

  export type USERCreateNestedOneWithoutCHATInput = {
    create?: XOR<USERCreateWithoutCHATInput, USERUncheckedCreateWithoutCHATInput>
    connectOrCreate?: USERCreateOrConnectWithoutCHATInput
    connect?: USERWhereUniqueInput
  }

  export type MESSAGECreateNestedOneWithoutCHAT_CHAT_seqToMESSAGEInput = {
    create?: XOR<MESSAGECreateWithoutCHAT_CHAT_seqToMESSAGEInput, MESSAGEUncheckedCreateWithoutCHAT_CHAT_seqToMESSAGEInput>
    connectOrCreate?: MESSAGECreateOrConnectWithoutCHAT_CHAT_seqToMESSAGEInput
    connect?: MESSAGEWhereUniqueInput
  }

  export type MESSAGECreateNestedOneWithoutCHAT_CHATToMESSAGE_seqInput = {
    create?: XOR<MESSAGECreateWithoutCHAT_CHATToMESSAGE_seqInput, MESSAGEUncheckedCreateWithoutCHAT_CHATToMESSAGE_seqInput>
    connectOrCreate?: MESSAGECreateOrConnectWithoutCHAT_CHATToMESSAGE_seqInput
    connect?: MESSAGEWhereUniqueInput
  }

  export type MESSAGEUncheckedCreateNestedOneWithoutCHAT_CHATToMESSAGE_seqInput = {
    create?: XOR<MESSAGECreateWithoutCHAT_CHATToMESSAGE_seqInput, MESSAGEUncheckedCreateWithoutCHAT_CHATToMESSAGE_seqInput>
    connectOrCreate?: MESSAGECreateOrConnectWithoutCHAT_CHATToMESSAGE_seqInput
    connect?: MESSAGEWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type USERUpdateOneRequiredWithoutCHATInput = {
    create?: XOR<USERCreateWithoutCHATInput, USERUncheckedCreateWithoutCHATInput>
    connectOrCreate?: USERCreateOrConnectWithoutCHATInput
    upsert?: USERUpsertWithoutCHATInput
    connect?: USERWhereUniqueInput
    update?: XOR<USERUpdateWithoutCHATInput, USERUncheckedUpdateWithoutCHATInput>
  }

  export type MESSAGEUpdateOneRequiredWithoutCHAT_CHAT_seqToMESSAGEInput = {
    create?: XOR<MESSAGECreateWithoutCHAT_CHAT_seqToMESSAGEInput, MESSAGEUncheckedCreateWithoutCHAT_CHAT_seqToMESSAGEInput>
    connectOrCreate?: MESSAGECreateOrConnectWithoutCHAT_CHAT_seqToMESSAGEInput
    upsert?: MESSAGEUpsertWithoutCHAT_CHAT_seqToMESSAGEInput
    connect?: MESSAGEWhereUniqueInput
    update?: XOR<MESSAGEUpdateWithoutCHAT_CHAT_seqToMESSAGEInput, MESSAGEUncheckedUpdateWithoutCHAT_CHAT_seqToMESSAGEInput>
  }

  export type MESSAGEUpdateOneWithoutCHAT_CHATToMESSAGE_seqInput = {
    create?: XOR<MESSAGECreateWithoutCHAT_CHATToMESSAGE_seqInput, MESSAGEUncheckedCreateWithoutCHAT_CHATToMESSAGE_seqInput>
    connectOrCreate?: MESSAGECreateOrConnectWithoutCHAT_CHATToMESSAGE_seqInput
    upsert?: MESSAGEUpsertWithoutCHAT_CHATToMESSAGE_seqInput
    connect?: MESSAGEWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MESSAGEUpdateWithoutCHAT_CHATToMESSAGE_seqInput, MESSAGEUncheckedUpdateWithoutCHAT_CHATToMESSAGE_seqInput>
  }

  export type MESSAGEUncheckedUpdateOneWithoutCHAT_CHATToMESSAGE_seqInput = {
    create?: XOR<MESSAGECreateWithoutCHAT_CHATToMESSAGE_seqInput, MESSAGEUncheckedCreateWithoutCHAT_CHATToMESSAGE_seqInput>
    connectOrCreate?: MESSAGECreateOrConnectWithoutCHAT_CHATToMESSAGE_seqInput
    upsert?: MESSAGEUpsertWithoutCHAT_CHATToMESSAGE_seqInput
    connect?: MESSAGEWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MESSAGEUpdateWithoutCHAT_CHATToMESSAGE_seqInput, MESSAGEUncheckedUpdateWithoutCHAT_CHATToMESSAGE_seqInput>
  }

  export type CALLCreateNestedOneWithoutLOCATIONInput = {
    create?: XOR<CALLCreateWithoutLOCATIONInput, CALLUncheckedCreateWithoutLOCATIONInput>
    connectOrCreate?: CALLCreateOrConnectWithoutLOCATIONInput
    connect?: CALLWhereUniqueInput
  }

  export type RESTAURANTCreateNestedOneWithoutLOCATIONInput = {
    create?: XOR<RESTAURANTCreateWithoutLOCATIONInput, RESTAURANTUncheckedCreateWithoutLOCATIONInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutLOCATIONInput
    connect?: RESTAURANTWhereUniqueInput
  }

  export type CALLUncheckedCreateNestedOneWithoutLOCATIONInput = {
    create?: XOR<CALLCreateWithoutLOCATIONInput, CALLUncheckedCreateWithoutLOCATIONInput>
    connectOrCreate?: CALLCreateOrConnectWithoutLOCATIONInput
    connect?: CALLWhereUniqueInput
  }

  export type RESTAURANTUncheckedCreateNestedOneWithoutLOCATIONInput = {
    create?: XOR<RESTAURANTCreateWithoutLOCATIONInput, RESTAURANTUncheckedCreateWithoutLOCATIONInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutLOCATIONInput
    connect?: RESTAURANTWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type CALLUpdateOneWithoutLOCATIONInput = {
    create?: XOR<CALLCreateWithoutLOCATIONInput, CALLUncheckedCreateWithoutLOCATIONInput>
    connectOrCreate?: CALLCreateOrConnectWithoutLOCATIONInput
    upsert?: CALLUpsertWithoutLOCATIONInput
    connect?: CALLWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CALLUpdateWithoutLOCATIONInput, CALLUncheckedUpdateWithoutLOCATIONInput>
  }

  export type RESTAURANTUpdateOneWithoutLOCATIONInput = {
    create?: XOR<RESTAURANTCreateWithoutLOCATIONInput, RESTAURANTUncheckedCreateWithoutLOCATIONInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutLOCATIONInput
    upsert?: RESTAURANTUpsertWithoutLOCATIONInput
    connect?: RESTAURANTWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RESTAURANTUpdateWithoutLOCATIONInput, RESTAURANTUncheckedUpdateWithoutLOCATIONInput>
  }

  export type CALLUncheckedUpdateOneWithoutLOCATIONInput = {
    create?: XOR<CALLCreateWithoutLOCATIONInput, CALLUncheckedCreateWithoutLOCATIONInput>
    connectOrCreate?: CALLCreateOrConnectWithoutLOCATIONInput
    upsert?: CALLUpsertWithoutLOCATIONInput
    connect?: CALLWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CALLUpdateWithoutLOCATIONInput, CALLUncheckedUpdateWithoutLOCATIONInput>
  }

  export type RESTAURANTUncheckedUpdateOneWithoutLOCATIONInput = {
    create?: XOR<RESTAURANTCreateWithoutLOCATIONInput, RESTAURANTUncheckedCreateWithoutLOCATIONInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutLOCATIONInput
    upsert?: RESTAURANTUpsertWithoutLOCATIONInput
    connect?: RESTAURANTWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RESTAURANTUpdateWithoutLOCATIONInput, RESTAURANTUncheckedUpdateWithoutLOCATIONInput>
  }

  export type RESTAURANTCreateNestedOneWithoutMENUInput = {
    create?: XOR<RESTAURANTCreateWithoutMENUInput, RESTAURANTUncheckedCreateWithoutMENUInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutMENUInput
    connect?: RESTAURANTWhereUniqueInput
  }

  export type OPTIONCreateNestedOneWithoutMENUInput = {
    create?: XOR<OPTIONCreateWithoutMENUInput, OPTIONUncheckedCreateWithoutMENUInput>
    connectOrCreate?: OPTIONCreateOrConnectWithoutMENUInput
    connect?: OPTIONWhereUniqueInput
  }

  export type SELECTED_MENUCreateNestedOneWithoutMENUInput = {
    create?: XOR<SELECTED_MENUCreateWithoutMENUInput, SELECTED_MENUUncheckedCreateWithoutMENUInput>
    connectOrCreate?: SELECTED_MENUCreateOrConnectWithoutMENUInput
    connect?: SELECTED_MENUWhereUniqueInput
  }

  export type OPTIONUncheckedCreateNestedOneWithoutMENUInput = {
    create?: XOR<OPTIONCreateWithoutMENUInput, OPTIONUncheckedCreateWithoutMENUInput>
    connectOrCreate?: OPTIONCreateOrConnectWithoutMENUInput
    connect?: OPTIONWhereUniqueInput
  }

  export type SELECTED_MENUUncheckedCreateNestedOneWithoutMENUInput = {
    create?: XOR<SELECTED_MENUCreateWithoutMENUInput, SELECTED_MENUUncheckedCreateWithoutMENUInput>
    connectOrCreate?: SELECTED_MENUCreateOrConnectWithoutMENUInput
    connect?: SELECTED_MENUWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type RESTAURANTUpdateOneRequiredWithoutMENUInput = {
    create?: XOR<RESTAURANTCreateWithoutMENUInput, RESTAURANTUncheckedCreateWithoutMENUInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutMENUInput
    upsert?: RESTAURANTUpsertWithoutMENUInput
    connect?: RESTAURANTWhereUniqueInput
    update?: XOR<RESTAURANTUpdateWithoutMENUInput, RESTAURANTUncheckedUpdateWithoutMENUInput>
  }

  export type OPTIONUpdateOneWithoutMENUInput = {
    create?: XOR<OPTIONCreateWithoutMENUInput, OPTIONUncheckedCreateWithoutMENUInput>
    connectOrCreate?: OPTIONCreateOrConnectWithoutMENUInput
    upsert?: OPTIONUpsertWithoutMENUInput
    connect?: OPTIONWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<OPTIONUpdateWithoutMENUInput, OPTIONUncheckedUpdateWithoutMENUInput>
  }

  export type SELECTED_MENUUpdateOneWithoutMENUInput = {
    create?: XOR<SELECTED_MENUCreateWithoutMENUInput, SELECTED_MENUUncheckedCreateWithoutMENUInput>
    connectOrCreate?: SELECTED_MENUCreateOrConnectWithoutMENUInput
    upsert?: SELECTED_MENUUpsertWithoutMENUInput
    connect?: SELECTED_MENUWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SELECTED_MENUUpdateWithoutMENUInput, SELECTED_MENUUncheckedUpdateWithoutMENUInput>
  }

  export type OPTIONUncheckedUpdateOneWithoutMENUInput = {
    create?: XOR<OPTIONCreateWithoutMENUInput, OPTIONUncheckedCreateWithoutMENUInput>
    connectOrCreate?: OPTIONCreateOrConnectWithoutMENUInput
    upsert?: OPTIONUpsertWithoutMENUInput
    connect?: OPTIONWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<OPTIONUpdateWithoutMENUInput, OPTIONUncheckedUpdateWithoutMENUInput>
  }

  export type SELECTED_MENUUncheckedUpdateOneWithoutMENUInput = {
    create?: XOR<SELECTED_MENUCreateWithoutMENUInput, SELECTED_MENUUncheckedCreateWithoutMENUInput>
    connectOrCreate?: SELECTED_MENUCreateOrConnectWithoutMENUInput
    upsert?: SELECTED_MENUUpsertWithoutMENUInput
    connect?: SELECTED_MENUWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SELECTED_MENUUpdateWithoutMENUInput, SELECTED_MENUUncheckedUpdateWithoutMENUInput>
  }

  export type USERCreateNestedOneWithoutMESSAGEInput = {
    create?: XOR<USERCreateWithoutMESSAGEInput, USERUncheckedCreateWithoutMESSAGEInput>
    connectOrCreate?: USERCreateOrConnectWithoutMESSAGEInput
    connect?: USERWhereUniqueInput
  }

  export type CHATCreateNestedOneWithoutMESSAGE_CHATToMESSAGE_seqInput = {
    create?: XOR<CHATCreateWithoutMESSAGE_CHATToMESSAGE_seqInput, CHATUncheckedCreateWithoutMESSAGE_CHATToMESSAGE_seqInput>
    connectOrCreate?: CHATCreateOrConnectWithoutMESSAGE_CHATToMESSAGE_seqInput
    connect?: CHATWhereUniqueInput
  }

  export type CHATCreateNestedOneWithoutMESSAGE_CHAT_seqToMESSAGEInput = {
    create?: XOR<CHATCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput, CHATUncheckedCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput>
    connectOrCreate?: CHATCreateOrConnectWithoutMESSAGE_CHAT_seqToMESSAGEInput
    connect?: CHATWhereUniqueInput
  }

  export type CHATUncheckedCreateNestedOneWithoutMESSAGE_CHAT_seqToMESSAGEInput = {
    create?: XOR<CHATCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput, CHATUncheckedCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput>
    connectOrCreate?: CHATCreateOrConnectWithoutMESSAGE_CHAT_seqToMESSAGEInput
    connect?: CHATWhereUniqueInput
  }

  export type USERUpdateOneRequiredWithoutMESSAGEInput = {
    create?: XOR<USERCreateWithoutMESSAGEInput, USERUncheckedCreateWithoutMESSAGEInput>
    connectOrCreate?: USERCreateOrConnectWithoutMESSAGEInput
    upsert?: USERUpsertWithoutMESSAGEInput
    connect?: USERWhereUniqueInput
    update?: XOR<USERUpdateWithoutMESSAGEInput, USERUncheckedUpdateWithoutMESSAGEInput>
  }

  export type CHATUpdateOneRequiredWithoutMESSAGE_CHATToMESSAGE_seqInput = {
    create?: XOR<CHATCreateWithoutMESSAGE_CHATToMESSAGE_seqInput, CHATUncheckedCreateWithoutMESSAGE_CHATToMESSAGE_seqInput>
    connectOrCreate?: CHATCreateOrConnectWithoutMESSAGE_CHATToMESSAGE_seqInput
    upsert?: CHATUpsertWithoutMESSAGE_CHATToMESSAGE_seqInput
    connect?: CHATWhereUniqueInput
    update?: XOR<CHATUpdateWithoutMESSAGE_CHATToMESSAGE_seqInput, CHATUncheckedUpdateWithoutMESSAGE_CHATToMESSAGE_seqInput>
  }

  export type CHATUpdateOneWithoutMESSAGE_CHAT_seqToMESSAGEInput = {
    create?: XOR<CHATCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput, CHATUncheckedCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput>
    connectOrCreate?: CHATCreateOrConnectWithoutMESSAGE_CHAT_seqToMESSAGEInput
    upsert?: CHATUpsertWithoutMESSAGE_CHAT_seqToMESSAGEInput
    connect?: CHATWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CHATUpdateWithoutMESSAGE_CHAT_seqToMESSAGEInput, CHATUncheckedUpdateWithoutMESSAGE_CHAT_seqToMESSAGEInput>
  }

  export type CHATUncheckedUpdateOneWithoutMESSAGE_CHAT_seqToMESSAGEInput = {
    create?: XOR<CHATCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput, CHATUncheckedCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput>
    connectOrCreate?: CHATCreateOrConnectWithoutMESSAGE_CHAT_seqToMESSAGEInput
    upsert?: CHATUpsertWithoutMESSAGE_CHAT_seqToMESSAGEInput
    connect?: CHATWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CHATUpdateWithoutMESSAGE_CHAT_seqToMESSAGEInput, CHATUncheckedUpdateWithoutMESSAGE_CHAT_seqToMESSAGEInput>
  }

  export type MENUCreateNestedOneWithoutOPTIONInput = {
    create?: XOR<MENUCreateWithoutOPTIONInput, MENUUncheckedCreateWithoutOPTIONInput>
    connectOrCreate?: MENUCreateOrConnectWithoutOPTIONInput
    connect?: MENUWhereUniqueInput
  }

  export type OPTION_ITEMCreateNestedOneWithoutOPTIONInput = {
    create?: XOR<OPTION_ITEMCreateWithoutOPTIONInput, OPTION_ITEMUncheckedCreateWithoutOPTIONInput>
    connectOrCreate?: OPTION_ITEMCreateOrConnectWithoutOPTIONInput
    connect?: OPTION_ITEMWhereUniqueInput
  }

  export type OPTION_ITEMUncheckedCreateNestedOneWithoutOPTIONInput = {
    create?: XOR<OPTION_ITEMCreateWithoutOPTIONInput, OPTION_ITEMUncheckedCreateWithoutOPTIONInput>
    connectOrCreate?: OPTION_ITEMCreateOrConnectWithoutOPTIONInput
    connect?: OPTION_ITEMWhereUniqueInput
  }

  export type MENUUpdateOneRequiredWithoutOPTIONInput = {
    create?: XOR<MENUCreateWithoutOPTIONInput, MENUUncheckedCreateWithoutOPTIONInput>
    connectOrCreate?: MENUCreateOrConnectWithoutOPTIONInput
    upsert?: MENUUpsertWithoutOPTIONInput
    connect?: MENUWhereUniqueInput
    update?: XOR<MENUUpdateWithoutOPTIONInput, MENUUncheckedUpdateWithoutOPTIONInput>
  }

  export type OPTION_ITEMUpdateOneWithoutOPTIONInput = {
    create?: XOR<OPTION_ITEMCreateWithoutOPTIONInput, OPTION_ITEMUncheckedCreateWithoutOPTIONInput>
    connectOrCreate?: OPTION_ITEMCreateOrConnectWithoutOPTIONInput
    upsert?: OPTION_ITEMUpsertWithoutOPTIONInput
    connect?: OPTION_ITEMWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<OPTION_ITEMUpdateWithoutOPTIONInput, OPTION_ITEMUncheckedUpdateWithoutOPTIONInput>
  }

  export type OPTION_ITEMUncheckedUpdateOneWithoutOPTIONInput = {
    create?: XOR<OPTION_ITEMCreateWithoutOPTIONInput, OPTION_ITEMUncheckedCreateWithoutOPTIONInput>
    connectOrCreate?: OPTION_ITEMCreateOrConnectWithoutOPTIONInput
    upsert?: OPTION_ITEMUpsertWithoutOPTIONInput
    connect?: OPTION_ITEMWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<OPTION_ITEMUpdateWithoutOPTIONInput, OPTION_ITEMUncheckedUpdateWithoutOPTIONInput>
  }

  export type OPTIONCreateNestedOneWithoutOPTION_ITEMInput = {
    create?: XOR<OPTIONCreateWithoutOPTION_ITEMInput, OPTIONUncheckedCreateWithoutOPTION_ITEMInput>
    connectOrCreate?: OPTIONCreateOrConnectWithoutOPTION_ITEMInput
    connect?: OPTIONWhereUniqueInput
  }

  export type SELECTED_MENUCreateNestedOneWithoutOPTION_ITEMInput = {
    create?: XOR<SELECTED_MENUCreateWithoutOPTION_ITEMInput, SELECTED_MENUUncheckedCreateWithoutOPTION_ITEMInput>
    connectOrCreate?: SELECTED_MENUCreateOrConnectWithoutOPTION_ITEMInput
    connect?: SELECTED_MENUWhereUniqueInput
  }

  export type SELECTED_MENUUncheckedCreateNestedOneWithoutOPTION_ITEMInput = {
    create?: XOR<SELECTED_MENUCreateWithoutOPTION_ITEMInput, SELECTED_MENUUncheckedCreateWithoutOPTION_ITEMInput>
    connectOrCreate?: SELECTED_MENUCreateOrConnectWithoutOPTION_ITEMInput
    connect?: SELECTED_MENUWhereUniqueInput
  }

  export type OPTIONUpdateOneRequiredWithoutOPTION_ITEMInput = {
    create?: XOR<OPTIONCreateWithoutOPTION_ITEMInput, OPTIONUncheckedCreateWithoutOPTION_ITEMInput>
    connectOrCreate?: OPTIONCreateOrConnectWithoutOPTION_ITEMInput
    upsert?: OPTIONUpsertWithoutOPTION_ITEMInput
    connect?: OPTIONWhereUniqueInput
    update?: XOR<OPTIONUpdateWithoutOPTION_ITEMInput, OPTIONUncheckedUpdateWithoutOPTION_ITEMInput>
  }

  export type SELECTED_MENUUpdateOneWithoutOPTION_ITEMInput = {
    create?: XOR<SELECTED_MENUCreateWithoutOPTION_ITEMInput, SELECTED_MENUUncheckedCreateWithoutOPTION_ITEMInput>
    connectOrCreate?: SELECTED_MENUCreateOrConnectWithoutOPTION_ITEMInput
    upsert?: SELECTED_MENUUpsertWithoutOPTION_ITEMInput
    connect?: SELECTED_MENUWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SELECTED_MENUUpdateWithoutOPTION_ITEMInput, SELECTED_MENUUncheckedUpdateWithoutOPTION_ITEMInput>
  }

  export type SELECTED_MENUUncheckedUpdateOneWithoutOPTION_ITEMInput = {
    create?: XOR<SELECTED_MENUCreateWithoutOPTION_ITEMInput, SELECTED_MENUUncheckedCreateWithoutOPTION_ITEMInput>
    connectOrCreate?: SELECTED_MENUCreateOrConnectWithoutOPTION_ITEMInput
    upsert?: SELECTED_MENUUpsertWithoutOPTION_ITEMInput
    connect?: SELECTED_MENUWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<SELECTED_MENUUpdateWithoutOPTION_ITEMInput, SELECTED_MENUUncheckedUpdateWithoutOPTION_ITEMInput>
  }

  export type RES_REVIEWCreateNestedOneWithoutORDERInput = {
    create?: XOR<RES_REVIEWCreateWithoutORDERInput, RES_REVIEWUncheckedCreateWithoutORDERInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutORDERInput
    connect?: RES_REVIEWWhereUniqueInput
  }

  export type USER_REVIEWCreateNestedOneWithoutORDER_ORDER_seqToUSER_REVIEWInput = {
    create?: XOR<USER_REVIEWCreateWithoutORDER_ORDER_seqToUSER_REVIEWInput, USER_REVIEWUncheckedCreateWithoutORDER_ORDER_seqToUSER_REVIEWInput>
    connectOrCreate?: USER_REVIEWCreateOrConnectWithoutORDER_ORDER_seqToUSER_REVIEWInput
    connect?: USER_REVIEWWhereUniqueInput
  }

  export type CALLCreateNestedOneWithoutORDERInput = {
    create?: XOR<CALLCreateWithoutORDERInput, CALLUncheckedCreateWithoutORDERInput>
    connectOrCreate?: CALLCreateOrConnectWithoutORDERInput
    connect?: CALLWhereUniqueInput
  }

  export type USERCreateNestedOneWithoutORDERInput = {
    create?: XOR<USERCreateWithoutORDERInput, USERUncheckedCreateWithoutORDERInput>
    connectOrCreate?: USERCreateOrConnectWithoutORDERInput
    connect?: USERWhereUniqueInput
  }

  export type USER_REVIEWCreateNestedOneWithoutORDER_ORDERToUSER_REVIEW_seqInput = {
    create?: XOR<USER_REVIEWCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput, USER_REVIEWUncheckedCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput>
    connectOrCreate?: USER_REVIEWCreateOrConnectWithoutORDER_ORDERToUSER_REVIEW_seqInput
    connect?: USER_REVIEWWhereUniqueInput
  }

  export type USER_REVIEWUncheckedCreateNestedOneWithoutORDER_ORDERToUSER_REVIEW_seqInput = {
    create?: XOR<USER_REVIEWCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput, USER_REVIEWUncheckedCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput>
    connectOrCreate?: USER_REVIEWCreateOrConnectWithoutORDER_ORDERToUSER_REVIEW_seqInput
    connect?: USER_REVIEWWhereUniqueInput
  }

  export type NullableEnumORDER_statusFieldUpdateOperationsInput = {
    set?: ORDER_status | null
  }

  export type RES_REVIEWUpdateOneRequiredWithoutORDERInput = {
    create?: XOR<RES_REVIEWCreateWithoutORDERInput, RES_REVIEWUncheckedCreateWithoutORDERInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutORDERInput
    upsert?: RES_REVIEWUpsertWithoutORDERInput
    connect?: RES_REVIEWWhereUniqueInput
    update?: XOR<RES_REVIEWUpdateWithoutORDERInput, RES_REVIEWUncheckedUpdateWithoutORDERInput>
  }

  export type USER_REVIEWUpdateOneRequiredWithoutORDER_ORDER_seqToUSER_REVIEWInput = {
    create?: XOR<USER_REVIEWCreateWithoutORDER_ORDER_seqToUSER_REVIEWInput, USER_REVIEWUncheckedCreateWithoutORDER_ORDER_seqToUSER_REVIEWInput>
    connectOrCreate?: USER_REVIEWCreateOrConnectWithoutORDER_ORDER_seqToUSER_REVIEWInput
    upsert?: USER_REVIEWUpsertWithoutORDER_ORDER_seqToUSER_REVIEWInput
    connect?: USER_REVIEWWhereUniqueInput
    update?: XOR<USER_REVIEWUpdateWithoutORDER_ORDER_seqToUSER_REVIEWInput, USER_REVIEWUncheckedUpdateWithoutORDER_ORDER_seqToUSER_REVIEWInput>
  }

  export type CALLUpdateOneRequiredWithoutORDERInput = {
    create?: XOR<CALLCreateWithoutORDERInput, CALLUncheckedCreateWithoutORDERInput>
    connectOrCreate?: CALLCreateOrConnectWithoutORDERInput
    upsert?: CALLUpsertWithoutORDERInput
    connect?: CALLWhereUniqueInput
    update?: XOR<CALLUpdateWithoutORDERInput, CALLUncheckedUpdateWithoutORDERInput>
  }

  export type USERUpdateOneRequiredWithoutORDERInput = {
    create?: XOR<USERCreateWithoutORDERInput, USERUncheckedCreateWithoutORDERInput>
    connectOrCreate?: USERCreateOrConnectWithoutORDERInput
    upsert?: USERUpsertWithoutORDERInput
    connect?: USERWhereUniqueInput
    update?: XOR<USERUpdateWithoutORDERInput, USERUncheckedUpdateWithoutORDERInput>
  }

  export type USER_REVIEWUpdateOneWithoutORDER_ORDERToUSER_REVIEW_seqInput = {
    create?: XOR<USER_REVIEWCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput, USER_REVIEWUncheckedCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput>
    connectOrCreate?: USER_REVIEWCreateOrConnectWithoutORDER_ORDERToUSER_REVIEW_seqInput
    upsert?: USER_REVIEWUpsertWithoutORDER_ORDERToUSER_REVIEW_seqInput
    connect?: USER_REVIEWWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<USER_REVIEWUpdateWithoutORDER_ORDERToUSER_REVIEW_seqInput, USER_REVIEWUncheckedUpdateWithoutORDER_ORDERToUSER_REVIEW_seqInput>
  }

  export type USER_REVIEWUncheckedUpdateOneWithoutORDER_ORDERToUSER_REVIEW_seqInput = {
    create?: XOR<USER_REVIEWCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput, USER_REVIEWUncheckedCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput>
    connectOrCreate?: USER_REVIEWCreateOrConnectWithoutORDER_ORDERToUSER_REVIEW_seqInput
    upsert?: USER_REVIEWUpsertWithoutORDER_ORDERToUSER_REVIEW_seqInput
    connect?: USER_REVIEWWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<USER_REVIEWUpdateWithoutORDER_ORDERToUSER_REVIEW_seqInput, USER_REVIEWUncheckedUpdateWithoutORDER_ORDERToUSER_REVIEW_seqInput>
  }

  export type RESTAURANTCreateNestedOneWithoutREPLYInput = {
    create?: XOR<RESTAURANTCreateWithoutREPLYInput, RESTAURANTUncheckedCreateWithoutREPLYInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutREPLYInput
    connect?: RESTAURANTWhereUniqueInput
  }

  export type RES_REVIEWCreateNestedOneWithoutREPLYInput = {
    create?: XOR<RES_REVIEWCreateWithoutREPLYInput, RES_REVIEWUncheckedCreateWithoutREPLYInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutREPLYInput
    connect?: RES_REVIEWWhereUniqueInput
  }

  export type RES_REVIEWUncheckedCreateNestedOneWithoutREPLYInput = {
    create?: XOR<RES_REVIEWCreateWithoutREPLYInput, RES_REVIEWUncheckedCreateWithoutREPLYInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutREPLYInput
    connect?: RES_REVIEWWhereUniqueInput
  }

  export type RESTAURANTUpdateOneRequiredWithoutREPLYInput = {
    create?: XOR<RESTAURANTCreateWithoutREPLYInput, RESTAURANTUncheckedCreateWithoutREPLYInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutREPLYInput
    upsert?: RESTAURANTUpsertWithoutREPLYInput
    connect?: RESTAURANTWhereUniqueInput
    update?: XOR<RESTAURANTUpdateWithoutREPLYInput, RESTAURANTUncheckedUpdateWithoutREPLYInput>
  }

  export type RES_REVIEWUpdateOneWithoutREPLYInput = {
    create?: XOR<RES_REVIEWCreateWithoutREPLYInput, RES_REVIEWUncheckedCreateWithoutREPLYInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutREPLYInput
    upsert?: RES_REVIEWUpsertWithoutREPLYInput
    connect?: RES_REVIEWWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RES_REVIEWUpdateWithoutREPLYInput, RES_REVIEWUncheckedUpdateWithoutREPLYInput>
  }

  export type RES_REVIEWUncheckedUpdateOneWithoutREPLYInput = {
    create?: XOR<RES_REVIEWCreateWithoutREPLYInput, RES_REVIEWUncheckedCreateWithoutREPLYInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutREPLYInput
    upsert?: RES_REVIEWUpsertWithoutREPLYInput
    connect?: RES_REVIEWWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RES_REVIEWUpdateWithoutREPLYInput, RES_REVIEWUncheckedUpdateWithoutREPLYInput>
  }

  export type USERCreateNestedOneWithoutREPORTInput = {
    create?: XOR<USERCreateWithoutREPORTInput, USERUncheckedCreateWithoutREPORTInput>
    connectOrCreate?: USERCreateOrConnectWithoutREPORTInput
    connect?: USERWhereUniqueInput
  }

  export type USERUpdateOneRequiredWithoutREPORTInput = {
    create?: XOR<USERCreateWithoutREPORTInput, USERUncheckedCreateWithoutREPORTInput>
    connectOrCreate?: USERCreateOrConnectWithoutREPORTInput
    upsert?: USERUpsertWithoutREPORTInput
    connect?: USERWhereUniqueInput
    update?: XOR<USERUpdateWithoutREPORTInput, USERUncheckedUpdateWithoutREPORTInput>
  }

  export type RESTAURANTCreateNestedOneWithoutRES_REVIEWInput = {
    create?: XOR<RESTAURANTCreateWithoutRES_REVIEWInput, RESTAURANTUncheckedCreateWithoutRES_REVIEWInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutRES_REVIEWInput
    connect?: RESTAURANTWhereUniqueInput
  }

  export type REPLYCreateNestedOneWithoutRES_REVIEWInput = {
    create?: XOR<REPLYCreateWithoutRES_REVIEWInput, REPLYUncheckedCreateWithoutRES_REVIEWInput>
    connectOrCreate?: REPLYCreateOrConnectWithoutRES_REVIEWInput
    connect?: REPLYWhereUniqueInput
  }

  export type USERCreateNestedOneWithoutRES_REVIEWInput = {
    create?: XOR<USERCreateWithoutRES_REVIEWInput, USERUncheckedCreateWithoutRES_REVIEWInput>
    connectOrCreate?: USERCreateOrConnectWithoutRES_REVIEWInput
    connect?: USERWhereUniqueInput
  }

  export type ORDERCreateNestedOneWithoutRES_REVIEWInput = {
    create?: XOR<ORDERCreateWithoutRES_REVIEWInput, ORDERUncheckedCreateWithoutRES_REVIEWInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutRES_REVIEWInput
    connect?: ORDERWhereUniqueInput
  }

  export type ORDERUncheckedCreateNestedOneWithoutRES_REVIEWInput = {
    create?: XOR<ORDERCreateWithoutRES_REVIEWInput, ORDERUncheckedCreateWithoutRES_REVIEWInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutRES_REVIEWInput
    connect?: ORDERWhereUniqueInput
  }

  export type RESTAURANTUpdateOneRequiredWithoutRES_REVIEWInput = {
    create?: XOR<RESTAURANTCreateWithoutRES_REVIEWInput, RESTAURANTUncheckedCreateWithoutRES_REVIEWInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutRES_REVIEWInput
    upsert?: RESTAURANTUpsertWithoutRES_REVIEWInput
    connect?: RESTAURANTWhereUniqueInput
    update?: XOR<RESTAURANTUpdateWithoutRES_REVIEWInput, RESTAURANTUncheckedUpdateWithoutRES_REVIEWInput>
  }

  export type REPLYUpdateOneRequiredWithoutRES_REVIEWInput = {
    create?: XOR<REPLYCreateWithoutRES_REVIEWInput, REPLYUncheckedCreateWithoutRES_REVIEWInput>
    connectOrCreate?: REPLYCreateOrConnectWithoutRES_REVIEWInput
    upsert?: REPLYUpsertWithoutRES_REVIEWInput
    connect?: REPLYWhereUniqueInput
    update?: XOR<REPLYUpdateWithoutRES_REVIEWInput, REPLYUncheckedUpdateWithoutRES_REVIEWInput>
  }

  export type USERUpdateOneRequiredWithoutRES_REVIEWInput = {
    create?: XOR<USERCreateWithoutRES_REVIEWInput, USERUncheckedCreateWithoutRES_REVIEWInput>
    connectOrCreate?: USERCreateOrConnectWithoutRES_REVIEWInput
    upsert?: USERUpsertWithoutRES_REVIEWInput
    connect?: USERWhereUniqueInput
    update?: XOR<USERUpdateWithoutRES_REVIEWInput, USERUncheckedUpdateWithoutRES_REVIEWInput>
  }

  export type ORDERUpdateOneWithoutRES_REVIEWInput = {
    create?: XOR<ORDERCreateWithoutRES_REVIEWInput, ORDERUncheckedCreateWithoutRES_REVIEWInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutRES_REVIEWInput
    upsert?: ORDERUpsertWithoutRES_REVIEWInput
    connect?: ORDERWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ORDERUpdateWithoutRES_REVIEWInput, ORDERUncheckedUpdateWithoutRES_REVIEWInput>
  }

  export type ORDERUncheckedUpdateOneWithoutRES_REVIEWInput = {
    create?: XOR<ORDERCreateWithoutRES_REVIEWInput, ORDERUncheckedCreateWithoutRES_REVIEWInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutRES_REVIEWInput
    upsert?: ORDERUpsertWithoutRES_REVIEWInput
    connect?: ORDERWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ORDERUpdateWithoutRES_REVIEWInput, ORDERUncheckedUpdateWithoutRES_REVIEWInput>
  }

  export type LOCATIONCreateNestedOneWithoutRESTAURANTInput = {
    create?: XOR<LOCATIONCreateWithoutRESTAURANTInput, LOCATIONUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: LOCATIONCreateOrConnectWithoutRESTAURANTInput
    connect?: LOCATIONWhereUniqueInput
  }

  export type RUN_TIMECreateNestedOneWithoutRESTAURANTInput = {
    create?: XOR<RUN_TIMECreateWithoutRESTAURANTInput, RUN_TIMEUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: RUN_TIMECreateOrConnectWithoutRESTAURANTInput
    connect?: RUN_TIMEWhereUniqueInput
  }

  export type CALLCreateNestedOneWithoutRESTAURANTInput = {
    create?: XOR<CALLCreateWithoutRESTAURANTInput, CALLUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: CALLCreateOrConnectWithoutRESTAURANTInput
    connect?: CALLWhereUniqueInput
  }

  export type MENUCreateNestedOneWithoutRESTAURANTInput = {
    create?: XOR<MENUCreateWithoutRESTAURANTInput, MENUUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: MENUCreateOrConnectWithoutRESTAURANTInput
    connect?: MENUWhereUniqueInput
  }

  export type REPLYCreateNestedOneWithoutRESTAURANTInput = {
    create?: XOR<REPLYCreateWithoutRESTAURANTInput, REPLYUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: REPLYCreateOrConnectWithoutRESTAURANTInput
    connect?: REPLYWhereUniqueInput
  }

  export type RES_REVIEWCreateNestedOneWithoutRESTAURANTInput = {
    create?: XOR<RES_REVIEWCreateWithoutRESTAURANTInput, RES_REVIEWUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutRESTAURANTInput
    connect?: RES_REVIEWWhereUniqueInput
  }

  export type CALLUncheckedCreateNestedOneWithoutRESTAURANTInput = {
    create?: XOR<CALLCreateWithoutRESTAURANTInput, CALLUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: CALLCreateOrConnectWithoutRESTAURANTInput
    connect?: CALLWhereUniqueInput
  }

  export type MENUUncheckedCreateNestedOneWithoutRESTAURANTInput = {
    create?: XOR<MENUCreateWithoutRESTAURANTInput, MENUUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: MENUCreateOrConnectWithoutRESTAURANTInput
    connect?: MENUWhereUniqueInput
  }

  export type REPLYUncheckedCreateNestedOneWithoutRESTAURANTInput = {
    create?: XOR<REPLYCreateWithoutRESTAURANTInput, REPLYUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: REPLYCreateOrConnectWithoutRESTAURANTInput
    connect?: REPLYWhereUniqueInput
  }

  export type RES_REVIEWUncheckedCreateNestedOneWithoutRESTAURANTInput = {
    create?: XOR<RES_REVIEWCreateWithoutRESTAURANTInput, RES_REVIEWUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutRESTAURANTInput
    connect?: RES_REVIEWWhereUniqueInput
  }

  export type LOCATIONUpdateOneRequiredWithoutRESTAURANTInput = {
    create?: XOR<LOCATIONCreateWithoutRESTAURANTInput, LOCATIONUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: LOCATIONCreateOrConnectWithoutRESTAURANTInput
    upsert?: LOCATIONUpsertWithoutRESTAURANTInput
    connect?: LOCATIONWhereUniqueInput
    update?: XOR<LOCATIONUpdateWithoutRESTAURANTInput, LOCATIONUncheckedUpdateWithoutRESTAURANTInput>
  }

  export type RUN_TIMEUpdateOneRequiredWithoutRESTAURANTInput = {
    create?: XOR<RUN_TIMECreateWithoutRESTAURANTInput, RUN_TIMEUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: RUN_TIMECreateOrConnectWithoutRESTAURANTInput
    upsert?: RUN_TIMEUpsertWithoutRESTAURANTInput
    connect?: RUN_TIMEWhereUniqueInput
    update?: XOR<RUN_TIMEUpdateWithoutRESTAURANTInput, RUN_TIMEUncheckedUpdateWithoutRESTAURANTInput>
  }

  export type CALLUpdateOneWithoutRESTAURANTInput = {
    create?: XOR<CALLCreateWithoutRESTAURANTInput, CALLUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: CALLCreateOrConnectWithoutRESTAURANTInput
    upsert?: CALLUpsertWithoutRESTAURANTInput
    connect?: CALLWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CALLUpdateWithoutRESTAURANTInput, CALLUncheckedUpdateWithoutRESTAURANTInput>
  }

  export type MENUUpdateOneWithoutRESTAURANTInput = {
    create?: XOR<MENUCreateWithoutRESTAURANTInput, MENUUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: MENUCreateOrConnectWithoutRESTAURANTInput
    upsert?: MENUUpsertWithoutRESTAURANTInput
    connect?: MENUWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MENUUpdateWithoutRESTAURANTInput, MENUUncheckedUpdateWithoutRESTAURANTInput>
  }

  export type REPLYUpdateOneWithoutRESTAURANTInput = {
    create?: XOR<REPLYCreateWithoutRESTAURANTInput, REPLYUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: REPLYCreateOrConnectWithoutRESTAURANTInput
    upsert?: REPLYUpsertWithoutRESTAURANTInput
    connect?: REPLYWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<REPLYUpdateWithoutRESTAURANTInput, REPLYUncheckedUpdateWithoutRESTAURANTInput>
  }

  export type RES_REVIEWUpdateOneWithoutRESTAURANTInput = {
    create?: XOR<RES_REVIEWCreateWithoutRESTAURANTInput, RES_REVIEWUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutRESTAURANTInput
    upsert?: RES_REVIEWUpsertWithoutRESTAURANTInput
    connect?: RES_REVIEWWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RES_REVIEWUpdateWithoutRESTAURANTInput, RES_REVIEWUncheckedUpdateWithoutRESTAURANTInput>
  }

  export type CALLUncheckedUpdateOneWithoutRESTAURANTInput = {
    create?: XOR<CALLCreateWithoutRESTAURANTInput, CALLUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: CALLCreateOrConnectWithoutRESTAURANTInput
    upsert?: CALLUpsertWithoutRESTAURANTInput
    connect?: CALLWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CALLUpdateWithoutRESTAURANTInput, CALLUncheckedUpdateWithoutRESTAURANTInput>
  }

  export type MENUUncheckedUpdateOneWithoutRESTAURANTInput = {
    create?: XOR<MENUCreateWithoutRESTAURANTInput, MENUUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: MENUCreateOrConnectWithoutRESTAURANTInput
    upsert?: MENUUpsertWithoutRESTAURANTInput
    connect?: MENUWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MENUUpdateWithoutRESTAURANTInput, MENUUncheckedUpdateWithoutRESTAURANTInput>
  }

  export type REPLYUncheckedUpdateOneWithoutRESTAURANTInput = {
    create?: XOR<REPLYCreateWithoutRESTAURANTInput, REPLYUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: REPLYCreateOrConnectWithoutRESTAURANTInput
    upsert?: REPLYUpsertWithoutRESTAURANTInput
    connect?: REPLYWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<REPLYUpdateWithoutRESTAURANTInput, REPLYUncheckedUpdateWithoutRESTAURANTInput>
  }

  export type RES_REVIEWUncheckedUpdateOneWithoutRESTAURANTInput = {
    create?: XOR<RES_REVIEWCreateWithoutRESTAURANTInput, RES_REVIEWUncheckedCreateWithoutRESTAURANTInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutRESTAURANTInput
    upsert?: RES_REVIEWUpsertWithoutRESTAURANTInput
    connect?: RES_REVIEWWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RES_REVIEWUpdateWithoutRESTAURANTInput, RES_REVIEWUncheckedUpdateWithoutRESTAURANTInput>
  }

  export type RESTAURANTCreateNestedOneWithoutRUN_TIMEInput = {
    create?: XOR<RESTAURANTCreateWithoutRUN_TIMEInput, RESTAURANTUncheckedCreateWithoutRUN_TIMEInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutRUN_TIMEInput
    connect?: RESTAURANTWhereUniqueInput
  }

  export type RESTAURANTUncheckedCreateNestedOneWithoutRUN_TIMEInput = {
    create?: XOR<RESTAURANTCreateWithoutRUN_TIMEInput, RESTAURANTUncheckedCreateWithoutRUN_TIMEInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutRUN_TIMEInput
    connect?: RESTAURANTWhereUniqueInput
  }

  export type RESTAURANTUpdateOneWithoutRUN_TIMEInput = {
    create?: XOR<RESTAURANTCreateWithoutRUN_TIMEInput, RESTAURANTUncheckedCreateWithoutRUN_TIMEInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutRUN_TIMEInput
    upsert?: RESTAURANTUpsertWithoutRUN_TIMEInput
    connect?: RESTAURANTWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RESTAURANTUpdateWithoutRUN_TIMEInput, RESTAURANTUncheckedUpdateWithoutRUN_TIMEInput>
  }

  export type RESTAURANTUncheckedUpdateOneWithoutRUN_TIMEInput = {
    create?: XOR<RESTAURANTCreateWithoutRUN_TIMEInput, RESTAURANTUncheckedCreateWithoutRUN_TIMEInput>
    connectOrCreate?: RESTAURANTCreateOrConnectWithoutRUN_TIMEInput
    upsert?: RESTAURANTUpsertWithoutRUN_TIMEInput
    connect?: RESTAURANTWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RESTAURANTUpdateWithoutRUN_TIMEInput, RESTAURANTUncheckedUpdateWithoutRUN_TIMEInput>
  }

  export type OPTION_ITEMCreateNestedOneWithoutSELECTED_MENUInput = {
    create?: XOR<OPTION_ITEMCreateWithoutSELECTED_MENUInput, OPTION_ITEMUncheckedCreateWithoutSELECTED_MENUInput>
    connectOrCreate?: OPTION_ITEMCreateOrConnectWithoutSELECTED_MENUInput
    connect?: OPTION_ITEMWhereUniqueInput
  }

  export type MENUCreateNestedOneWithoutSELECTED_MENUInput = {
    create?: XOR<MENUCreateWithoutSELECTED_MENUInput, MENUUncheckedCreateWithoutSELECTED_MENUInput>
    connectOrCreate?: MENUCreateOrConnectWithoutSELECTED_MENUInput
    connect?: MENUWhereUniqueInput
  }

  export type CARTCreateNestedOneWithoutSELECTED_MENUInput = {
    create?: XOR<CARTCreateWithoutSELECTED_MENUInput, CARTUncheckedCreateWithoutSELECTED_MENUInput>
    connectOrCreate?: CARTCreateOrConnectWithoutSELECTED_MENUInput
    connect?: CARTWhereUniqueInput
  }

  export type CARTUncheckedCreateNestedOneWithoutSELECTED_MENUInput = {
    create?: XOR<CARTCreateWithoutSELECTED_MENUInput, CARTUncheckedCreateWithoutSELECTED_MENUInput>
    connectOrCreate?: CARTCreateOrConnectWithoutSELECTED_MENUInput
    connect?: CARTWhereUniqueInput
  }

  export type OPTION_ITEMUpdateOneRequiredWithoutSELECTED_MENUInput = {
    create?: XOR<OPTION_ITEMCreateWithoutSELECTED_MENUInput, OPTION_ITEMUncheckedCreateWithoutSELECTED_MENUInput>
    connectOrCreate?: OPTION_ITEMCreateOrConnectWithoutSELECTED_MENUInput
    upsert?: OPTION_ITEMUpsertWithoutSELECTED_MENUInput
    connect?: OPTION_ITEMWhereUniqueInput
    update?: XOR<OPTION_ITEMUpdateWithoutSELECTED_MENUInput, OPTION_ITEMUncheckedUpdateWithoutSELECTED_MENUInput>
  }

  export type MENUUpdateOneRequiredWithoutSELECTED_MENUInput = {
    create?: XOR<MENUCreateWithoutSELECTED_MENUInput, MENUUncheckedCreateWithoutSELECTED_MENUInput>
    connectOrCreate?: MENUCreateOrConnectWithoutSELECTED_MENUInput
    upsert?: MENUUpsertWithoutSELECTED_MENUInput
    connect?: MENUWhereUniqueInput
    update?: XOR<MENUUpdateWithoutSELECTED_MENUInput, MENUUncheckedUpdateWithoutSELECTED_MENUInput>
  }

  export type CARTUpdateOneWithoutSELECTED_MENUInput = {
    create?: XOR<CARTCreateWithoutSELECTED_MENUInput, CARTUncheckedCreateWithoutSELECTED_MENUInput>
    connectOrCreate?: CARTCreateOrConnectWithoutSELECTED_MENUInput
    upsert?: CARTUpsertWithoutSELECTED_MENUInput
    connect?: CARTWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CARTUpdateWithoutSELECTED_MENUInput, CARTUncheckedUpdateWithoutSELECTED_MENUInput>
  }

  export type CARTUncheckedUpdateOneWithoutSELECTED_MENUInput = {
    create?: XOR<CARTCreateWithoutSELECTED_MENUInput, CARTUncheckedCreateWithoutSELECTED_MENUInput>
    connectOrCreate?: CARTCreateOrConnectWithoutSELECTED_MENUInput
    upsert?: CARTUpsertWithoutSELECTED_MENUInput
    connect?: CARTWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CARTUpdateWithoutSELECTED_MENUInput, CARTUncheckedUpdateWithoutSELECTED_MENUInput>
  }

  export type CALLCreateNestedOneWithoutUSERInput = {
    create?: XOR<CALLCreateWithoutUSERInput, CALLUncheckedCreateWithoutUSERInput>
    connectOrCreate?: CALLCreateOrConnectWithoutUSERInput
    connect?: CALLWhereUniqueInput
  }

  export type CARTCreateNestedOneWithoutUSERInput = {
    create?: XOR<CARTCreateWithoutUSERInput, CARTUncheckedCreateWithoutUSERInput>
    connectOrCreate?: CARTCreateOrConnectWithoutUSERInput
    connect?: CARTWhereUniqueInput
  }

  export type CHATCreateNestedOneWithoutUSERInput = {
    create?: XOR<CHATCreateWithoutUSERInput, CHATUncheckedCreateWithoutUSERInput>
    connectOrCreate?: CHATCreateOrConnectWithoutUSERInput
    connect?: CHATWhereUniqueInput
  }

  export type MESSAGECreateNestedOneWithoutUSERInput = {
    create?: XOR<MESSAGECreateWithoutUSERInput, MESSAGEUncheckedCreateWithoutUSERInput>
    connectOrCreate?: MESSAGECreateOrConnectWithoutUSERInput
    connect?: MESSAGEWhereUniqueInput
  }

  export type ORDERCreateNestedOneWithoutUSERInput = {
    create?: XOR<ORDERCreateWithoutUSERInput, ORDERUncheckedCreateWithoutUSERInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutUSERInput
    connect?: ORDERWhereUniqueInput
  }

  export type REPORTCreateNestedOneWithoutUSERInput = {
    create?: XOR<REPORTCreateWithoutUSERInput, REPORTUncheckedCreateWithoutUSERInput>
    connectOrCreate?: REPORTCreateOrConnectWithoutUSERInput
    connect?: REPORTWhereUniqueInput
  }

  export type RES_REVIEWCreateNestedOneWithoutUSERInput = {
    create?: XOR<RES_REVIEWCreateWithoutUSERInput, RES_REVIEWUncheckedCreateWithoutUSERInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutUSERInput
    connect?: RES_REVIEWWhereUniqueInput
  }

  export type USER_REVIEWCreateNestedOneWithoutUSERInput = {
    create?: XOR<USER_REVIEWCreateWithoutUSERInput, USER_REVIEWUncheckedCreateWithoutUSERInput>
    connectOrCreate?: USER_REVIEWCreateOrConnectWithoutUSERInput
    connect?: USER_REVIEWWhereUniqueInput
  }

  export type CALLUncheckedCreateNestedOneWithoutUSERInput = {
    create?: XOR<CALLCreateWithoutUSERInput, CALLUncheckedCreateWithoutUSERInput>
    connectOrCreate?: CALLCreateOrConnectWithoutUSERInput
    connect?: CALLWhereUniqueInput
  }

  export type CARTUncheckedCreateNestedOneWithoutUSERInput = {
    create?: XOR<CARTCreateWithoutUSERInput, CARTUncheckedCreateWithoutUSERInput>
    connectOrCreate?: CARTCreateOrConnectWithoutUSERInput
    connect?: CARTWhereUniqueInput
  }

  export type CHATUncheckedCreateNestedOneWithoutUSERInput = {
    create?: XOR<CHATCreateWithoutUSERInput, CHATUncheckedCreateWithoutUSERInput>
    connectOrCreate?: CHATCreateOrConnectWithoutUSERInput
    connect?: CHATWhereUniqueInput
  }

  export type MESSAGEUncheckedCreateNestedOneWithoutUSERInput = {
    create?: XOR<MESSAGECreateWithoutUSERInput, MESSAGEUncheckedCreateWithoutUSERInput>
    connectOrCreate?: MESSAGECreateOrConnectWithoutUSERInput
    connect?: MESSAGEWhereUniqueInput
  }

  export type ORDERUncheckedCreateNestedOneWithoutUSERInput = {
    create?: XOR<ORDERCreateWithoutUSERInput, ORDERUncheckedCreateWithoutUSERInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutUSERInput
    connect?: ORDERWhereUniqueInput
  }

  export type REPORTUncheckedCreateNestedOneWithoutUSERInput = {
    create?: XOR<REPORTCreateWithoutUSERInput, REPORTUncheckedCreateWithoutUSERInput>
    connectOrCreate?: REPORTCreateOrConnectWithoutUSERInput
    connect?: REPORTWhereUniqueInput
  }

  export type RES_REVIEWUncheckedCreateNestedOneWithoutUSERInput = {
    create?: XOR<RES_REVIEWCreateWithoutUSERInput, RES_REVIEWUncheckedCreateWithoutUSERInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutUSERInput
    connect?: RES_REVIEWWhereUniqueInput
  }

  export type USER_REVIEWUncheckedCreateNestedOneWithoutUSERInput = {
    create?: XOR<USER_REVIEWCreateWithoutUSERInput, USER_REVIEWUncheckedCreateWithoutUSERInput>
    connectOrCreate?: USER_REVIEWCreateOrConnectWithoutUSERInput
    connect?: USER_REVIEWWhereUniqueInput
  }

  export type EnumUSER_statusFieldUpdateOperationsInput = {
    set?: USER_status
  }

  export type CALLUpdateOneWithoutUSERInput = {
    create?: XOR<CALLCreateWithoutUSERInput, CALLUncheckedCreateWithoutUSERInput>
    connectOrCreate?: CALLCreateOrConnectWithoutUSERInput
    upsert?: CALLUpsertWithoutUSERInput
    connect?: CALLWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CALLUpdateWithoutUSERInput, CALLUncheckedUpdateWithoutUSERInput>
  }

  export type CARTUpdateOneWithoutUSERInput = {
    create?: XOR<CARTCreateWithoutUSERInput, CARTUncheckedCreateWithoutUSERInput>
    connectOrCreate?: CARTCreateOrConnectWithoutUSERInput
    upsert?: CARTUpsertWithoutUSERInput
    connect?: CARTWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CARTUpdateWithoutUSERInput, CARTUncheckedUpdateWithoutUSERInput>
  }

  export type CHATUpdateOneWithoutUSERInput = {
    create?: XOR<CHATCreateWithoutUSERInput, CHATUncheckedCreateWithoutUSERInput>
    connectOrCreate?: CHATCreateOrConnectWithoutUSERInput
    upsert?: CHATUpsertWithoutUSERInput
    connect?: CHATWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CHATUpdateWithoutUSERInput, CHATUncheckedUpdateWithoutUSERInput>
  }

  export type MESSAGEUpdateOneWithoutUSERInput = {
    create?: XOR<MESSAGECreateWithoutUSERInput, MESSAGEUncheckedCreateWithoutUSERInput>
    connectOrCreate?: MESSAGECreateOrConnectWithoutUSERInput
    upsert?: MESSAGEUpsertWithoutUSERInput
    connect?: MESSAGEWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MESSAGEUpdateWithoutUSERInput, MESSAGEUncheckedUpdateWithoutUSERInput>
  }

  export type ORDERUpdateOneWithoutUSERInput = {
    create?: XOR<ORDERCreateWithoutUSERInput, ORDERUncheckedCreateWithoutUSERInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutUSERInput
    upsert?: ORDERUpsertWithoutUSERInput
    connect?: ORDERWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ORDERUpdateWithoutUSERInput, ORDERUncheckedUpdateWithoutUSERInput>
  }

  export type REPORTUpdateOneWithoutUSERInput = {
    create?: XOR<REPORTCreateWithoutUSERInput, REPORTUncheckedCreateWithoutUSERInput>
    connectOrCreate?: REPORTCreateOrConnectWithoutUSERInput
    upsert?: REPORTUpsertWithoutUSERInput
    connect?: REPORTWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<REPORTUpdateWithoutUSERInput, REPORTUncheckedUpdateWithoutUSERInput>
  }

  export type RES_REVIEWUpdateOneWithoutUSERInput = {
    create?: XOR<RES_REVIEWCreateWithoutUSERInput, RES_REVIEWUncheckedCreateWithoutUSERInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutUSERInput
    upsert?: RES_REVIEWUpsertWithoutUSERInput
    connect?: RES_REVIEWWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RES_REVIEWUpdateWithoutUSERInput, RES_REVIEWUncheckedUpdateWithoutUSERInput>
  }

  export type USER_REVIEWUpdateOneWithoutUSERInput = {
    create?: XOR<USER_REVIEWCreateWithoutUSERInput, USER_REVIEWUncheckedCreateWithoutUSERInput>
    connectOrCreate?: USER_REVIEWCreateOrConnectWithoutUSERInput
    upsert?: USER_REVIEWUpsertWithoutUSERInput
    connect?: USER_REVIEWWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<USER_REVIEWUpdateWithoutUSERInput, USER_REVIEWUncheckedUpdateWithoutUSERInput>
  }

  export type CALLUncheckedUpdateOneWithoutUSERInput = {
    create?: XOR<CALLCreateWithoutUSERInput, CALLUncheckedCreateWithoutUSERInput>
    connectOrCreate?: CALLCreateOrConnectWithoutUSERInput
    upsert?: CALLUpsertWithoutUSERInput
    connect?: CALLWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CALLUpdateWithoutUSERInput, CALLUncheckedUpdateWithoutUSERInput>
  }

  export type CARTUncheckedUpdateOneWithoutUSERInput = {
    create?: XOR<CARTCreateWithoutUSERInput, CARTUncheckedCreateWithoutUSERInput>
    connectOrCreate?: CARTCreateOrConnectWithoutUSERInput
    upsert?: CARTUpsertWithoutUSERInput
    connect?: CARTWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CARTUpdateWithoutUSERInput, CARTUncheckedUpdateWithoutUSERInput>
  }

  export type CHATUncheckedUpdateOneWithoutUSERInput = {
    create?: XOR<CHATCreateWithoutUSERInput, CHATUncheckedCreateWithoutUSERInput>
    connectOrCreate?: CHATCreateOrConnectWithoutUSERInput
    upsert?: CHATUpsertWithoutUSERInput
    connect?: CHATWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CHATUpdateWithoutUSERInput, CHATUncheckedUpdateWithoutUSERInput>
  }

  export type MESSAGEUncheckedUpdateOneWithoutUSERInput = {
    create?: XOR<MESSAGECreateWithoutUSERInput, MESSAGEUncheckedCreateWithoutUSERInput>
    connectOrCreate?: MESSAGECreateOrConnectWithoutUSERInput
    upsert?: MESSAGEUpsertWithoutUSERInput
    connect?: MESSAGEWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<MESSAGEUpdateWithoutUSERInput, MESSAGEUncheckedUpdateWithoutUSERInput>
  }

  export type ORDERUncheckedUpdateOneWithoutUSERInput = {
    create?: XOR<ORDERCreateWithoutUSERInput, ORDERUncheckedCreateWithoutUSERInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutUSERInput
    upsert?: ORDERUpsertWithoutUSERInput
    connect?: ORDERWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ORDERUpdateWithoutUSERInput, ORDERUncheckedUpdateWithoutUSERInput>
  }

  export type REPORTUncheckedUpdateOneWithoutUSERInput = {
    create?: XOR<REPORTCreateWithoutUSERInput, REPORTUncheckedCreateWithoutUSERInput>
    connectOrCreate?: REPORTCreateOrConnectWithoutUSERInput
    upsert?: REPORTUpsertWithoutUSERInput
    connect?: REPORTWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<REPORTUpdateWithoutUSERInput, REPORTUncheckedUpdateWithoutUSERInput>
  }

  export type RES_REVIEWUncheckedUpdateOneWithoutUSERInput = {
    create?: XOR<RES_REVIEWCreateWithoutUSERInput, RES_REVIEWUncheckedCreateWithoutUSERInput>
    connectOrCreate?: RES_REVIEWCreateOrConnectWithoutUSERInput
    upsert?: RES_REVIEWUpsertWithoutUSERInput
    connect?: RES_REVIEWWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<RES_REVIEWUpdateWithoutUSERInput, RES_REVIEWUncheckedUpdateWithoutUSERInput>
  }

  export type USER_REVIEWUncheckedUpdateOneWithoutUSERInput = {
    create?: XOR<USER_REVIEWCreateWithoutUSERInput, USER_REVIEWUncheckedCreateWithoutUSERInput>
    connectOrCreate?: USER_REVIEWCreateOrConnectWithoutUSERInput
    upsert?: USER_REVIEWUpsertWithoutUSERInput
    connect?: USER_REVIEWWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<USER_REVIEWUpdateWithoutUSERInput, USER_REVIEWUncheckedUpdateWithoutUSERInput>
  }

  export type ORDERCreateNestedOneWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput = {
    create?: XOR<ORDERCreateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput, ORDERUncheckedCreateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput
    connect?: ORDERWhereUniqueInput
  }

  export type USERCreateNestedOneWithoutUSER_REVIEWInput = {
    create?: XOR<USERCreateWithoutUSER_REVIEWInput, USERUncheckedCreateWithoutUSER_REVIEWInput>
    connectOrCreate?: USERCreateOrConnectWithoutUSER_REVIEWInput
    connect?: USERWhereUniqueInput
  }

  export type ORDERCreateNestedOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput = {
    create?: XOR<ORDERCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput, ORDERUncheckedCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
    connect?: ORDERWhereUniqueInput
  }

  export type ORDERUncheckedCreateNestedOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput = {
    create?: XOR<ORDERCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput, ORDERUncheckedCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
    connect?: ORDERWhereUniqueInput
  }

  export type ORDERUpdateOneRequiredWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput = {
    create?: XOR<ORDERCreateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput, ORDERUncheckedCreateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput
    upsert?: ORDERUpsertWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput
    connect?: ORDERWhereUniqueInput
    update?: XOR<ORDERUpdateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput, ORDERUncheckedUpdateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput>
  }

  export type USERUpdateOneRequiredWithoutUSER_REVIEWInput = {
    create?: XOR<USERCreateWithoutUSER_REVIEWInput, USERUncheckedCreateWithoutUSER_REVIEWInput>
    connectOrCreate?: USERCreateOrConnectWithoutUSER_REVIEWInput
    upsert?: USERUpsertWithoutUSER_REVIEWInput
    connect?: USERWhereUniqueInput
    update?: XOR<USERUpdateWithoutUSER_REVIEWInput, USERUncheckedUpdateWithoutUSER_REVIEWInput>
  }

  export type ORDERUpdateOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput = {
    create?: XOR<ORDERCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput, ORDERUncheckedCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
    upsert?: ORDERUpsertWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
    connect?: ORDERWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ORDERUpdateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput, ORDERUncheckedUpdateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput>
  }

  export type ORDERUncheckedUpdateOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput = {
    create?: XOR<ORDERCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput, ORDERUncheckedCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput>
    connectOrCreate?: ORDERCreateOrConnectWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
    upsert?: ORDERUpsertWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
    connect?: ORDERWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<ORDERUpdateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput, ORDERUncheckedUpdateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedEnumCALL_statusNullableFilter = {
    equals?: CALL_status | null
    in?: Enumerable<CALL_status> | null
    notIn?: Enumerable<CALL_status> | null
    not?: NestedEnumCALL_statusNullableFilter | CALL_status | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedIntFilter
    min?: NestedIntFilter
    max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    count?: NestedIntNullableFilter
    min?: NestedDateTimeNullableFilter
    max?: NestedDateTimeNullableFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedEnumCALL_statusNullableWithAggregatesFilter = {
    equals?: CALL_status | null
    in?: Enumerable<CALL_status> | null
    notIn?: Enumerable<CALL_status> | null
    not?: NestedEnumCALL_statusNullableWithAggregatesFilter | CALL_status | null
    count?: NestedIntNullableFilter
    min?: NestedEnumCALL_statusNullableFilter
    max?: NestedEnumCALL_statusNullableFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    count?: NestedIntNullableFilter
    min?: NestedStringNullableFilter
    max?: NestedStringNullableFilter
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    count?: NestedIntFilter
    min?: NestedDateTimeFilter
    max?: NestedDateTimeFilter
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    count?: NestedIntFilter
    avg?: NestedFloatFilter
    sum?: NestedFloatFilter
    min?: NestedFloatFilter
    max?: NestedFloatFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    count?: NestedIntFilter
    min?: NestedStringFilter
    max?: NestedStringFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    count?: NestedIntFilter
    min?: NestedBoolFilter
    max?: NestedBoolFilter
  }

  export type NestedEnumORDER_statusNullableFilter = {
    equals?: ORDER_status | null
    in?: Enumerable<ORDER_status> | null
    notIn?: Enumerable<ORDER_status> | null
    not?: NestedEnumORDER_statusNullableFilter | ORDER_status | null
  }

  export type NestedEnumORDER_statusNullableWithAggregatesFilter = {
    equals?: ORDER_status | null
    in?: Enumerable<ORDER_status> | null
    notIn?: Enumerable<ORDER_status> | null
    not?: NestedEnumORDER_statusNullableWithAggregatesFilter | ORDER_status | null
    count?: NestedIntNullableFilter
    min?: NestedEnumORDER_statusNullableFilter
    max?: NestedEnumORDER_statusNullableFilter
  }

  export type NestedEnumUSER_statusFilter = {
    equals?: USER_status
    in?: Enumerable<USER_status>
    notIn?: Enumerable<USER_status>
    not?: NestedEnumUSER_statusFilter | USER_status
  }

  export type NestedEnumUSER_statusWithAggregatesFilter = {
    equals?: USER_status
    in?: Enumerable<USER_status>
    notIn?: Enumerable<USER_status>
    not?: NestedEnumUSER_statusWithAggregatesFilter | USER_status
    count?: NestedIntFilter
    min?: NestedEnumUSER_statusFilter
    max?: NestedEnumUSER_statusFilter
  }

  export type RESTAURANTCreateWithoutCALLInput = {
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    LOCATION?: LOCATIONCreateNestedOneWithoutRESTAURANTInput
    RUN_TIME?: RUN_TIMECreateNestedOneWithoutRESTAURANTInput
    MENU?: MENUCreateNestedOneWithoutRESTAURANTInput
    REPLY?: REPLYCreateNestedOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedCreateWithoutCALLInput = {
    seq?: number
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    MENU?: MENUUncheckedCreateNestedOneWithoutRESTAURANTInput
    REPLY?: REPLYUncheckedCreateNestedOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTCreateOrConnectWithoutCALLInput = {
    where: RESTAURANTWhereUniqueInput
    create: XOR<RESTAURANTCreateWithoutCALLInput, RESTAURANTUncheckedCreateWithoutCALLInput>
  }

  export type LOCATIONCreateWithoutCALLInput = {
    latitude: number
    longitude: number
    address: string
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutLOCATIONInput
  }

  export type LOCATIONUncheckedCreateWithoutCALLInput = {
    seq?: number
    latitude: number
    longitude: number
    address: string
    RESTAURANT?: RESTAURANTUncheckedCreateNestedOneWithoutLOCATIONInput
  }

  export type LOCATIONCreateOrConnectWithoutCALLInput = {
    where: LOCATIONWhereUniqueInput
    create: XOR<LOCATIONCreateWithoutCALLInput, LOCATIONUncheckedCreateWithoutCALLInput>
  }

  export type USERCreateWithoutCALLInput = {
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CART?: CARTCreateNestedOneWithoutUSERInput
    CHAT?: CHATCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGECreateNestedOneWithoutUSERInput
    ORDER?: ORDERCreateNestedOneWithoutUSERInput
    REPORT?: REPORTCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWCreateNestedOneWithoutUSERInput
  }

  export type USERUncheckedCreateWithoutCALLInput = {
    seq?: number
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CART?: CARTUncheckedCreateNestedOneWithoutUSERInput
    CHAT?: CHATUncheckedCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedCreateNestedOneWithoutUSERInput
    ORDER?: ORDERUncheckedCreateNestedOneWithoutUSERInput
    REPORT?: REPORTUncheckedCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedCreateNestedOneWithoutUSERInput
  }

  export type USERCreateOrConnectWithoutCALLInput = {
    where: USERWhereUniqueInput
    create: XOR<USERCreateWithoutCALLInput, USERUncheckedCreateWithoutCALLInput>
  }

  export type CARTCreateWithoutCALLInput = {
    request?: string | null
    SELECTED_MENU?: SELECTED_MENUCreateNestedOneWithoutCARTInput
    USER?: USERCreateNestedOneWithoutCARTInput
  }

  export type CARTUncheckedCreateWithoutCALLInput = {
    request?: string | null
  }

  export type CARTCreateOrConnectWithoutCALLInput = {
    where: CARTWhereUniqueInput
    create: XOR<CARTCreateWithoutCALLInput, CARTUncheckedCreateWithoutCALLInput>
  }

  export type ORDERCreateWithoutCALLInput = {
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutORDERInput
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: USER_REVIEWCreateNestedOneWithoutORDER_ORDER_seqToUSER_REVIEWInput
    USER?: USERCreateNestedOneWithoutORDERInput
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWCreateNestedOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERUncheckedCreateWithoutCALLInput = {
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUncheckedCreateNestedOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERCreateOrConnectWithoutCALLInput = {
    where: ORDERWhereUniqueInput
    create: XOR<ORDERCreateWithoutCALLInput, ORDERUncheckedCreateWithoutCALLInput>
  }

  export type RESTAURANTUpsertWithoutCALLInput = {
    update: XOR<RESTAURANTUpdateWithoutCALLInput, RESTAURANTUncheckedUpdateWithoutCALLInput>
    create: XOR<RESTAURANTCreateWithoutCALLInput, RESTAURANTUncheckedCreateWithoutCALLInput>
  }

  export type RESTAURANTUpdateWithoutCALLInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    LOCATION?: LOCATIONUpdateOneRequiredWithoutRESTAURANTInput
    RUN_TIME?: RUN_TIMEUpdateOneRequiredWithoutRESTAURANTInput
    MENU?: MENUUpdateOneWithoutRESTAURANTInput
    REPLY?: REPLYUpdateOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedUpdateWithoutCALLInput = {
    seq?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    MENU?: MENUUncheckedUpdateOneWithoutRESTAURANTInput
    REPLY?: REPLYUncheckedUpdateOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutRESTAURANTInput
  }

  export type LOCATIONUpsertWithoutCALLInput = {
    update: XOR<LOCATIONUpdateWithoutCALLInput, LOCATIONUncheckedUpdateWithoutCALLInput>
    create: XOR<LOCATIONCreateWithoutCALLInput, LOCATIONUncheckedCreateWithoutCALLInput>
  }

  export type LOCATIONUpdateWithoutCALLInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    RESTAURANT?: RESTAURANTUpdateOneWithoutLOCATIONInput
  }

  export type LOCATIONUncheckedUpdateWithoutCALLInput = {
    seq?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    RESTAURANT?: RESTAURANTUncheckedUpdateOneWithoutLOCATIONInput
  }

  export type USERUpsertWithoutCALLInput = {
    update: XOR<USERUpdateWithoutCALLInput, USERUncheckedUpdateWithoutCALLInput>
    create: XOR<USERCreateWithoutCALLInput, USERUncheckedCreateWithoutCALLInput>
  }

  export type USERUpdateWithoutCALLInput = {
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CART?: CARTUpdateOneWithoutUSERInput
    CHAT?: CHATUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUpdateOneWithoutUSERInput
    ORDER?: ORDERUpdateOneWithoutUSERInput
    REPORT?: REPORTUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUpdateOneWithoutUSERInput
  }

  export type USERUncheckedUpdateWithoutCALLInput = {
    seq?: IntFieldUpdateOperationsInput | number
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CART?: CARTUncheckedUpdateOneWithoutUSERInput
    CHAT?: CHATUncheckedUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedUpdateOneWithoutUSERInput
    ORDER?: ORDERUncheckedUpdateOneWithoutUSERInput
    REPORT?: REPORTUncheckedUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedUpdateOneWithoutUSERInput
  }

  export type CARTUpsertWithoutCALLInput = {
    update: XOR<CARTUpdateWithoutCALLInput, CARTUncheckedUpdateWithoutCALLInput>
    create: XOR<CARTCreateWithoutCALLInput, CARTUncheckedCreateWithoutCALLInput>
  }

  export type CARTUpdateWithoutCALLInput = {
    request?: NullableStringFieldUpdateOperationsInput | string | null
    SELECTED_MENU?: SELECTED_MENUUpdateOneRequiredWithoutCARTInput
    USER?: USERUpdateOneRequiredWithoutCARTInput
  }

  export type CARTUncheckedUpdateWithoutCALLInput = {
    request?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ORDERUpsertWithoutCALLInput = {
    update: XOR<ORDERUpdateWithoutCALLInput, ORDERUncheckedUpdateWithoutCALLInput>
    create: XOR<ORDERCreateWithoutCALLInput, ORDERUncheckedCreateWithoutCALLInput>
  }

  export type ORDERUpdateWithoutCALLInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
    RES_REVIEW?: RES_REVIEWUpdateOneRequiredWithoutORDERInput
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: USER_REVIEWUpdateOneRequiredWithoutORDER_ORDER_seqToUSER_REVIEWInput
    USER?: USERUpdateOneRequiredWithoutORDERInput
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUpdateOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERUncheckedUpdateWithoutCALLInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUncheckedUpdateOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type CALLCreateWithoutCARTInput = {
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutCALLInput
    LOCATION?: LOCATIONCreateNestedOneWithoutCALLInput
    USER?: USERCreateNestedOneWithoutCALLInput
    ORDER?: ORDERCreateNestedOneWithoutCALLInput
  }

  export type CALLUncheckedCreateWithoutCARTInput = {
    seq?: number
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
    ORDER?: ORDERUncheckedCreateNestedOneWithoutCALLInput
  }

  export type CALLCreateOrConnectWithoutCARTInput = {
    where: CALLWhereUniqueInput
    create: XOR<CALLCreateWithoutCARTInput, CALLUncheckedCreateWithoutCARTInput>
  }

  export type SELECTED_MENUCreateWithoutCARTInput = {
    count?: number
    OPTION_ITEM?: OPTION_ITEMCreateNestedOneWithoutSELECTED_MENUInput
    MENU?: MENUCreateNestedOneWithoutSELECTED_MENUInput
  }

  export type SELECTED_MENUUncheckedCreateWithoutCARTInput = {
    seq?: number
    count?: number
  }

  export type SELECTED_MENUCreateOrConnectWithoutCARTInput = {
    where: SELECTED_MENUWhereUniqueInput
    create: XOR<SELECTED_MENUCreateWithoutCARTInput, SELECTED_MENUUncheckedCreateWithoutCARTInput>
  }

  export type USERCreateWithoutCARTInput = {
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLCreateNestedOneWithoutUSERInput
    CHAT?: CHATCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGECreateNestedOneWithoutUSERInput
    ORDER?: ORDERCreateNestedOneWithoutUSERInput
    REPORT?: REPORTCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWCreateNestedOneWithoutUSERInput
  }

  export type USERUncheckedCreateWithoutCARTInput = {
    seq?: number
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLUncheckedCreateNestedOneWithoutUSERInput
    CHAT?: CHATUncheckedCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedCreateNestedOneWithoutUSERInput
    ORDER?: ORDERUncheckedCreateNestedOneWithoutUSERInput
    REPORT?: REPORTUncheckedCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedCreateNestedOneWithoutUSERInput
  }

  export type USERCreateOrConnectWithoutCARTInput = {
    where: USERWhereUniqueInput
    create: XOR<USERCreateWithoutCARTInput, USERUncheckedCreateWithoutCARTInput>
  }

  export type CALLUpsertWithoutCARTInput = {
    update: XOR<CALLUpdateWithoutCARTInput, CALLUncheckedUpdateWithoutCARTInput>
    create: XOR<CALLCreateWithoutCARTInput, CALLUncheckedCreateWithoutCARTInput>
  }

  export type CALLUpdateWithoutCARTInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutCALLInput
    LOCATION?: LOCATIONUpdateOneRequiredWithoutCALLInput
    USER?: USERUpdateOneRequiredWithoutCALLInput
    ORDER?: ORDERUpdateOneWithoutCALLInput
  }

  export type CALLUncheckedUpdateWithoutCARTInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    ORDER?: ORDERUncheckedUpdateOneWithoutCALLInput
  }

  export type SELECTED_MENUUpsertWithoutCARTInput = {
    update: XOR<SELECTED_MENUUpdateWithoutCARTInput, SELECTED_MENUUncheckedUpdateWithoutCARTInput>
    create: XOR<SELECTED_MENUCreateWithoutCARTInput, SELECTED_MENUUncheckedCreateWithoutCARTInput>
  }

  export type SELECTED_MENUUpdateWithoutCARTInput = {
    count?: IntFieldUpdateOperationsInput | number
    OPTION_ITEM?: OPTION_ITEMUpdateOneRequiredWithoutSELECTED_MENUInput
    MENU?: MENUUpdateOneRequiredWithoutSELECTED_MENUInput
  }

  export type SELECTED_MENUUncheckedUpdateWithoutCARTInput = {
    seq?: IntFieldUpdateOperationsInput | number
    count?: IntFieldUpdateOperationsInput | number
  }

  export type USERUpsertWithoutCARTInput = {
    update: XOR<USERUpdateWithoutCARTInput, USERUncheckedUpdateWithoutCARTInput>
    create: XOR<USERCreateWithoutCARTInput, USERUncheckedCreateWithoutCARTInput>
  }

  export type USERUpdateWithoutCARTInput = {
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUpdateOneWithoutUSERInput
    CHAT?: CHATUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUpdateOneWithoutUSERInput
    ORDER?: ORDERUpdateOneWithoutUSERInput
    REPORT?: REPORTUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUpdateOneWithoutUSERInput
  }

  export type USERUncheckedUpdateWithoutCARTInput = {
    seq?: IntFieldUpdateOperationsInput | number
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUncheckedUpdateOneWithoutUSERInput
    CHAT?: CHATUncheckedUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedUpdateOneWithoutUSERInput
    ORDER?: ORDERUncheckedUpdateOneWithoutUSERInput
    REPORT?: REPORTUncheckedUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedUpdateOneWithoutUSERInput
  }

  export type USERCreateWithoutCHATInput = {
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLCreateNestedOneWithoutUSERInput
    CART?: CARTCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGECreateNestedOneWithoutUSERInput
    ORDER?: ORDERCreateNestedOneWithoutUSERInput
    REPORT?: REPORTCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWCreateNestedOneWithoutUSERInput
  }

  export type USERUncheckedCreateWithoutCHATInput = {
    seq?: number
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLUncheckedCreateNestedOneWithoutUSERInput
    CART?: CARTUncheckedCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedCreateNestedOneWithoutUSERInput
    ORDER?: ORDERUncheckedCreateNestedOneWithoutUSERInput
    REPORT?: REPORTUncheckedCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedCreateNestedOneWithoutUSERInput
  }

  export type USERCreateOrConnectWithoutCHATInput = {
    where: USERWhereUniqueInput
    create: XOR<USERCreateWithoutCHATInput, USERUncheckedCreateWithoutCHATInput>
  }

  export type MESSAGECreateWithoutCHAT_CHAT_seqToMESSAGEInput = {
    text: string
    isRead?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
    USER?: USERCreateNestedOneWithoutMESSAGEInput
    CHAT_CHATToMESSAGE_seq?: CHATCreateNestedOneWithoutMESSAGE_CHATToMESSAGE_seqInput
  }

  export type MESSAGEUncheckedCreateWithoutCHAT_CHAT_seqToMESSAGEInput = {
    seq?: number
    text: string
    isRead?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type MESSAGECreateOrConnectWithoutCHAT_CHAT_seqToMESSAGEInput = {
    where: MESSAGEWhereUniqueInput
    create: XOR<MESSAGECreateWithoutCHAT_CHAT_seqToMESSAGEInput, MESSAGEUncheckedCreateWithoutCHAT_CHAT_seqToMESSAGEInput>
  }

  export type MESSAGECreateWithoutCHAT_CHATToMESSAGE_seqInput = {
    text: string
    isRead?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
    USER?: USERCreateNestedOneWithoutMESSAGEInput
    CHAT_CHAT_seqToMESSAGE?: CHATCreateNestedOneWithoutMESSAGE_CHAT_seqToMESSAGEInput
  }

  export type MESSAGEUncheckedCreateWithoutCHAT_CHATToMESSAGE_seqInput = {
    text: string
    isRead?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
    CHAT_CHAT_seqToMESSAGE?: CHATUncheckedCreateNestedOneWithoutMESSAGE_CHAT_seqToMESSAGEInput
  }

  export type MESSAGECreateOrConnectWithoutCHAT_CHATToMESSAGE_seqInput = {
    where: MESSAGEWhereUniqueInput
    create: XOR<MESSAGECreateWithoutCHAT_CHATToMESSAGE_seqInput, MESSAGEUncheckedCreateWithoutCHAT_CHATToMESSAGE_seqInput>
  }

  export type USERUpsertWithoutCHATInput = {
    update: XOR<USERUpdateWithoutCHATInput, USERUncheckedUpdateWithoutCHATInput>
    create: XOR<USERCreateWithoutCHATInput, USERUncheckedCreateWithoutCHATInput>
  }

  export type USERUpdateWithoutCHATInput = {
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUpdateOneWithoutUSERInput
    CART?: CARTUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUpdateOneWithoutUSERInput
    ORDER?: ORDERUpdateOneWithoutUSERInput
    REPORT?: REPORTUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUpdateOneWithoutUSERInput
  }

  export type USERUncheckedUpdateWithoutCHATInput = {
    seq?: IntFieldUpdateOperationsInput | number
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUncheckedUpdateOneWithoutUSERInput
    CART?: CARTUncheckedUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedUpdateOneWithoutUSERInput
    ORDER?: ORDERUncheckedUpdateOneWithoutUSERInput
    REPORT?: REPORTUncheckedUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedUpdateOneWithoutUSERInput
  }

  export type MESSAGEUpsertWithoutCHAT_CHAT_seqToMESSAGEInput = {
    update: XOR<MESSAGEUpdateWithoutCHAT_CHAT_seqToMESSAGEInput, MESSAGEUncheckedUpdateWithoutCHAT_CHAT_seqToMESSAGEInput>
    create: XOR<MESSAGECreateWithoutCHAT_CHAT_seqToMESSAGEInput, MESSAGEUncheckedCreateWithoutCHAT_CHAT_seqToMESSAGEInput>
  }

  export type MESSAGEUpdateWithoutCHAT_CHAT_seqToMESSAGEInput = {
    text?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    USER?: USERUpdateOneRequiredWithoutMESSAGEInput
    CHAT_CHATToMESSAGE_seq?: CHATUpdateOneRequiredWithoutMESSAGE_CHATToMESSAGE_seqInput
  }

  export type MESSAGEUncheckedUpdateWithoutCHAT_CHAT_seqToMESSAGEInput = {
    seq?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MESSAGEUpsertWithoutCHAT_CHATToMESSAGE_seqInput = {
    update: XOR<MESSAGEUpdateWithoutCHAT_CHATToMESSAGE_seqInput, MESSAGEUncheckedUpdateWithoutCHAT_CHATToMESSAGE_seqInput>
    create: XOR<MESSAGECreateWithoutCHAT_CHATToMESSAGE_seqInput, MESSAGEUncheckedCreateWithoutCHAT_CHATToMESSAGE_seqInput>
  }

  export type MESSAGEUpdateWithoutCHAT_CHATToMESSAGE_seqInput = {
    text?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    USER?: USERUpdateOneRequiredWithoutMESSAGEInput
    CHAT_CHAT_seqToMESSAGE?: CHATUpdateOneWithoutMESSAGE_CHAT_seqToMESSAGEInput
  }

  export type MESSAGEUncheckedUpdateWithoutCHAT_CHATToMESSAGE_seqInput = {
    text?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CHAT_CHAT_seqToMESSAGE?: CHATUncheckedUpdateOneWithoutMESSAGE_CHAT_seqToMESSAGEInput
  }

  export type CALLCreateWithoutLOCATIONInput = {
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutCALLInput
    USER?: USERCreateNestedOneWithoutCALLInput
    CART?: CARTCreateNestedOneWithoutCALLInput
    ORDER?: ORDERCreateNestedOneWithoutCALLInput
  }

  export type CALLUncheckedCreateWithoutLOCATIONInput = {
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
    CART?: CARTUncheckedCreateNestedOneWithoutCALLInput
    ORDER?: ORDERUncheckedCreateNestedOneWithoutCALLInput
  }

  export type CALLCreateOrConnectWithoutLOCATIONInput = {
    where: CALLWhereUniqueInput
    create: XOR<CALLCreateWithoutLOCATIONInput, CALLUncheckedCreateWithoutLOCATIONInput>
  }

  export type RESTAURANTCreateWithoutLOCATIONInput = {
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    RUN_TIME?: RUN_TIMECreateNestedOneWithoutRESTAURANTInput
    CALL?: CALLCreateNestedOneWithoutRESTAURANTInput
    MENU?: MENUCreateNestedOneWithoutRESTAURANTInput
    REPLY?: REPLYCreateNestedOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedCreateWithoutLOCATIONInput = {
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    CALL?: CALLUncheckedCreateNestedOneWithoutRESTAURANTInput
    MENU?: MENUUncheckedCreateNestedOneWithoutRESTAURANTInput
    REPLY?: REPLYUncheckedCreateNestedOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTCreateOrConnectWithoutLOCATIONInput = {
    where: RESTAURANTWhereUniqueInput
    create: XOR<RESTAURANTCreateWithoutLOCATIONInput, RESTAURANTUncheckedCreateWithoutLOCATIONInput>
  }

  export type CALLUpsertWithoutLOCATIONInput = {
    update: XOR<CALLUpdateWithoutLOCATIONInput, CALLUncheckedUpdateWithoutLOCATIONInput>
    create: XOR<CALLCreateWithoutLOCATIONInput, CALLUncheckedCreateWithoutLOCATIONInput>
  }

  export type CALLUpdateWithoutLOCATIONInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutCALLInput
    USER?: USERUpdateOneRequiredWithoutCALLInput
    CART?: CARTUpdateOneWithoutCALLInput
    ORDER?: ORDERUpdateOneWithoutCALLInput
  }

  export type CALLUncheckedUpdateWithoutLOCATIONInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    CART?: CARTUncheckedUpdateOneWithoutCALLInput
    ORDER?: ORDERUncheckedUpdateOneWithoutCALLInput
  }

  export type RESTAURANTUpsertWithoutLOCATIONInput = {
    update: XOR<RESTAURANTUpdateWithoutLOCATIONInput, RESTAURANTUncheckedUpdateWithoutLOCATIONInput>
    create: XOR<RESTAURANTCreateWithoutLOCATIONInput, RESTAURANTUncheckedCreateWithoutLOCATIONInput>
  }

  export type RESTAURANTUpdateWithoutLOCATIONInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    RUN_TIME?: RUN_TIMEUpdateOneRequiredWithoutRESTAURANTInput
    CALL?: CALLUpdateOneWithoutRESTAURANTInput
    MENU?: MENUUpdateOneWithoutRESTAURANTInput
    REPLY?: REPLYUpdateOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedUpdateWithoutLOCATIONInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    CALL?: CALLUncheckedUpdateOneWithoutRESTAURANTInput
    MENU?: MENUUncheckedUpdateOneWithoutRESTAURANTInput
    REPLY?: REPLYUncheckedUpdateOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutRESTAURANTInput
  }

  export type RESTAURANTCreateWithoutMENUInput = {
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    LOCATION?: LOCATIONCreateNestedOneWithoutRESTAURANTInput
    RUN_TIME?: RUN_TIMECreateNestedOneWithoutRESTAURANTInput
    CALL?: CALLCreateNestedOneWithoutRESTAURANTInput
    REPLY?: REPLYCreateNestedOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedCreateWithoutMENUInput = {
    seq?: number
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    CALL?: CALLUncheckedCreateNestedOneWithoutRESTAURANTInput
    REPLY?: REPLYUncheckedCreateNestedOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTCreateOrConnectWithoutMENUInput = {
    where: RESTAURANTWhereUniqueInput
    create: XOR<RESTAURANTCreateWithoutMENUInput, RESTAURANTUncheckedCreateWithoutMENUInput>
  }

  export type OPTIONCreateWithoutMENUInput = {
    category: string
    isRequired: boolean
    isMultiple: boolean
    OPTION_ITEM?: OPTION_ITEMCreateNestedOneWithoutOPTIONInput
  }

  export type OPTIONUncheckedCreateWithoutMENUInput = {
    category: string
    isRequired: boolean
    isMultiple: boolean
    OPTION_ITEM?: OPTION_ITEMUncheckedCreateNestedOneWithoutOPTIONInput
  }

  export type OPTIONCreateOrConnectWithoutMENUInput = {
    where: OPTIONWhereUniqueInput
    create: XOR<OPTIONCreateWithoutMENUInput, OPTIONUncheckedCreateWithoutMENUInput>
  }

  export type SELECTED_MENUCreateWithoutMENUInput = {
    count?: number
    OPTION_ITEM?: OPTION_ITEMCreateNestedOneWithoutSELECTED_MENUInput
    CART?: CARTCreateNestedOneWithoutSELECTED_MENUInput
  }

  export type SELECTED_MENUUncheckedCreateWithoutMENUInput = {
    count?: number
    CART?: CARTUncheckedCreateNestedOneWithoutSELECTED_MENUInput
  }

  export type SELECTED_MENUCreateOrConnectWithoutMENUInput = {
    where: SELECTED_MENUWhereUniqueInput
    create: XOR<SELECTED_MENUCreateWithoutMENUInput, SELECTED_MENUUncheckedCreateWithoutMENUInput>
  }

  export type RESTAURANTUpsertWithoutMENUInput = {
    update: XOR<RESTAURANTUpdateWithoutMENUInput, RESTAURANTUncheckedUpdateWithoutMENUInput>
    create: XOR<RESTAURANTCreateWithoutMENUInput, RESTAURANTUncheckedCreateWithoutMENUInput>
  }

  export type RESTAURANTUpdateWithoutMENUInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    LOCATION?: LOCATIONUpdateOneRequiredWithoutRESTAURANTInput
    RUN_TIME?: RUN_TIMEUpdateOneRequiredWithoutRESTAURANTInput
    CALL?: CALLUpdateOneWithoutRESTAURANTInput
    REPLY?: REPLYUpdateOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedUpdateWithoutMENUInput = {
    seq?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    CALL?: CALLUncheckedUpdateOneWithoutRESTAURANTInput
    REPLY?: REPLYUncheckedUpdateOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutRESTAURANTInput
  }

  export type OPTIONUpsertWithoutMENUInput = {
    update: XOR<OPTIONUpdateWithoutMENUInput, OPTIONUncheckedUpdateWithoutMENUInput>
    create: XOR<OPTIONCreateWithoutMENUInput, OPTIONUncheckedCreateWithoutMENUInput>
  }

  export type OPTIONUpdateWithoutMENUInput = {
    category?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    OPTION_ITEM?: OPTION_ITEMUpdateOneWithoutOPTIONInput
  }

  export type OPTIONUncheckedUpdateWithoutMENUInput = {
    category?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    OPTION_ITEM?: OPTION_ITEMUncheckedUpdateOneWithoutOPTIONInput
  }

  export type SELECTED_MENUUpsertWithoutMENUInput = {
    update: XOR<SELECTED_MENUUpdateWithoutMENUInput, SELECTED_MENUUncheckedUpdateWithoutMENUInput>
    create: XOR<SELECTED_MENUCreateWithoutMENUInput, SELECTED_MENUUncheckedCreateWithoutMENUInput>
  }

  export type SELECTED_MENUUpdateWithoutMENUInput = {
    count?: IntFieldUpdateOperationsInput | number
    OPTION_ITEM?: OPTION_ITEMUpdateOneRequiredWithoutSELECTED_MENUInput
    CART?: CARTUpdateOneWithoutSELECTED_MENUInput
  }

  export type SELECTED_MENUUncheckedUpdateWithoutMENUInput = {
    count?: IntFieldUpdateOperationsInput | number
    CART?: CARTUncheckedUpdateOneWithoutSELECTED_MENUInput
  }

  export type USERCreateWithoutMESSAGEInput = {
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLCreateNestedOneWithoutUSERInput
    CART?: CARTCreateNestedOneWithoutUSERInput
    CHAT?: CHATCreateNestedOneWithoutUSERInput
    ORDER?: ORDERCreateNestedOneWithoutUSERInput
    REPORT?: REPORTCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWCreateNestedOneWithoutUSERInput
  }

  export type USERUncheckedCreateWithoutMESSAGEInput = {
    seq?: number
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLUncheckedCreateNestedOneWithoutUSERInput
    CART?: CARTUncheckedCreateNestedOneWithoutUSERInput
    CHAT?: CHATUncheckedCreateNestedOneWithoutUSERInput
    ORDER?: ORDERUncheckedCreateNestedOneWithoutUSERInput
    REPORT?: REPORTUncheckedCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedCreateNestedOneWithoutUSERInput
  }

  export type USERCreateOrConnectWithoutMESSAGEInput = {
    where: USERWhereUniqueInput
    create: XOR<USERCreateWithoutMESSAGEInput, USERUncheckedCreateWithoutMESSAGEInput>
  }

  export type CHATCreateWithoutMESSAGE_CHATToMESSAGE_seqInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    USER?: USERCreateNestedOneWithoutCHATInput
    MESSAGE_CHAT_seqToMESSAGE?: MESSAGECreateNestedOneWithoutCHAT_CHAT_seqToMESSAGEInput
  }

  export type CHATUncheckedCreateWithoutMESSAGE_CHATToMESSAGE_seqInput = {
    seq?: number
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type CHATCreateOrConnectWithoutMESSAGE_CHATToMESSAGE_seqInput = {
    where: CHATWhereUniqueInput
    create: XOR<CHATCreateWithoutMESSAGE_CHATToMESSAGE_seqInput, CHATUncheckedCreateWithoutMESSAGE_CHATToMESSAGE_seqInput>
  }

  export type CHATCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    USER?: USERCreateNestedOneWithoutCHATInput
    MESSAGE_CHATToMESSAGE_seq?: MESSAGECreateNestedOneWithoutCHAT_CHATToMESSAGE_seqInput
  }

  export type CHATUncheckedCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    MESSAGE_CHATToMESSAGE_seq?: MESSAGEUncheckedCreateNestedOneWithoutCHAT_CHATToMESSAGE_seqInput
  }

  export type CHATCreateOrConnectWithoutMESSAGE_CHAT_seqToMESSAGEInput = {
    where: CHATWhereUniqueInput
    create: XOR<CHATCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput, CHATUncheckedCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput>
  }

  export type USERUpsertWithoutMESSAGEInput = {
    update: XOR<USERUpdateWithoutMESSAGEInput, USERUncheckedUpdateWithoutMESSAGEInput>
    create: XOR<USERCreateWithoutMESSAGEInput, USERUncheckedCreateWithoutMESSAGEInput>
  }

  export type USERUpdateWithoutMESSAGEInput = {
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUpdateOneWithoutUSERInput
    CART?: CARTUpdateOneWithoutUSERInput
    CHAT?: CHATUpdateOneWithoutUSERInput
    ORDER?: ORDERUpdateOneWithoutUSERInput
    REPORT?: REPORTUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUpdateOneWithoutUSERInput
  }

  export type USERUncheckedUpdateWithoutMESSAGEInput = {
    seq?: IntFieldUpdateOperationsInput | number
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUncheckedUpdateOneWithoutUSERInput
    CART?: CARTUncheckedUpdateOneWithoutUSERInput
    CHAT?: CHATUncheckedUpdateOneWithoutUSERInput
    ORDER?: ORDERUncheckedUpdateOneWithoutUSERInput
    REPORT?: REPORTUncheckedUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedUpdateOneWithoutUSERInput
  }

  export type CHATUpsertWithoutMESSAGE_CHATToMESSAGE_seqInput = {
    update: XOR<CHATUpdateWithoutMESSAGE_CHATToMESSAGE_seqInput, CHATUncheckedUpdateWithoutMESSAGE_CHATToMESSAGE_seqInput>
    create: XOR<CHATCreateWithoutMESSAGE_CHATToMESSAGE_seqInput, CHATUncheckedCreateWithoutMESSAGE_CHATToMESSAGE_seqInput>
  }

  export type CHATUpdateWithoutMESSAGE_CHATToMESSAGE_seqInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    USER?: USERUpdateOneRequiredWithoutCHATInput
    MESSAGE_CHAT_seqToMESSAGE?: MESSAGEUpdateOneRequiredWithoutCHAT_CHAT_seqToMESSAGEInput
  }

  export type CHATUncheckedUpdateWithoutMESSAGE_CHATToMESSAGE_seqInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CHATUpsertWithoutMESSAGE_CHAT_seqToMESSAGEInput = {
    update: XOR<CHATUpdateWithoutMESSAGE_CHAT_seqToMESSAGEInput, CHATUncheckedUpdateWithoutMESSAGE_CHAT_seqToMESSAGEInput>
    create: XOR<CHATCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput, CHATUncheckedCreateWithoutMESSAGE_CHAT_seqToMESSAGEInput>
  }

  export type CHATUpdateWithoutMESSAGE_CHAT_seqToMESSAGEInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    USER?: USERUpdateOneRequiredWithoutCHATInput
    MESSAGE_CHATToMESSAGE_seq?: MESSAGEUpdateOneWithoutCHAT_CHATToMESSAGE_seqInput
  }

  export type CHATUncheckedUpdateWithoutMESSAGE_CHAT_seqToMESSAGEInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MESSAGE_CHATToMESSAGE_seq?: MESSAGEUncheckedUpdateOneWithoutCHAT_CHATToMESSAGE_seqInput
  }

  export type MENUCreateWithoutOPTIONInput = {
    name: string
    thumbnail?: string | null
    description?: string | null
    price: number
    isAvailable?: boolean
    bestmenu?: boolean
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutMENUInput
    SELECTED_MENU?: SELECTED_MENUCreateNestedOneWithoutMENUInput
  }

  export type MENUUncheckedCreateWithoutOPTIONInput = {
    seq?: number
    name: string
    thumbnail?: string | null
    description?: string | null
    price: number
    isAvailable?: boolean
    bestmenu?: boolean
    SELECTED_MENU?: SELECTED_MENUUncheckedCreateNestedOneWithoutMENUInput
  }

  export type MENUCreateOrConnectWithoutOPTIONInput = {
    where: MENUWhereUniqueInput
    create: XOR<MENUCreateWithoutOPTIONInput, MENUUncheckedCreateWithoutOPTIONInput>
  }

  export type OPTION_ITEMCreateWithoutOPTIONInput = {
    content: string
    price: number
    SELECTED_MENU?: SELECTED_MENUCreateNestedOneWithoutOPTION_ITEMInput
  }

  export type OPTION_ITEMUncheckedCreateWithoutOPTIONInput = {
    content: string
    price: number
    SELECTED_MENU?: SELECTED_MENUUncheckedCreateNestedOneWithoutOPTION_ITEMInput
  }

  export type OPTION_ITEMCreateOrConnectWithoutOPTIONInput = {
    where: OPTION_ITEMWhereUniqueInput
    create: XOR<OPTION_ITEMCreateWithoutOPTIONInput, OPTION_ITEMUncheckedCreateWithoutOPTIONInput>
  }

  export type MENUUpsertWithoutOPTIONInput = {
    update: XOR<MENUUpdateWithoutOPTIONInput, MENUUncheckedUpdateWithoutOPTIONInput>
    create: XOR<MENUCreateWithoutOPTIONInput, MENUUncheckedCreateWithoutOPTIONInput>
  }

  export type MENUUpdateWithoutOPTIONInput = {
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bestmenu?: BoolFieldUpdateOperationsInput | boolean
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutMENUInput
    SELECTED_MENU?: SELECTED_MENUUpdateOneWithoutMENUInput
  }

  export type MENUUncheckedUpdateWithoutOPTIONInput = {
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bestmenu?: BoolFieldUpdateOperationsInput | boolean
    SELECTED_MENU?: SELECTED_MENUUncheckedUpdateOneWithoutMENUInput
  }

  export type OPTION_ITEMUpsertWithoutOPTIONInput = {
    update: XOR<OPTION_ITEMUpdateWithoutOPTIONInput, OPTION_ITEMUncheckedUpdateWithoutOPTIONInput>
    create: XOR<OPTION_ITEMCreateWithoutOPTIONInput, OPTION_ITEMUncheckedCreateWithoutOPTIONInput>
  }

  export type OPTION_ITEMUpdateWithoutOPTIONInput = {
    content?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    SELECTED_MENU?: SELECTED_MENUUpdateOneWithoutOPTION_ITEMInput
  }

  export type OPTION_ITEMUncheckedUpdateWithoutOPTIONInput = {
    content?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    SELECTED_MENU?: SELECTED_MENUUncheckedUpdateOneWithoutOPTION_ITEMInput
  }

  export type OPTIONCreateWithoutOPTION_ITEMInput = {
    category: string
    isRequired: boolean
    isMultiple: boolean
    MENU?: MENUCreateNestedOneWithoutOPTIONInput
  }

  export type OPTIONUncheckedCreateWithoutOPTION_ITEMInput = {
    seq?: number
    category: string
    isRequired: boolean
    isMultiple: boolean
  }

  export type OPTIONCreateOrConnectWithoutOPTION_ITEMInput = {
    where: OPTIONWhereUniqueInput
    create: XOR<OPTIONCreateWithoutOPTION_ITEMInput, OPTIONUncheckedCreateWithoutOPTION_ITEMInput>
  }

  export type SELECTED_MENUCreateWithoutOPTION_ITEMInput = {
    count?: number
    MENU?: MENUCreateNestedOneWithoutSELECTED_MENUInput
    CART?: CARTCreateNestedOneWithoutSELECTED_MENUInput
  }

  export type SELECTED_MENUUncheckedCreateWithoutOPTION_ITEMInput = {
    count?: number
    CART?: CARTUncheckedCreateNestedOneWithoutSELECTED_MENUInput
  }

  export type SELECTED_MENUCreateOrConnectWithoutOPTION_ITEMInput = {
    where: SELECTED_MENUWhereUniqueInput
    create: XOR<SELECTED_MENUCreateWithoutOPTION_ITEMInput, SELECTED_MENUUncheckedCreateWithoutOPTION_ITEMInput>
  }

  export type OPTIONUpsertWithoutOPTION_ITEMInput = {
    update: XOR<OPTIONUpdateWithoutOPTION_ITEMInput, OPTIONUncheckedUpdateWithoutOPTION_ITEMInput>
    create: XOR<OPTIONCreateWithoutOPTION_ITEMInput, OPTIONUncheckedCreateWithoutOPTION_ITEMInput>
  }

  export type OPTIONUpdateWithoutOPTION_ITEMInput = {
    category?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
    MENU?: MENUUpdateOneRequiredWithoutOPTIONInput
  }

  export type OPTIONUncheckedUpdateWithoutOPTION_ITEMInput = {
    seq?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isMultiple?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SELECTED_MENUUpsertWithoutOPTION_ITEMInput = {
    update: XOR<SELECTED_MENUUpdateWithoutOPTION_ITEMInput, SELECTED_MENUUncheckedUpdateWithoutOPTION_ITEMInput>
    create: XOR<SELECTED_MENUCreateWithoutOPTION_ITEMInput, SELECTED_MENUUncheckedCreateWithoutOPTION_ITEMInput>
  }

  export type SELECTED_MENUUpdateWithoutOPTION_ITEMInput = {
    count?: IntFieldUpdateOperationsInput | number
    MENU?: MENUUpdateOneRequiredWithoutSELECTED_MENUInput
    CART?: CARTUpdateOneWithoutSELECTED_MENUInput
  }

  export type SELECTED_MENUUncheckedUpdateWithoutOPTION_ITEMInput = {
    count?: IntFieldUpdateOperationsInput | number
    CART?: CARTUncheckedUpdateOneWithoutSELECTED_MENUInput
  }

  export type RES_REVIEWCreateWithoutORDERInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content: string
    image?: string | null
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutRES_REVIEWInput
    REPLY?: REPLYCreateNestedOneWithoutRES_REVIEWInput
    USER?: USERCreateNestedOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWUncheckedCreateWithoutORDERInput = {
    seq?: number
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content: string
    image?: string | null
  }

  export type RES_REVIEWCreateOrConnectWithoutORDERInput = {
    where: RES_REVIEWWhereUniqueInput
    create: XOR<RES_REVIEWCreateWithoutORDERInput, RES_REVIEWUncheckedCreateWithoutORDERInput>
  }

  export type USER_REVIEWCreateWithoutORDER_ORDER_seqToUSER_REVIEWInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content?: string | null
    ORDER_ORDERToUSER_REVIEW_seq?: ORDERCreateNestedOneWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput
    USER?: USERCreateNestedOneWithoutUSER_REVIEWInput
  }

  export type USER_REVIEWUncheckedCreateWithoutORDER_ORDER_seqToUSER_REVIEWInput = {
    seq?: number
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content?: string | null
  }

  export type USER_REVIEWCreateOrConnectWithoutORDER_ORDER_seqToUSER_REVIEWInput = {
    where: USER_REVIEWWhereUniqueInput
    create: XOR<USER_REVIEWCreateWithoutORDER_ORDER_seqToUSER_REVIEWInput, USER_REVIEWUncheckedCreateWithoutORDER_ORDER_seqToUSER_REVIEWInput>
  }

  export type CALLCreateWithoutORDERInput = {
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutCALLInput
    LOCATION?: LOCATIONCreateNestedOneWithoutCALLInput
    USER?: USERCreateNestedOneWithoutCALLInput
    CART?: CARTCreateNestedOneWithoutCALLInput
  }

  export type CALLUncheckedCreateWithoutORDERInput = {
    seq?: number
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
    CART?: CARTUncheckedCreateNestedOneWithoutCALLInput
  }

  export type CALLCreateOrConnectWithoutORDERInput = {
    where: CALLWhereUniqueInput
    create: XOR<CALLCreateWithoutORDERInput, CALLUncheckedCreateWithoutORDERInput>
  }

  export type USERCreateWithoutORDERInput = {
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLCreateNestedOneWithoutUSERInput
    CART?: CARTCreateNestedOneWithoutUSERInput
    CHAT?: CHATCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGECreateNestedOneWithoutUSERInput
    REPORT?: REPORTCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWCreateNestedOneWithoutUSERInput
  }

  export type USERUncheckedCreateWithoutORDERInput = {
    seq?: number
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLUncheckedCreateNestedOneWithoutUSERInput
    CART?: CARTUncheckedCreateNestedOneWithoutUSERInput
    CHAT?: CHATUncheckedCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedCreateNestedOneWithoutUSERInput
    REPORT?: REPORTUncheckedCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedCreateNestedOneWithoutUSERInput
  }

  export type USERCreateOrConnectWithoutORDERInput = {
    where: USERWhereUniqueInput
    create: XOR<USERCreateWithoutORDERInput, USERUncheckedCreateWithoutORDERInput>
  }

  export type USER_REVIEWCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content?: string | null
    USER?: USERCreateNestedOneWithoutUSER_REVIEWInput
    ORDER_ORDER_seqToUSER_REVIEW?: ORDERCreateNestedOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
  }

  export type USER_REVIEWUncheckedCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content?: string | null
    ORDER_ORDER_seqToUSER_REVIEW?: ORDERUncheckedCreateNestedOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
  }

  export type USER_REVIEWCreateOrConnectWithoutORDER_ORDERToUSER_REVIEW_seqInput = {
    where: USER_REVIEWWhereUniqueInput
    create: XOR<USER_REVIEWCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput, USER_REVIEWUncheckedCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput>
  }

  export type RES_REVIEWUpsertWithoutORDERInput = {
    update: XOR<RES_REVIEWUpdateWithoutORDERInput, RES_REVIEWUncheckedUpdateWithoutORDERInput>
    create: XOR<RES_REVIEWCreateWithoutORDERInput, RES_REVIEWUncheckedCreateWithoutORDERInput>
  }

  export type RES_REVIEWUpdateWithoutORDERInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutRES_REVIEWInput
    REPLY?: REPLYUpdateOneRequiredWithoutRES_REVIEWInput
    USER?: USERUpdateOneRequiredWithoutRES_REVIEWInput
  }

  export type RES_REVIEWUncheckedUpdateWithoutORDERInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type USER_REVIEWUpsertWithoutORDER_ORDER_seqToUSER_REVIEWInput = {
    update: XOR<USER_REVIEWUpdateWithoutORDER_ORDER_seqToUSER_REVIEWInput, USER_REVIEWUncheckedUpdateWithoutORDER_ORDER_seqToUSER_REVIEWInput>
    create: XOR<USER_REVIEWCreateWithoutORDER_ORDER_seqToUSER_REVIEWInput, USER_REVIEWUncheckedCreateWithoutORDER_ORDER_seqToUSER_REVIEWInput>
  }

  export type USER_REVIEWUpdateWithoutORDER_ORDER_seqToUSER_REVIEWInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ORDER_ORDERToUSER_REVIEW_seq?: ORDERUpdateOneRequiredWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput
    USER?: USERUpdateOneRequiredWithoutUSER_REVIEWInput
  }

  export type USER_REVIEWUncheckedUpdateWithoutORDER_ORDER_seqToUSER_REVIEWInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CALLUpsertWithoutORDERInput = {
    update: XOR<CALLUpdateWithoutORDERInput, CALLUncheckedUpdateWithoutORDERInput>
    create: XOR<CALLCreateWithoutORDERInput, CALLUncheckedCreateWithoutORDERInput>
  }

  export type CALLUpdateWithoutORDERInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutCALLInput
    LOCATION?: LOCATIONUpdateOneRequiredWithoutCALLInput
    USER?: USERUpdateOneRequiredWithoutCALLInput
    CART?: CARTUpdateOneWithoutCALLInput
  }

  export type CALLUncheckedUpdateWithoutORDERInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    CART?: CARTUncheckedUpdateOneWithoutCALLInput
  }

  export type USERUpsertWithoutORDERInput = {
    update: XOR<USERUpdateWithoutORDERInput, USERUncheckedUpdateWithoutORDERInput>
    create: XOR<USERCreateWithoutORDERInput, USERUncheckedCreateWithoutORDERInput>
  }

  export type USERUpdateWithoutORDERInput = {
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUpdateOneWithoutUSERInput
    CART?: CARTUpdateOneWithoutUSERInput
    CHAT?: CHATUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUpdateOneWithoutUSERInput
    REPORT?: REPORTUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUpdateOneWithoutUSERInput
  }

  export type USERUncheckedUpdateWithoutORDERInput = {
    seq?: IntFieldUpdateOperationsInput | number
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUncheckedUpdateOneWithoutUSERInput
    CART?: CARTUncheckedUpdateOneWithoutUSERInput
    CHAT?: CHATUncheckedUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedUpdateOneWithoutUSERInput
    REPORT?: REPORTUncheckedUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedUpdateOneWithoutUSERInput
  }

  export type USER_REVIEWUpsertWithoutORDER_ORDERToUSER_REVIEW_seqInput = {
    update: XOR<USER_REVIEWUpdateWithoutORDER_ORDERToUSER_REVIEW_seqInput, USER_REVIEWUncheckedUpdateWithoutORDER_ORDERToUSER_REVIEW_seqInput>
    create: XOR<USER_REVIEWCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput, USER_REVIEWUncheckedCreateWithoutORDER_ORDERToUSER_REVIEW_seqInput>
  }

  export type USER_REVIEWUpdateWithoutORDER_ORDERToUSER_REVIEW_seqInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    USER?: USERUpdateOneRequiredWithoutUSER_REVIEWInput
    ORDER_ORDER_seqToUSER_REVIEW?: ORDERUpdateOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
  }

  export type USER_REVIEWUncheckedUpdateWithoutORDER_ORDERToUSER_REVIEW_seqInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ORDER_ORDER_seqToUSER_REVIEW?: ORDERUncheckedUpdateOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
  }

  export type RESTAURANTCreateWithoutREPLYInput = {
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    LOCATION?: LOCATIONCreateNestedOneWithoutRESTAURANTInput
    RUN_TIME?: RUN_TIMECreateNestedOneWithoutRESTAURANTInput
    CALL?: CALLCreateNestedOneWithoutRESTAURANTInput
    MENU?: MENUCreateNestedOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedCreateWithoutREPLYInput = {
    seq?: number
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    CALL?: CALLUncheckedCreateNestedOneWithoutRESTAURANTInput
    MENU?: MENUUncheckedCreateNestedOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTCreateOrConnectWithoutREPLYInput = {
    where: RESTAURANTWhereUniqueInput
    create: XOR<RESTAURANTCreateWithoutREPLYInput, RESTAURANTUncheckedCreateWithoutREPLYInput>
  }

  export type RES_REVIEWCreateWithoutREPLYInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content: string
    image?: string | null
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutRES_REVIEWInput
    USER?: USERCreateNestedOneWithoutRES_REVIEWInput
    ORDER?: ORDERCreateNestedOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWUncheckedCreateWithoutREPLYInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content: string
    image?: string | null
    ORDER?: ORDERUncheckedCreateNestedOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWCreateOrConnectWithoutREPLYInput = {
    where: RES_REVIEWWhereUniqueInput
    create: XOR<RES_REVIEWCreateWithoutREPLYInput, RES_REVIEWUncheckedCreateWithoutREPLYInput>
  }

  export type RESTAURANTUpsertWithoutREPLYInput = {
    update: XOR<RESTAURANTUpdateWithoutREPLYInput, RESTAURANTUncheckedUpdateWithoutREPLYInput>
    create: XOR<RESTAURANTCreateWithoutREPLYInput, RESTAURANTUncheckedCreateWithoutREPLYInput>
  }

  export type RESTAURANTUpdateWithoutREPLYInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    LOCATION?: LOCATIONUpdateOneRequiredWithoutRESTAURANTInput
    RUN_TIME?: RUN_TIMEUpdateOneRequiredWithoutRESTAURANTInput
    CALL?: CALLUpdateOneWithoutRESTAURANTInput
    MENU?: MENUUpdateOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedUpdateWithoutREPLYInput = {
    seq?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    CALL?: CALLUncheckedUpdateOneWithoutRESTAURANTInput
    MENU?: MENUUncheckedUpdateOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutRESTAURANTInput
  }

  export type RES_REVIEWUpsertWithoutREPLYInput = {
    update: XOR<RES_REVIEWUpdateWithoutREPLYInput, RES_REVIEWUncheckedUpdateWithoutREPLYInput>
    create: XOR<RES_REVIEWCreateWithoutREPLYInput, RES_REVIEWUncheckedCreateWithoutREPLYInput>
  }

  export type RES_REVIEWUpdateWithoutREPLYInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutRES_REVIEWInput
    USER?: USERUpdateOneRequiredWithoutRES_REVIEWInput
    ORDER?: ORDERUpdateOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWUncheckedUpdateWithoutREPLYInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    ORDER?: ORDERUncheckedUpdateOneWithoutRES_REVIEWInput
  }

  export type USERCreateWithoutREPORTInput = {
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLCreateNestedOneWithoutUSERInput
    CART?: CARTCreateNestedOneWithoutUSERInput
    CHAT?: CHATCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGECreateNestedOneWithoutUSERInput
    ORDER?: ORDERCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWCreateNestedOneWithoutUSERInput
  }

  export type USERUncheckedCreateWithoutREPORTInput = {
    seq?: number
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLUncheckedCreateNestedOneWithoutUSERInput
    CART?: CARTUncheckedCreateNestedOneWithoutUSERInput
    CHAT?: CHATUncheckedCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedCreateNestedOneWithoutUSERInput
    ORDER?: ORDERUncheckedCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedCreateNestedOneWithoutUSERInput
  }

  export type USERCreateOrConnectWithoutREPORTInput = {
    where: USERWhereUniqueInput
    create: XOR<USERCreateWithoutREPORTInput, USERUncheckedCreateWithoutREPORTInput>
  }

  export type USERUpsertWithoutREPORTInput = {
    update: XOR<USERUpdateWithoutREPORTInput, USERUncheckedUpdateWithoutREPORTInput>
    create: XOR<USERCreateWithoutREPORTInput, USERUncheckedCreateWithoutREPORTInput>
  }

  export type USERUpdateWithoutREPORTInput = {
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUpdateOneWithoutUSERInput
    CART?: CARTUpdateOneWithoutUSERInput
    CHAT?: CHATUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUpdateOneWithoutUSERInput
    ORDER?: ORDERUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUpdateOneWithoutUSERInput
  }

  export type USERUncheckedUpdateWithoutREPORTInput = {
    seq?: IntFieldUpdateOperationsInput | number
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUncheckedUpdateOneWithoutUSERInput
    CART?: CARTUncheckedUpdateOneWithoutUSERInput
    CHAT?: CHATUncheckedUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedUpdateOneWithoutUSERInput
    ORDER?: ORDERUncheckedUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedUpdateOneWithoutUSERInput
  }

  export type RESTAURANTCreateWithoutRES_REVIEWInput = {
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    LOCATION?: LOCATIONCreateNestedOneWithoutRESTAURANTInput
    RUN_TIME?: RUN_TIMECreateNestedOneWithoutRESTAURANTInput
    CALL?: CALLCreateNestedOneWithoutRESTAURANTInput
    MENU?: MENUCreateNestedOneWithoutRESTAURANTInput
    REPLY?: REPLYCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedCreateWithoutRES_REVIEWInput = {
    seq?: number
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    CALL?: CALLUncheckedCreateNestedOneWithoutRESTAURANTInput
    MENU?: MENUUncheckedCreateNestedOneWithoutRESTAURANTInput
    REPLY?: REPLYUncheckedCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTCreateOrConnectWithoutRES_REVIEWInput = {
    where: RESTAURANTWhereUniqueInput
    create: XOR<RESTAURANTCreateWithoutRES_REVIEWInput, RESTAURANTUncheckedCreateWithoutRES_REVIEWInput>
  }

  export type REPLYCreateWithoutRES_REVIEWInput = {
    content: string
    createdAt: Date | string
    updatedAt?: Date | string | null
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutREPLYInput
  }

  export type REPLYUncheckedCreateWithoutRES_REVIEWInput = {
    seq?: number
    content: string
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type REPLYCreateOrConnectWithoutRES_REVIEWInput = {
    where: REPLYWhereUniqueInput
    create: XOR<REPLYCreateWithoutRES_REVIEWInput, REPLYUncheckedCreateWithoutRES_REVIEWInput>
  }

  export type USERCreateWithoutRES_REVIEWInput = {
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLCreateNestedOneWithoutUSERInput
    CART?: CARTCreateNestedOneWithoutUSERInput
    CHAT?: CHATCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGECreateNestedOneWithoutUSERInput
    ORDER?: ORDERCreateNestedOneWithoutUSERInput
    REPORT?: REPORTCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWCreateNestedOneWithoutUSERInput
  }

  export type USERUncheckedCreateWithoutRES_REVIEWInput = {
    seq?: number
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLUncheckedCreateNestedOneWithoutUSERInput
    CART?: CARTUncheckedCreateNestedOneWithoutUSERInput
    CHAT?: CHATUncheckedCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedCreateNestedOneWithoutUSERInput
    ORDER?: ORDERUncheckedCreateNestedOneWithoutUSERInput
    REPORT?: REPORTUncheckedCreateNestedOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedCreateNestedOneWithoutUSERInput
  }

  export type USERCreateOrConnectWithoutRES_REVIEWInput = {
    where: USERWhereUniqueInput
    create: XOR<USERCreateWithoutRES_REVIEWInput, USERUncheckedCreateWithoutRES_REVIEWInput>
  }

  export type ORDERCreateWithoutRES_REVIEWInput = {
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: USER_REVIEWCreateNestedOneWithoutORDER_ORDER_seqToUSER_REVIEWInput
    CALL?: CALLCreateNestedOneWithoutORDERInput
    USER?: USERCreateNestedOneWithoutORDERInput
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWCreateNestedOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERUncheckedCreateWithoutRES_REVIEWInput = {
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUncheckedCreateNestedOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERCreateOrConnectWithoutRES_REVIEWInput = {
    where: ORDERWhereUniqueInput
    create: XOR<ORDERCreateWithoutRES_REVIEWInput, ORDERUncheckedCreateWithoutRES_REVIEWInput>
  }

  export type RESTAURANTUpsertWithoutRES_REVIEWInput = {
    update: XOR<RESTAURANTUpdateWithoutRES_REVIEWInput, RESTAURANTUncheckedUpdateWithoutRES_REVIEWInput>
    create: XOR<RESTAURANTCreateWithoutRES_REVIEWInput, RESTAURANTUncheckedCreateWithoutRES_REVIEWInput>
  }

  export type RESTAURANTUpdateWithoutRES_REVIEWInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    LOCATION?: LOCATIONUpdateOneRequiredWithoutRESTAURANTInput
    RUN_TIME?: RUN_TIMEUpdateOneRequiredWithoutRESTAURANTInput
    CALL?: CALLUpdateOneWithoutRESTAURANTInput
    MENU?: MENUUpdateOneWithoutRESTAURANTInput
    REPLY?: REPLYUpdateOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedUpdateWithoutRES_REVIEWInput = {
    seq?: IntFieldUpdateOperationsInput | number
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    CALL?: CALLUncheckedUpdateOneWithoutRESTAURANTInput
    MENU?: MENUUncheckedUpdateOneWithoutRESTAURANTInput
    REPLY?: REPLYUncheckedUpdateOneWithoutRESTAURANTInput
  }

  export type REPLYUpsertWithoutRES_REVIEWInput = {
    update: XOR<REPLYUpdateWithoutRES_REVIEWInput, REPLYUncheckedUpdateWithoutRES_REVIEWInput>
    create: XOR<REPLYCreateWithoutRES_REVIEWInput, REPLYUncheckedCreateWithoutRES_REVIEWInput>
  }

  export type REPLYUpdateWithoutRES_REVIEWInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutREPLYInput
  }

  export type REPLYUncheckedUpdateWithoutRES_REVIEWInput = {
    seq?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type USERUpsertWithoutRES_REVIEWInput = {
    update: XOR<USERUpdateWithoutRES_REVIEWInput, USERUncheckedUpdateWithoutRES_REVIEWInput>
    create: XOR<USERCreateWithoutRES_REVIEWInput, USERUncheckedCreateWithoutRES_REVIEWInput>
  }

  export type USERUpdateWithoutRES_REVIEWInput = {
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUpdateOneWithoutUSERInput
    CART?: CARTUpdateOneWithoutUSERInput
    CHAT?: CHATUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUpdateOneWithoutUSERInput
    ORDER?: ORDERUpdateOneWithoutUSERInput
    REPORT?: REPORTUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUpdateOneWithoutUSERInput
  }

  export type USERUncheckedUpdateWithoutRES_REVIEWInput = {
    seq?: IntFieldUpdateOperationsInput | number
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUncheckedUpdateOneWithoutUSERInput
    CART?: CARTUncheckedUpdateOneWithoutUSERInput
    CHAT?: CHATUncheckedUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedUpdateOneWithoutUSERInput
    ORDER?: ORDERUncheckedUpdateOneWithoutUSERInput
    REPORT?: REPORTUncheckedUpdateOneWithoutUSERInput
    USER_REVIEW?: USER_REVIEWUncheckedUpdateOneWithoutUSERInput
  }

  export type ORDERUpsertWithoutRES_REVIEWInput = {
    update: XOR<ORDERUpdateWithoutRES_REVIEWInput, ORDERUncheckedUpdateWithoutRES_REVIEWInput>
    create: XOR<ORDERCreateWithoutRES_REVIEWInput, ORDERUncheckedCreateWithoutRES_REVIEWInput>
  }

  export type ORDERUpdateWithoutRES_REVIEWInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: USER_REVIEWUpdateOneRequiredWithoutORDER_ORDER_seqToUSER_REVIEWInput
    CALL?: CALLUpdateOneRequiredWithoutORDERInput
    USER?: USERUpdateOneRequiredWithoutORDERInput
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUpdateOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERUncheckedUpdateWithoutRES_REVIEWInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUncheckedUpdateOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type LOCATIONCreateWithoutRESTAURANTInput = {
    latitude: number
    longitude: number
    address: string
    CALL?: CALLCreateNestedOneWithoutLOCATIONInput
  }

  export type LOCATIONUncheckedCreateWithoutRESTAURANTInput = {
    seq?: number
    latitude: number
    longitude: number
    address: string
    CALL?: CALLUncheckedCreateNestedOneWithoutLOCATIONInput
  }

  export type LOCATIONCreateOrConnectWithoutRESTAURANTInput = {
    where: LOCATIONWhereUniqueInput
    create: XOR<LOCATIONCreateWithoutRESTAURANTInput, LOCATIONUncheckedCreateWithoutRESTAURANTInput>
  }

  export type RUN_TIMECreateWithoutRESTAURANTInput = {
    day: string
    open: Date | string
    close: Date | string
  }

  export type RUN_TIMEUncheckedCreateWithoutRESTAURANTInput = {
    seq?: number
    day: string
    open: Date | string
    close: Date | string
  }

  export type RUN_TIMECreateOrConnectWithoutRESTAURANTInput = {
    where: RUN_TIMEWhereUniqueInput
    create: XOR<RUN_TIMECreateWithoutRESTAURANTInput, RUN_TIMEUncheckedCreateWithoutRESTAURANTInput>
  }

  export type CALLCreateWithoutRESTAURANTInput = {
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
    LOCATION?: LOCATIONCreateNestedOneWithoutCALLInput
    USER?: USERCreateNestedOneWithoutCALLInput
    CART?: CARTCreateNestedOneWithoutCALLInput
    ORDER?: ORDERCreateNestedOneWithoutCALLInput
  }

  export type CALLUncheckedCreateWithoutRESTAURANTInput = {
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
    CART?: CARTUncheckedCreateNestedOneWithoutCALLInput
    ORDER?: ORDERUncheckedCreateNestedOneWithoutCALLInput
  }

  export type CALLCreateOrConnectWithoutRESTAURANTInput = {
    where: CALLWhereUniqueInput
    create: XOR<CALLCreateWithoutRESTAURANTInput, CALLUncheckedCreateWithoutRESTAURANTInput>
  }

  export type MENUCreateWithoutRESTAURANTInput = {
    name: string
    thumbnail?: string | null
    description?: string | null
    price: number
    isAvailable?: boolean
    bestmenu?: boolean
    OPTION?: OPTIONCreateNestedOneWithoutMENUInput
    SELECTED_MENU?: SELECTED_MENUCreateNestedOneWithoutMENUInput
  }

  export type MENUUncheckedCreateWithoutRESTAURANTInput = {
    name: string
    thumbnail?: string | null
    description?: string | null
    price: number
    isAvailable?: boolean
    bestmenu?: boolean
    OPTION?: OPTIONUncheckedCreateNestedOneWithoutMENUInput
    SELECTED_MENU?: SELECTED_MENUUncheckedCreateNestedOneWithoutMENUInput
  }

  export type MENUCreateOrConnectWithoutRESTAURANTInput = {
    where: MENUWhereUniqueInput
    create: XOR<MENUCreateWithoutRESTAURANTInput, MENUUncheckedCreateWithoutRESTAURANTInput>
  }

  export type REPLYCreateWithoutRESTAURANTInput = {
    content: string
    createdAt: Date | string
    updatedAt?: Date | string | null
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutREPLYInput
  }

  export type REPLYUncheckedCreateWithoutRESTAURANTInput = {
    content: string
    createdAt: Date | string
    updatedAt?: Date | string | null
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutREPLYInput
  }

  export type REPLYCreateOrConnectWithoutRESTAURANTInput = {
    where: REPLYWhereUniqueInput
    create: XOR<REPLYCreateWithoutRESTAURANTInput, REPLYUncheckedCreateWithoutRESTAURANTInput>
  }

  export type RES_REVIEWCreateWithoutRESTAURANTInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content: string
    image?: string | null
    REPLY?: REPLYCreateNestedOneWithoutRES_REVIEWInput
    USER?: USERCreateNestedOneWithoutRES_REVIEWInput
    ORDER?: ORDERCreateNestedOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWUncheckedCreateWithoutRESTAURANTInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content: string
    image?: string | null
    ORDER?: ORDERUncheckedCreateNestedOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWCreateOrConnectWithoutRESTAURANTInput = {
    where: RES_REVIEWWhereUniqueInput
    create: XOR<RES_REVIEWCreateWithoutRESTAURANTInput, RES_REVIEWUncheckedCreateWithoutRESTAURANTInput>
  }

  export type LOCATIONUpsertWithoutRESTAURANTInput = {
    update: XOR<LOCATIONUpdateWithoutRESTAURANTInput, LOCATIONUncheckedUpdateWithoutRESTAURANTInput>
    create: XOR<LOCATIONCreateWithoutRESTAURANTInput, LOCATIONUncheckedCreateWithoutRESTAURANTInput>
  }

  export type LOCATIONUpdateWithoutRESTAURANTInput = {
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    CALL?: CALLUpdateOneWithoutLOCATIONInput
  }

  export type LOCATIONUncheckedUpdateWithoutRESTAURANTInput = {
    seq?: IntFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    address?: StringFieldUpdateOperationsInput | string
    CALL?: CALLUncheckedUpdateOneWithoutLOCATIONInput
  }

  export type RUN_TIMEUpsertWithoutRESTAURANTInput = {
    update: XOR<RUN_TIMEUpdateWithoutRESTAURANTInput, RUN_TIMEUncheckedUpdateWithoutRESTAURANTInput>
    create: XOR<RUN_TIMECreateWithoutRESTAURANTInput, RUN_TIMEUncheckedCreateWithoutRESTAURANTInput>
  }

  export type RUN_TIMEUpdateWithoutRESTAURANTInput = {
    day?: StringFieldUpdateOperationsInput | string
    open?: DateTimeFieldUpdateOperationsInput | Date | string
    close?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RUN_TIMEUncheckedUpdateWithoutRESTAURANTInput = {
    seq?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    open?: DateTimeFieldUpdateOperationsInput | Date | string
    close?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CALLUpsertWithoutRESTAURANTInput = {
    update: XOR<CALLUpdateWithoutRESTAURANTInput, CALLUncheckedUpdateWithoutRESTAURANTInput>
    create: XOR<CALLCreateWithoutRESTAURANTInput, CALLUncheckedCreateWithoutRESTAURANTInput>
  }

  export type CALLUpdateWithoutRESTAURANTInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    LOCATION?: LOCATIONUpdateOneRequiredWithoutCALLInput
    USER?: USERUpdateOneRequiredWithoutCALLInput
    CART?: CARTUpdateOneWithoutCALLInput
    ORDER?: ORDERUpdateOneWithoutCALLInput
  }

  export type CALLUncheckedUpdateWithoutRESTAURANTInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    CART?: CARTUncheckedUpdateOneWithoutCALLInput
    ORDER?: ORDERUncheckedUpdateOneWithoutCALLInput
  }

  export type MENUUpsertWithoutRESTAURANTInput = {
    update: XOR<MENUUpdateWithoutRESTAURANTInput, MENUUncheckedUpdateWithoutRESTAURANTInput>
    create: XOR<MENUCreateWithoutRESTAURANTInput, MENUUncheckedCreateWithoutRESTAURANTInput>
  }

  export type MENUUpdateWithoutRESTAURANTInput = {
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bestmenu?: BoolFieldUpdateOperationsInput | boolean
    OPTION?: OPTIONUpdateOneWithoutMENUInput
    SELECTED_MENU?: SELECTED_MENUUpdateOneWithoutMENUInput
  }

  export type MENUUncheckedUpdateWithoutRESTAURANTInput = {
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bestmenu?: BoolFieldUpdateOperationsInput | boolean
    OPTION?: OPTIONUncheckedUpdateOneWithoutMENUInput
    SELECTED_MENU?: SELECTED_MENUUncheckedUpdateOneWithoutMENUInput
  }

  export type REPLYUpsertWithoutRESTAURANTInput = {
    update: XOR<REPLYUpdateWithoutRESTAURANTInput, REPLYUncheckedUpdateWithoutRESTAURANTInput>
    create: XOR<REPLYCreateWithoutRESTAURANTInput, REPLYUncheckedCreateWithoutRESTAURANTInput>
  }

  export type REPLYUpdateWithoutRESTAURANTInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutREPLYInput
  }

  export type REPLYUncheckedUpdateWithoutRESTAURANTInput = {
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutREPLYInput
  }

  export type RES_REVIEWUpsertWithoutRESTAURANTInput = {
    update: XOR<RES_REVIEWUpdateWithoutRESTAURANTInput, RES_REVIEWUncheckedUpdateWithoutRESTAURANTInput>
    create: XOR<RES_REVIEWCreateWithoutRESTAURANTInput, RES_REVIEWUncheckedCreateWithoutRESTAURANTInput>
  }

  export type RES_REVIEWUpdateWithoutRESTAURANTInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    REPLY?: REPLYUpdateOneRequiredWithoutRES_REVIEWInput
    USER?: USERUpdateOneRequiredWithoutRES_REVIEWInput
    ORDER?: ORDERUpdateOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWUncheckedUpdateWithoutRESTAURANTInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    ORDER?: ORDERUncheckedUpdateOneWithoutRES_REVIEWInput
  }

  export type RESTAURANTCreateWithoutRUN_TIMEInput = {
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    LOCATION?: LOCATIONCreateNestedOneWithoutRESTAURANTInput
    CALL?: CALLCreateNestedOneWithoutRESTAURANTInput
    MENU?: MENUCreateNestedOneWithoutRESTAURANTInput
    REPLY?: REPLYCreateNestedOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedCreateWithoutRUN_TIMEInput = {
    id: string
    password: string
    createdAt: Date | string
    dayoff: string
    isOpen: boolean
    minOrder: number
    deliveryTip: number
    seperatable: boolean
    introduction?: string | null
    thumbnail?: string | null
    rate?: number
    category: string
    CALL?: CALLUncheckedCreateNestedOneWithoutRESTAURANTInput
    MENU?: MENUUncheckedCreateNestedOneWithoutRESTAURANTInput
    REPLY?: REPLYUncheckedCreateNestedOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutRESTAURANTInput
  }

  export type RESTAURANTCreateOrConnectWithoutRUN_TIMEInput = {
    where: RESTAURANTWhereUniqueInput
    create: XOR<RESTAURANTCreateWithoutRUN_TIMEInput, RESTAURANTUncheckedCreateWithoutRUN_TIMEInput>
  }

  export type RESTAURANTUpsertWithoutRUN_TIMEInput = {
    update: XOR<RESTAURANTUpdateWithoutRUN_TIMEInput, RESTAURANTUncheckedUpdateWithoutRUN_TIMEInput>
    create: XOR<RESTAURANTCreateWithoutRUN_TIMEInput, RESTAURANTUncheckedCreateWithoutRUN_TIMEInput>
  }

  export type RESTAURANTUpdateWithoutRUN_TIMEInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    LOCATION?: LOCATIONUpdateOneRequiredWithoutRESTAURANTInput
    CALL?: CALLUpdateOneWithoutRESTAURANTInput
    MENU?: MENUUpdateOneWithoutRESTAURANTInput
    REPLY?: REPLYUpdateOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutRESTAURANTInput
  }

  export type RESTAURANTUncheckedUpdateWithoutRUN_TIMEInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dayoff?: StringFieldUpdateOperationsInput | string
    isOpen?: BoolFieldUpdateOperationsInput | boolean
    minOrder?: IntFieldUpdateOperationsInput | number
    deliveryTip?: IntFieldUpdateOperationsInput | number
    seperatable?: BoolFieldUpdateOperationsInput | boolean
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    CALL?: CALLUncheckedUpdateOneWithoutRESTAURANTInput
    MENU?: MENUUncheckedUpdateOneWithoutRESTAURANTInput
    REPLY?: REPLYUncheckedUpdateOneWithoutRESTAURANTInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutRESTAURANTInput
  }

  export type OPTION_ITEMCreateWithoutSELECTED_MENUInput = {
    content: string
    price: number
    OPTION?: OPTIONCreateNestedOneWithoutOPTION_ITEMInput
  }

  export type OPTION_ITEMUncheckedCreateWithoutSELECTED_MENUInput = {
    seq?: number
    content: string
    price: number
  }

  export type OPTION_ITEMCreateOrConnectWithoutSELECTED_MENUInput = {
    where: OPTION_ITEMWhereUniqueInput
    create: XOR<OPTION_ITEMCreateWithoutSELECTED_MENUInput, OPTION_ITEMUncheckedCreateWithoutSELECTED_MENUInput>
  }

  export type MENUCreateWithoutSELECTED_MENUInput = {
    name: string
    thumbnail?: string | null
    description?: string | null
    price: number
    isAvailable?: boolean
    bestmenu?: boolean
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutMENUInput
    OPTION?: OPTIONCreateNestedOneWithoutMENUInput
  }

  export type MENUUncheckedCreateWithoutSELECTED_MENUInput = {
    seq?: number
    name: string
    thumbnail?: string | null
    description?: string | null
    price: number
    isAvailable?: boolean
    bestmenu?: boolean
    OPTION?: OPTIONUncheckedCreateNestedOneWithoutMENUInput
  }

  export type MENUCreateOrConnectWithoutSELECTED_MENUInput = {
    where: MENUWhereUniqueInput
    create: XOR<MENUCreateWithoutSELECTED_MENUInput, MENUUncheckedCreateWithoutSELECTED_MENUInput>
  }

  export type CARTCreateWithoutSELECTED_MENUInput = {
    request?: string | null
    CALL?: CALLCreateNestedOneWithoutCARTInput
    USER?: USERCreateNestedOneWithoutCARTInput
  }

  export type CARTUncheckedCreateWithoutSELECTED_MENUInput = {
    request?: string | null
  }

  export type CARTCreateOrConnectWithoutSELECTED_MENUInput = {
    where: CARTWhereUniqueInput
    create: XOR<CARTCreateWithoutSELECTED_MENUInput, CARTUncheckedCreateWithoutSELECTED_MENUInput>
  }

  export type OPTION_ITEMUpsertWithoutSELECTED_MENUInput = {
    update: XOR<OPTION_ITEMUpdateWithoutSELECTED_MENUInput, OPTION_ITEMUncheckedUpdateWithoutSELECTED_MENUInput>
    create: XOR<OPTION_ITEMCreateWithoutSELECTED_MENUInput, OPTION_ITEMUncheckedCreateWithoutSELECTED_MENUInput>
  }

  export type OPTION_ITEMUpdateWithoutSELECTED_MENUInput = {
    content?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    OPTION?: OPTIONUpdateOneRequiredWithoutOPTION_ITEMInput
  }

  export type OPTION_ITEMUncheckedUpdateWithoutSELECTED_MENUInput = {
    seq?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type MENUUpsertWithoutSELECTED_MENUInput = {
    update: XOR<MENUUpdateWithoutSELECTED_MENUInput, MENUUncheckedUpdateWithoutSELECTED_MENUInput>
    create: XOR<MENUCreateWithoutSELECTED_MENUInput, MENUUncheckedCreateWithoutSELECTED_MENUInput>
  }

  export type MENUUpdateWithoutSELECTED_MENUInput = {
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bestmenu?: BoolFieldUpdateOperationsInput | boolean
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutMENUInput
    OPTION?: OPTIONUpdateOneWithoutMENUInput
  }

  export type MENUUncheckedUpdateWithoutSELECTED_MENUInput = {
    seq?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    bestmenu?: BoolFieldUpdateOperationsInput | boolean
    OPTION?: OPTIONUncheckedUpdateOneWithoutMENUInput
  }

  export type CARTUpsertWithoutSELECTED_MENUInput = {
    update: XOR<CARTUpdateWithoutSELECTED_MENUInput, CARTUncheckedUpdateWithoutSELECTED_MENUInput>
    create: XOR<CARTCreateWithoutSELECTED_MENUInput, CARTUncheckedCreateWithoutSELECTED_MENUInput>
  }

  export type CARTUpdateWithoutSELECTED_MENUInput = {
    request?: NullableStringFieldUpdateOperationsInput | string | null
    CALL?: CALLUpdateOneRequiredWithoutCARTInput
    USER?: USERUpdateOneRequiredWithoutCARTInput
  }

  export type CARTUncheckedUpdateWithoutSELECTED_MENUInput = {
    request?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CALLCreateWithoutUSERInput = {
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutCALLInput
    LOCATION?: LOCATIONCreateNestedOneWithoutCALLInput
    CART?: CARTCreateNestedOneWithoutCALLInput
    ORDER?: ORDERCreateNestedOneWithoutCALLInput
  }

  export type CALLUncheckedCreateWithoutUSERInput = {
    createdAt?: Date | string | null
    expiredAt?: Date | string | null
    status?: CALL_status | null
    calltext?: string | null
    price: number
    CART?: CARTUncheckedCreateNestedOneWithoutCALLInput
    ORDER?: ORDERUncheckedCreateNestedOneWithoutCALLInput
  }

  export type CALLCreateOrConnectWithoutUSERInput = {
    where: CALLWhereUniqueInput
    create: XOR<CALLCreateWithoutUSERInput, CALLUncheckedCreateWithoutUSERInput>
  }

  export type CARTCreateWithoutUSERInput = {
    request?: string | null
    CALL?: CALLCreateNestedOneWithoutCARTInput
    SELECTED_MENU?: SELECTED_MENUCreateNestedOneWithoutCARTInput
  }

  export type CARTUncheckedCreateWithoutUSERInput = {
    request?: string | null
  }

  export type CARTCreateOrConnectWithoutUSERInput = {
    where: CARTWhereUniqueInput
    create: XOR<CARTCreateWithoutUSERInput, CARTUncheckedCreateWithoutUSERInput>
  }

  export type CHATCreateWithoutUSERInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    MESSAGE_CHAT_seqToMESSAGE?: MESSAGECreateNestedOneWithoutCHAT_CHAT_seqToMESSAGEInput
    MESSAGE_CHATToMESSAGE_seq?: MESSAGECreateNestedOneWithoutCHAT_CHATToMESSAGE_seqInput
  }

  export type CHATUncheckedCreateWithoutUSERInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    MESSAGE_CHATToMESSAGE_seq?: MESSAGEUncheckedCreateNestedOneWithoutCHAT_CHATToMESSAGE_seqInput
  }

  export type CHATCreateOrConnectWithoutUSERInput = {
    where: CHATWhereUniqueInput
    create: XOR<CHATCreateWithoutUSERInput, CHATUncheckedCreateWithoutUSERInput>
  }

  export type MESSAGECreateWithoutUSERInput = {
    text: string
    isRead?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
    CHAT_CHATToMESSAGE_seq?: CHATCreateNestedOneWithoutMESSAGE_CHATToMESSAGE_seqInput
    CHAT_CHAT_seqToMESSAGE?: CHATCreateNestedOneWithoutMESSAGE_CHAT_seqToMESSAGEInput
  }

  export type MESSAGEUncheckedCreateWithoutUSERInput = {
    text: string
    isRead?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
    CHAT_CHAT_seqToMESSAGE?: CHATUncheckedCreateNestedOneWithoutMESSAGE_CHAT_seqToMESSAGEInput
  }

  export type MESSAGECreateOrConnectWithoutUSERInput = {
    where: MESSAGEWhereUniqueInput
    create: XOR<MESSAGECreateWithoutUSERInput, MESSAGEUncheckedCreateWithoutUSERInput>
  }

  export type ORDERCreateWithoutUSERInput = {
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutORDERInput
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: USER_REVIEWCreateNestedOneWithoutORDER_ORDER_seqToUSER_REVIEWInput
    CALL?: CALLCreateNestedOneWithoutORDERInput
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWCreateNestedOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERUncheckedCreateWithoutUSERInput = {
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUncheckedCreateNestedOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERCreateOrConnectWithoutUSERInput = {
    where: ORDERWhereUniqueInput
    create: XOR<ORDERCreateWithoutUSERInput, ORDERUncheckedCreateWithoutUSERInput>
  }

  export type REPORTCreateWithoutUSERInput = {
    reason: string
    isSolved?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type REPORTUncheckedCreateWithoutUSERInput = {
    reason: string
    isSolved?: boolean
    createdAt: Date | string
    updatedAt?: Date | string | null
  }

  export type REPORTCreateOrConnectWithoutUSERInput = {
    where: REPORTWhereUniqueInput
    create: XOR<REPORTCreateWithoutUSERInput, REPORTUncheckedCreateWithoutUSERInput>
  }

  export type RES_REVIEWCreateWithoutUSERInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content: string
    image?: string | null
    RESTAURANT?: RESTAURANTCreateNestedOneWithoutRES_REVIEWInput
    REPLY?: REPLYCreateNestedOneWithoutRES_REVIEWInput
    ORDER?: ORDERCreateNestedOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWUncheckedCreateWithoutUSERInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content: string
    image?: string | null
    ORDER?: ORDERUncheckedCreateNestedOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWCreateOrConnectWithoutUSERInput = {
    where: RES_REVIEWWhereUniqueInput
    create: XOR<RES_REVIEWCreateWithoutUSERInput, RES_REVIEWUncheckedCreateWithoutUSERInput>
  }

  export type USER_REVIEWCreateWithoutUSERInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content?: string | null
    ORDER_ORDERToUSER_REVIEW_seq?: ORDERCreateNestedOneWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput
    ORDER_ORDER_seqToUSER_REVIEW?: ORDERCreateNestedOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
  }

  export type USER_REVIEWUncheckedCreateWithoutUSERInput = {
    createdAt: Date | string
    updatedAt?: Date | string | null
    rate?: number
    content?: string | null
    ORDER_ORDER_seqToUSER_REVIEW?: ORDERUncheckedCreateNestedOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
  }

  export type USER_REVIEWCreateOrConnectWithoutUSERInput = {
    where: USER_REVIEWWhereUniqueInput
    create: XOR<USER_REVIEWCreateWithoutUSERInput, USER_REVIEWUncheckedCreateWithoutUSERInput>
  }

  export type CALLUpsertWithoutUSERInput = {
    update: XOR<CALLUpdateWithoutUSERInput, CALLUncheckedUpdateWithoutUSERInput>
    create: XOR<CALLCreateWithoutUSERInput, CALLUncheckedCreateWithoutUSERInput>
  }

  export type CALLUpdateWithoutUSERInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutCALLInput
    LOCATION?: LOCATIONUpdateOneRequiredWithoutCALLInput
    CART?: CARTUpdateOneWithoutCALLInput
    ORDER?: ORDERUpdateOneWithoutCALLInput
  }

  export type CALLUncheckedUpdateWithoutUSERInput = {
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableEnumCALL_statusFieldUpdateOperationsInput | CALL_status | null
    calltext?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    CART?: CARTUncheckedUpdateOneWithoutCALLInput
    ORDER?: ORDERUncheckedUpdateOneWithoutCALLInput
  }

  export type CARTUpsertWithoutUSERInput = {
    update: XOR<CARTUpdateWithoutUSERInput, CARTUncheckedUpdateWithoutUSERInput>
    create: XOR<CARTCreateWithoutUSERInput, CARTUncheckedCreateWithoutUSERInput>
  }

  export type CARTUpdateWithoutUSERInput = {
    request?: NullableStringFieldUpdateOperationsInput | string | null
    CALL?: CALLUpdateOneRequiredWithoutCARTInput
    SELECTED_MENU?: SELECTED_MENUUpdateOneRequiredWithoutCARTInput
  }

  export type CARTUncheckedUpdateWithoutUSERInput = {
    request?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CHATUpsertWithoutUSERInput = {
    update: XOR<CHATUpdateWithoutUSERInput, CHATUncheckedUpdateWithoutUSERInput>
    create: XOR<CHATCreateWithoutUSERInput, CHATUncheckedCreateWithoutUSERInput>
  }

  export type CHATUpdateWithoutUSERInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MESSAGE_CHAT_seqToMESSAGE?: MESSAGEUpdateOneRequiredWithoutCHAT_CHAT_seqToMESSAGEInput
    MESSAGE_CHATToMESSAGE_seq?: MESSAGEUpdateOneWithoutCHAT_CHATToMESSAGE_seqInput
  }

  export type CHATUncheckedUpdateWithoutUSERInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MESSAGE_CHATToMESSAGE_seq?: MESSAGEUncheckedUpdateOneWithoutCHAT_CHATToMESSAGE_seqInput
  }

  export type MESSAGEUpsertWithoutUSERInput = {
    update: XOR<MESSAGEUpdateWithoutUSERInput, MESSAGEUncheckedUpdateWithoutUSERInput>
    create: XOR<MESSAGECreateWithoutUSERInput, MESSAGEUncheckedCreateWithoutUSERInput>
  }

  export type MESSAGEUpdateWithoutUSERInput = {
    text?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CHAT_CHATToMESSAGE_seq?: CHATUpdateOneRequiredWithoutMESSAGE_CHATToMESSAGE_seqInput
    CHAT_CHAT_seqToMESSAGE?: CHATUpdateOneWithoutMESSAGE_CHAT_seqToMESSAGEInput
  }

  export type MESSAGEUncheckedUpdateWithoutUSERInput = {
    text?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CHAT_CHAT_seqToMESSAGE?: CHATUncheckedUpdateOneWithoutMESSAGE_CHAT_seqToMESSAGEInput
  }

  export type ORDERUpsertWithoutUSERInput = {
    update: XOR<ORDERUpdateWithoutUSERInput, ORDERUncheckedUpdateWithoutUSERInput>
    create: XOR<ORDERCreateWithoutUSERInput, ORDERUncheckedCreateWithoutUSERInput>
  }

  export type ORDERUpdateWithoutUSERInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
    RES_REVIEW?: RES_REVIEWUpdateOneRequiredWithoutORDERInput
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: USER_REVIEWUpdateOneRequiredWithoutORDER_ORDER_seqToUSER_REVIEWInput
    CALL?: CALLUpdateOneRequiredWithoutORDERInput
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUpdateOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERUncheckedUpdateWithoutUSERInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUncheckedUpdateOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type REPORTUpsertWithoutUSERInput = {
    update: XOR<REPORTUpdateWithoutUSERInput, REPORTUncheckedUpdateWithoutUSERInput>
    create: XOR<REPORTCreateWithoutUSERInput, REPORTUncheckedCreateWithoutUSERInput>
  }

  export type REPORTUpdateWithoutUSERInput = {
    reason?: StringFieldUpdateOperationsInput | string
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type REPORTUncheckedUpdateWithoutUSERInput = {
    reason?: StringFieldUpdateOperationsInput | string
    isSolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RES_REVIEWUpsertWithoutUSERInput = {
    update: XOR<RES_REVIEWUpdateWithoutUSERInput, RES_REVIEWUncheckedUpdateWithoutUSERInput>
    create: XOR<RES_REVIEWCreateWithoutUSERInput, RES_REVIEWUncheckedCreateWithoutUSERInput>
  }

  export type RES_REVIEWUpdateWithoutUSERInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    RESTAURANT?: RESTAURANTUpdateOneRequiredWithoutRES_REVIEWInput
    REPLY?: REPLYUpdateOneRequiredWithoutRES_REVIEWInput
    ORDER?: ORDERUpdateOneWithoutRES_REVIEWInput
  }

  export type RES_REVIEWUncheckedUpdateWithoutUSERInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    ORDER?: ORDERUncheckedUpdateOneWithoutRES_REVIEWInput
  }

  export type USER_REVIEWUpsertWithoutUSERInput = {
    update: XOR<USER_REVIEWUpdateWithoutUSERInput, USER_REVIEWUncheckedUpdateWithoutUSERInput>
    create: XOR<USER_REVIEWCreateWithoutUSERInput, USER_REVIEWUncheckedCreateWithoutUSERInput>
  }

  export type USER_REVIEWUpdateWithoutUSERInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ORDER_ORDERToUSER_REVIEW_seq?: ORDERUpdateOneRequiredWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput
    ORDER_ORDER_seqToUSER_REVIEW?: ORDERUpdateOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
  }

  export type USER_REVIEWUncheckedUpdateWithoutUSERInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rate?: IntFieldUpdateOperationsInput | number
    content?: NullableStringFieldUpdateOperationsInput | string | null
    ORDER_ORDER_seqToUSER_REVIEW?: ORDERUncheckedUpdateOneWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput
  }

  export type ORDERCreateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput = {
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutORDERInput
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: USER_REVIEWCreateNestedOneWithoutORDER_ORDER_seqToUSER_REVIEWInput
    CALL?: CALLCreateNestedOneWithoutORDERInput
    USER?: USERCreateNestedOneWithoutORDERInput
  }

  export type ORDERUncheckedCreateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput = {
    seq?: number
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
  }

  export type ORDERCreateOrConnectWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput = {
    where: ORDERWhereUniqueInput
    create: XOR<ORDERCreateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput, ORDERUncheckedCreateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput>
  }

  export type USERCreateWithoutUSER_REVIEWInput = {
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLCreateNestedOneWithoutUSERInput
    CART?: CARTCreateNestedOneWithoutUSERInput
    CHAT?: CHATCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGECreateNestedOneWithoutUSERInput
    ORDER?: ORDERCreateNestedOneWithoutUSERInput
    REPORT?: REPORTCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutUSERInput
  }

  export type USERUncheckedCreateWithoutUSER_REVIEWInput = {
    seq?: number
    ID: string
    password: string
    name: string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
    thumbnail?: string | null
    token: string
    status: USER_status
    CALL?: CALLUncheckedCreateNestedOneWithoutUSERInput
    CART?: CARTUncheckedCreateNestedOneWithoutUSERInput
    CHAT?: CHATUncheckedCreateNestedOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedCreateNestedOneWithoutUSERInput
    ORDER?: ORDERUncheckedCreateNestedOneWithoutUSERInput
    REPORT?: REPORTUncheckedCreateNestedOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedCreateNestedOneWithoutUSERInput
  }

  export type USERCreateOrConnectWithoutUSER_REVIEWInput = {
    where: USERWhereUniqueInput
    create: XOR<USERCreateWithoutUSER_REVIEWInput, USERUncheckedCreateWithoutUSER_REVIEWInput>
  }

  export type ORDERCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput = {
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
    RES_REVIEW?: RES_REVIEWCreateNestedOneWithoutORDERInput
    CALL?: CALLCreateNestedOneWithoutORDERInput
    USER?: USERCreateNestedOneWithoutORDERInput
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWCreateNestedOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERUncheckedCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput = {
    createdAt: Date | string
    updatedAt: Date | string
    deliveryTime: Date | string
    status?: ORDER_status | null
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUncheckedCreateNestedOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERCreateOrConnectWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput = {
    where: ORDERWhereUniqueInput
    create: XOR<ORDERCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput, ORDERUncheckedCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput>
  }

  export type ORDERUpsertWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput = {
    update: XOR<ORDERUpdateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput, ORDERUncheckedUpdateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput>
    create: XOR<ORDERCreateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput, ORDERUncheckedCreateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput>
  }

  export type ORDERUpdateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
    RES_REVIEW?: RES_REVIEWUpdateOneRequiredWithoutORDERInput
    USER_REVIEW_ORDER_seqToUSER_REVIEW?: USER_REVIEWUpdateOneRequiredWithoutORDER_ORDER_seqToUSER_REVIEWInput
    CALL?: CALLUpdateOneRequiredWithoutORDERInput
    USER?: USERUpdateOneRequiredWithoutORDERInput
  }

  export type ORDERUncheckedUpdateWithoutUSER_REVIEW_ORDERToUSER_REVIEW_seqInput = {
    seq?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
  }

  export type USERUpsertWithoutUSER_REVIEWInput = {
    update: XOR<USERUpdateWithoutUSER_REVIEWInput, USERUncheckedUpdateWithoutUSER_REVIEWInput>
    create: XOR<USERCreateWithoutUSER_REVIEWInput, USERUncheckedCreateWithoutUSER_REVIEWInput>
  }

  export type USERUpdateWithoutUSER_REVIEWInput = {
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUpdateOneWithoutUSERInput
    CART?: CARTUpdateOneWithoutUSERInput
    CHAT?: CHATUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUpdateOneWithoutUSERInput
    ORDER?: ORDERUpdateOneWithoutUSERInput
    REPORT?: REPORTUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUpdateOneWithoutUSERInput
  }

  export type USERUncheckedUpdateWithoutUSER_REVIEWInput = {
    seq?: IntFieldUpdateOperationsInput | number
    ID?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    status?: EnumUSER_statusFieldUpdateOperationsInput | USER_status
    CALL?: CALLUncheckedUpdateOneWithoutUSERInput
    CART?: CARTUncheckedUpdateOneWithoutUSERInput
    CHAT?: CHATUncheckedUpdateOneWithoutUSERInput
    MESSAGE?: MESSAGEUncheckedUpdateOneWithoutUSERInput
    ORDER?: ORDERUncheckedUpdateOneWithoutUSERInput
    REPORT?: REPORTUncheckedUpdateOneWithoutUSERInput
    RES_REVIEW?: RES_REVIEWUncheckedUpdateOneWithoutUSERInput
  }

  export type ORDERUpsertWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput = {
    update: XOR<ORDERUpdateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput, ORDERUncheckedUpdateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput>
    create: XOR<ORDERCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput, ORDERUncheckedCreateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput>
  }

  export type ORDERUpdateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
    RES_REVIEW?: RES_REVIEWUpdateOneRequiredWithoutORDERInput
    CALL?: CALLUpdateOneRequiredWithoutORDERInput
    USER?: USERUpdateOneRequiredWithoutORDERInput
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUpdateOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }

  export type ORDERUncheckedUpdateWithoutUSER_REVIEW_ORDER_seqToUSER_REVIEWInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryTime?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: NullableEnumORDER_statusFieldUpdateOperationsInput | ORDER_status | null
    USER_REVIEW_ORDERToUSER_REVIEW_seq?: USER_REVIEWUncheckedUpdateOneWithoutORDER_ORDERToUSER_REVIEW_seqInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}